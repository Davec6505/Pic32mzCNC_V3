# Dev Log — 2025-11-07

## Summary
- Implemented a guard to skip zero-length motion segments at creation time and at load time.
- Fixed an invalid `break` statement in `motion.c` that caused a build error when skipping segments.
- Rebuilt successfully (Release). Output: `bins/Release/CS23.hex`.

## Files changed today
- `srcs/motion/motion.c`
  - In `MOTION_ProcessGcodeEvent(...)`: after `KINEMATICS_LinearMove`, if `segment->steps_remaining == 0`, do not enqueue; update `appData.currentX/Y/Z/A` and return success.
  - In `MOTION_Tasks(...)`: when loading a segment, if `steps_remaining == 0`, dequeue and return early. Also replaced an invalid `break` with `return` in this path.

## Why this matters
- We previously observed stray single pulses or stalls right after a reset or first move. Those were caused by zero-length segments entering the pipeline. Skipping them at the source (and defensively at load time) prevents spurious scheduling and clears the path for the first real move to run continuously without requiring Ctrl+X.

## Build status
- Build: PASS (Release)
- Artifact: `bins/Release/CS23.hex`

## Quick test plan (hardware)
1. Power/boot (no Ctrl+X).
2. Send:
   - `G92 X0`  (set origin)
   - `G1 X10 F100`
3. Observe:
   - Logs show `[LOAD]` with non-zero steps and deltas (no `steps=0`).
   - LED2 rapid blink during scheduling; LED1 turns ON when segment loads and OFF on completion.
   - Multiple `[ISR5]` entries over time (not just one).
   - Status (`?`) transitions out of `<Idle...>` with increasing MPos.

If motion still stalls, enable a short inline trace around `KINEMATICS_LinearMove` to print computed deltas/steps before enqueueing.

## Open items / next steps
- SIMPLE_MOTION (scoped, optional debug path):
  - Add compile-time `SIMPLE_MOTION` flag to enable a minimal X-only stepper pipeline.
  - Under `G1` in `motion.c` when `SIMPLE_MOTION` is enabled: compute X steps and interval, set simple state, schedule first step, and update modal/current position.
  - In `stepper.c` OC5 ISR: if `SIMPLE_MOTION` active, schedule subsequent steps until done; disable axis when complete.
- Validate cold-boot behavior (no Ctrl+X) with the sequence above and confirm continuous motion.
- Optional: Add targeted "CRIT" prints at parse → kinematics → loader if needed for on-board root-cause when debugging live.
- Longer term: finalize TMR2 rollover routine and confirm phase ordering remains single-writer for OC scheduling; ensure ISR fallback can be removed once stable.

## Reference checklist (working set)
- Zero-length segment guard: DONE
- Fix invalid `break` in `MOTION_Tasks`: DONE
- Cold-boot G1 validation: PENDING
- SIMPLE_MOTION minimal path: PENDING

## Rollback note
- All changes are localized in `motion.c`. To revert, remove the zero-length guards and restore prior `MOTION_Tasks` flow, but this is not recommended.
