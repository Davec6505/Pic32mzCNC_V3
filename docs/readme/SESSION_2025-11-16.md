# Development Session - November 16, 2025

**Branch**: patch2  
**Firmware**: bins/Release/CS23.hex  
**Status**: Under Active Testing ‚úÖ

---

## Session Overview

This session focused on bug fixes, Z-axis configuration, limit switch implementation verification, and adding the $21 hard limits enable/disable feature following GRBL v1.1 standards.

---

## üêõ Critical Bug Fixes

### 1. Direction Invert Setting ($3) Not Updating at Runtime

**Problem**: The $3 (step_direction_invert) setting was stored correctly but not applied to stepper drivers until restart.

**Root Cause**: Settings were initialized once during `STEPPER_Initialize()` but never reloaded when user changed $3.

**Fix Applied** (`srcs/motion/stepper.c`):
- Added `STEPPER_ReloadSettings()` function
- Called from `SETTINGS_SetValue()` when $2, $3, or $4 are modified
- Live updates direction/pulse/enable inversion without restart

**Files Modified**:
- `srcs/motion/stepper.c` - Added reload function
- `srcs/settings/settings.c` - Added calls to reload on settings change
- `incs/motion/stepper.h` - Added function prototype

**Testing**: User confirmed direction invert now works immediately after `$3=1` command.

---

### 2. Soft Reset Not Clearing Alarm State

**Problem**: Ctrl+X soft reset during hard limit alarm would leave system stuck in `APP_ALARM` state.

**Root Cause**: `GCODE_SoftReset()` cleared motion queue and modal state but didn't reset alarm flags.

**Fix Applied** (`srcs/gcode/gcode_parser.c` lines 123-131):
```c
// Step 5: Clear alarm state (NEW FIX)
extern volatile bool g_hard_limit_alarm;
g_hard_limit_alarm = false;
appData->alarmCode = 0;
grblAlarm = false;
```

**Impact**: Soft reset now properly returns to IDLE from any alarm condition.

---

### 3. Homing Limit Switch XOR Logic Clarity

**Problem**: Comments in `HOMING_LimitTriggered()` were unclear about NO vs NC switch behavior.

**Fix Applied** (`srcs/motion/homing.c` lines 274-290):
- Added comprehensive comments explaining XOR truth table
- Clarified simplified 4-bit $5 model vs full GRBL 8-bit standard
- Documented that same invert bit applies to both Min and Max for an axis

**Implementation Choice**: Kept simplified 4-bit model (one invert bit per axis) rather than full GRBL 8-bit (one bit per limit switch). Easier to configure for most CNC applications.

---

## ‚öôÔ∏è Hardware Configuration

### Z-Axis Threaded Rod Setup

**Hardware Specs** (provided by user):
- Threaded rod: 1mm pitch per revolution
- Microstepping: 32√ó
- Stepper motor: 200 steps/revolution (1.8¬∞ standard)

**Settings Configured**:
```gcode
$102=6400.0      # Z steps/mm = (200 √ó 32) / 1mm = 6400
$112=500.0       # Z max rate = 500 mm/min (slower for threaded rod)
$122=100.0       # Z acceleration = 100 mm/sec¬≤ (gentler for vertical load)
```

**Calculation**:
```
steps_per_mm = (motor_steps_per_rev √ó microstepping) / pitch
             = (200 √ó 32) / 1mm
             = 6400 steps/mm
```

**Testing**: Debug build confirmed motion working correctly with new settings.

---

## üÜï New Feature: $21 Hard Limits Enable

### Overview

Implemented GRBL v1.1 standard $21 parameter to allow users to enable/disable hard limit checking during normal motion.

**Purpose**: 
- Allows testing without limit switches installed
- Troubleshooting wiring issues
- Soft-limits-only mode

**Default**: 0 (disabled) for safety during initial setup

---

### Implementation Details

#### 1. Settings Structure (`incs/settings/settings.h`)

**Changes**:
```c
typedef struct {
    // ... existing fields ...
    uint8_t hard_limits_enable;  // NEW: $21 setting
    uint8_t homing_enable;       // Existing $22
    uint8_t padding2;            // Changed from uint16_t to uint8_t (alignment)
    // ... rest of structure ...
} CNC_Settings;
```

**Structure Alignment**: Maintained 4-byte alignment by adjusting padding.

---

#### 2. Default Value (`srcs/settings/settings.c` line ~58)

```c
static const CNC_Settings default_settings = {
    // ... other defaults ...
    .hard_limits_enable = 0,  // Disabled by default for safety
    .homing_enable = 1,
    // ...
};
```

---

#### 3. Get/Set Functions (`srcs/settings/settings.c`)

**SETTINGS_SetValue()** (line ~301):
```c
case 21: settings->hard_limits_enable = (uint8_t)value; break;
case 22: settings->homing_enable = (uint8_t)value; break;
```

**SETTINGS_GetValue()** (line ~357):
```c
case 21: return (float)settings->hard_limits_enable;
case 22: return (float)settings->homing_enable;
```

---

#### 4. Settings Print (`srcs/settings/settings.c` line ~393)

Updated `SETTINGS_PrintAll()` to include $21:
```c
len += sprintf(&settings_buffer[len], "$21=%u\r\n", settings->hard_limits_enable);
len += sprintf(&settings_buffer[len], "$22=%u\r\n", settings->homing_enable);
```

**Total Settings**: Updated from 29 to 30 parameters.

---

#### 5. ISR Integration (`srcs/motion/stepper.c` line ~372)

**Modified limit checking logic**:
```c
void OCP1_ISR(uintptr_t context) {
    // ‚úÖ CRITICAL: Check hard limits FIRST - emergency stop if triggered
    // Only check if $21 (hard_limits_enable) is set to 1
    CNC_Settings* settings = SETTINGS_GetCurrent();
    if (settings->hard_limits_enable && MOTION_UTILS_CheckHardLimits(settings->limit_pins_invert)) {
        // EMERGENCY STOP - Hard limit triggered!
        TMR4_Stop();
        MOTION_UTILS_EnableAllAxes(false, enable_invert);
        
        g_hard_limit_alarm = true;
        LED2_Set();
        // ... alarm handling ...
    }
    // ... rest of ISR ...
}
```

**Behavior**:
- **$21=0**: Hard limits ignored during motion (homing still works via $22)
- **$21=1**: Hard limits active, triggers emergency stop when any limit hit

---

#### 6. Help Documentation (`srcs/gcode/gcode_parser.c` line ~1072)

Added help message for $ command:
```c
UART3_Write("[MSG:$21 Hard Limits Enable - $21=0 (disabled), $21=1 (enabled)]\r\n", 68);
UART3_Write("[MSG:$5 Limit Pin Invert - NO switch:$5=0 (pin HIGH triggers), NC switch:$5=255 (pin LOW triggers)]\r\n", 103);
```

---

### Usage Examples

```gcode
# Check current setting
$$              # Shows $21=0 or $21=1

# Disable hard limits (for testing)
$21=0

# Enable hard limits (normal operation)
$21=1

# View help
$               # Shows $21 description
```

---

### Relationship to Homing

**Important**: $21 and $22 are independent settings:

| Setting | Purpose | Affects Motion | Affects Homing |
|---------|---------|----------------|----------------|
| $21 | Hard limits enable | ‚úÖ Yes | ‚ùå No |
| $22 | Homing enable | ‚ùå No | ‚úÖ Yes |

**Example Configurations**:
```gcode
$21=0 $22=1    # Homing works, but motion ignores limits (setup mode)
$21=1 $22=1    # Full safety: limits checked during motion AND homing (production)
$21=1 $22=0    # Limits checked during motion, homing disabled
$21=0 $22=0    # Everything disabled (manual positioning only)
```

---

## üîç Limit Switch System Verification

### Current Implementation Model

**Simplified 4-bit $5 Model**:
- Bit 0: Inverts both X_min AND X_max
- Bit 1: Inverts both Y_min AND Y_max
- Bit 2: Inverts both Z_min AND Z_max
- Bit 3: Inverts both A_min AND A_max

**XOR Truth Table**:
```
NO Switch ($5 bit = 0):
  Pin LOW (0):  0 ^ 0 = 0 (no alarm) ‚úÖ
  Pin HIGH (1): 1 ^ 0 = 1 (alarm - switch closed) ‚úÖ

NC Switch ($5 bit = 1):
  Pin LOW (0):  0 ^ 1 = 1 (alarm - switch open/broken) ‚úÖ
  Pin HIGH (1): 1 ^ 1 = 0 (no alarm - switch closed) ‚úÖ
```

**Decision**: Kept simplified model instead of full GRBL 8-bit standard (one bit per switch). Simpler to configure, sufficient for most applications.

---

### Limit Switch Functions

**Hardware Abstraction** (`incs/utils/utils.h`):
```c
// Function pointer arrays for limit switches
extern GPIO_GetFunc axis_limit_min_get[NUM_AXIS];
extern GPIO_GetFunc axis_limit_max_get[NUM_AXIS];

// Inline helpers
static inline bool LIMIT_GetMin(E_AXIS axis) {
    return axis_limit_min_get[axis]();
}

static inline bool LIMIT_GetMax(E_AXIS axis) {
    return axis_limit_max_get[axis]();
}

// Check if any limit triggered for an axis
static inline bool LIMIT_CheckAxis(E_AXIS axis, uint8_t invert_mask) {
    bool inverted = (invert_mask >> axis) & 0x01;
    return (LIMIT_GetMin(axis) ^ inverted) || (LIMIT_GetMax(axis) ^ inverted);
}
```

---

### GPIO Configuration

**User Hardware**:
- External pull-up/pull-down resistors installed
- Can wire switches to VDD or VSS (user's choice)
- NO internal pull-ups configured in firmware (intentional flexibility)

**Pin Assignments** (from MCC):
- X_Min: RA4, X_Max: RA7
- Y_Min: RD0, Y_Max: RE0
- Z_Min: RD13, Z_Max: RE1
- A_Min: RA6, A_Max: RB1

---

## üè† Homing System Verification

### Homing Cycle Flow

**4-Phase Cycle**:

1. **SEEK** (Fast approach)
   - Speed: $25 (homing_seek_rate, default 500 mm/min)
   - Direction: $23 bit determines positive or negative
   - Stops when limit triggered
   - Alarm if limit not found

2. **LOCATE** (Precision positioning)
   - Back off 5mm
   - Re-approach at $24 (homing_feed_rate, default 100 mm/min)
   - Stops when limit triggered again
   - Provides precise home position

3. **PULLOFF** (Clear switch)
   - Move away by $27 (homing_pull_off, default 2mm)
   - Ensures switch no longer triggered
   - Prevents false alarms during motion

4. **COMPLETE**
   - Set machine position to zero
   - Move to next axis (if multi-axis)
   - Return to IDLE when all axes homed

---

### Homing Settings

```gcode
$22=1        # Homing enable (0=disabled, 1=enabled)
$23=0        # Homing direction mask (0=all negative, 15=all positive)
$24=100.0    # Homing feed rate (mm/min) - slow precision approach
$25=500.0    # Homing seek rate (mm/min) - fast initial search
$26=25       # Homing debounce (microseconds)
$27=2.0      # Homing pull-off distance (mm)
```

**Direction Mask ($23)**:
- Bit 0: X-axis (0=home to Min, 1=home to Max)
- Bit 1: Y-axis
- Bit 2: Z-axis
- Bit 3: A-axis

**Examples**:
```gcode
$23=0     # All axes home to Min (negative direction)
$23=4     # Z homes to Max, X/Y/A home to Min (binary: 0100)
$23=15    # All axes home to Max (positive direction)
```

---

### Limit Detection Logic

**Implementation** (`srcs/motion/homing.c` lines 274-290):
```c
bool HOMING_LimitTriggered(void) {
    // Determine which limit to check based on homing direction
    bool home_positive = (*g_homing_settings[axis].homing_dir_mask >> axis) & 0x01;
    
    // Get raw limit pin state
    bool limit_state = home_positive ? LIMIT_GetMax(axis) : LIMIT_GetMin(axis);
    
    // Apply invert mask from settings ($5)
    CNC_Settings* settings = SETTINGS_GetCurrent();
    bool inverted = (settings->limit_pins_invert >> axis) & 0x01;
    
    // XOR inverts the trigger logic
    limit_state ^= inverted;
    
    // Hardware debouncing (default 25¬µs)
    if (limit_state && !g_homing.debouncing) {
        g_homing.debounce_start = CORETIMER_CounterGet();
        g_homing.debouncing = true;
        return false;  // Not confirmed yet
    } else if (limit_state && g_homing.debouncing) {
        // Check if debounce delay elapsed
        // ... debounce logic ...
        return true;  // Confirmed trigger
    }
    
    return false;
}
```

**Key Points**:
- Selects Min or Max based on $23 direction
- Applies $5 inversion using XOR
- Hardware debouncing prevents false triggers
- Independent from $21 (hard limits enable)

---

## üìù Testing Procedures

### 1. Settings Verification

```gcode
$$              # View all settings
$I              # Build info
$               # Help (shows $21 and $5 descriptions)
```

**Expected Output**:
```
$21=0           # Hard limits disabled by default
$22=1           # Homing enabled by default
$5=0            # NO switches by default
$102=6400.000   # Z-axis configured for threaded rod
```

---

### 2. Limit Switch Testing

**Without Hard Limits**:
```gcode
$21=0           # Disable hard limits
```
- Manually trigger switches - no alarm
- Motion continues past limits

**With Hard Limits**:
```gcode
$21=1           # Enable hard limits
```
- Manually trigger any switch
- LED2 should light up
- Motion stops immediately
- `$X` to clear alarm

**If switches don't trigger correctly**:
```gcode
$5=15           # Try inverting all axes (NC switches)
$5=0            # Or revert to NO switches
```

---

### 3. Homing Cycle Testing

**Prerequisites**:
```gcode
$21=0           # Disable hard limits during homing test (optional)
$22=1           # Enable homing
$$              # Verify $23, $24, $25, $26, $27 settings
```

**Run Homing**:
```gcode
$H              # Home all axes (XYZA sequence)
```

**Expected Behavior**:
1. X-axis homes (fast seek, slow locate, pulloff)
2. Y-axis homes
3. Z-axis homes
4. A-axis homes
5. Position set to (0,0,0,0)

**Verify Position**:
```gcode
?               # Should show MPos:0.000,0.000,0.000,0.000
```

---

### 4. Direction Invert Testing

```gcode
$3=0            # Normal direction
G1 X10 F100     # Move X positive
```
- Observe motor direction

```gcode
$3=1            # Invert X-axis (bit 0)
G1 X10 F100     # Move X positive (motor reverses)
```
- Motor should spin opposite direction
- Change takes effect immediately (no restart needed)

---

## üìä Build Results

**Firmware**: `bins/Release/CS23.hex`  
**Build Date**: November 16, 2025  
**Build Status**: ‚úÖ SUCCESS

**Compilation Output**:
- All files compiled without errors
- All warnings resolved
- Zero runtime overhead from debug macros in Release build

**Total Settings**: 30 GRBL parameters
- $0-$5: Step configuration
- $11-$13: Arc/junction settings
- $21: Hard limits enable (NEW)
- $22-$27: Homing configuration
- $30-$31: Spindle settings
- $100-$103: Steps per mm
- $110-$113: Max rates
- $120-$123: Acceleration
- $130-$132: Max travel

---

## üìÅ Files Modified Summary

### New Features
- `incs/settings/settings.h` - Added hard_limits_enable field
- `srcs/settings/settings.c` - Added $21 default, get/set, print
- `srcs/motion/stepper.c` - Added $21 check in ISR
- `srcs/gcode/gcode_parser.c` - Added $21 help message

### Bug Fixes
- `srcs/motion/stepper.c` - Added STEPPER_ReloadSettings()
- `incs/motion/stepper.h` - Added reload function prototype
- `srcs/settings/settings.c` - Call reload on $2/$3/$4 changes
- `srcs/gcode/gcode_parser.c` - Clear alarm state in soft reset

### Documentation
- `srcs/motion/homing.c` - Enhanced XOR logic comments

### Configuration
- Z-axis settings: $102=6400, $112=500, $122=100

---

## üéØ Production Readiness Checklist

- [x] Direction invert ($3) works at runtime
- [x] Soft reset clears all alarm states
- [x] Z-axis configured for threaded rod hardware
- [x] $21 hard limits enable/disable implemented
- [x] $5 limit inversion XOR logic verified
- [x] Homing cycle logic verified
- [x] All settings persistent in NVM flash
- [x] Help documentation updated
- [x] Firmware compiled successfully
- [x] Zero compiler warnings

**Status**: ‚úÖ **TESTING IN PROGRESS**

---

## üöÄ Next Steps

### Hardware Testing
1. Flash `bins/Release/CS23.hex` to controller
2. Verify all settings with `$$` command
3. Test limit switches with $5 inversion
4. Test $21 enable/disable during motion
5. Run $H homing cycle
6. Verify direction invert with $3
7. Run production G-code programs

### Optional Future Enhancements
- Probe support (G38.x commands)
- Tool length compensation (G43/G49)
- Work coordinate systems G54-G59
- Canned cycles (G81-G89)
- Look-ahead planner (multi-segment optimization)

---

## üìö Reference Documents

- [SETTINGS_REFERENCE.md](SETTINGS_REFERENCE.md) - Complete GRBL parameter guide
- [DEBUG_SYSTEM_TUTORIAL.md](DEBUG_SYSTEM_TUTORIAL.md) - Compile-time debug system
- [MEMORY_MAP.md](MEMORY_MAP.md) - Flash layout and NVM details
- [ARCHITECTURE.md](ARCHITECTURE.md) - System design overview

---

**Session Complete**: November 16, 2025  
**Total Changes**: 7 files modified, 1 new feature, 3 bug fixes  
**Build Status**: ‚úÖ Success  
**Firmware Ready**: bins/Release/CS23.hex
