MPLAB® XC32 C/C++ Compiler User's Guide
for PIC32M MCUs
XC32 Compiler for PIC32M

Notice to Development Tools Customers
Important:
All documentation becomes dated, and Development Tools manuals are no exception.
Our tools and documentation are constantly evolving to meet customer needs, so some
actual dialogs and/or tool descriptions may differ from those in this document. Please
refer to our website (www.microchip.com/) to obtain the latest version of the PDF
document.
Documents are identified with a DS number located on the bottom of each page. The
DS format is DS<DocumentNumber><Version>, where <DocumentNumber> is an 8-digit
number and <Version> is an uppercase letter.
For the most up-to-date information, find help for your tool at
onlinedocs.microchip.com/.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 1

XC32 Compiler for PIC32M

Table of Contents
Notice to Development Tools Customers..........................................................................................................................1
1.

Preface............................................................................................................................................................................ 7
1.1.
1.2.

2.

Compiler Overview......................................................................................................................................................10
2.1.
2.2.
2.3.

3.

6.

5.1.
5.2.
5.3.
5.4.
5.5.

Invoking The Compiler.................................................................................................................................... 50
The C Compilation Sequence......................................................................................................................... 52
The C++ Compilation Sequences................................................................................................................... 56
Runtime Files.................................................................................................................................................... 58
Compiler Output.............................................................................................................................................. 61

5.6.
5.7.

Compiler Messages......................................................................................................................................... 63
Driver Option Descriptions............................................................................................................................. 63

ANSI C Standard Issues............................................................................................................................................ 103
Divergence Fom the ANSI C Standard.........................................................................................................103
Extensions to the ANSI C Standard..............................................................................................................103
Implementation-Defined Behavior..............................................................................................................103

Device-Related Features...........................................................................................................................................104
7.1.
7.2.
7.3.
7.4.
7.5.

8.

MPLAB X IDE and Tools Installation...............................................................................................................35
MPLAB X IDE Setup.......................................................................................................................................... 35
MPLAB X IDE Projects...................................................................................................................................... 36
Project Setup.................................................................................................................................................... 38
Project Example............................................................................................................................................... 48

Command-line Driver................................................................................................................................................. 50

6.1.
6.2.
6.3.
7.

Installing and Activating the Compiler.......................................................................................................... 12
Invoking the Compiler..................................................................................................................................... 13
Writing Source Code........................................................................................................................................ 15
Getting My Application To Do What I Want.................................................................................................. 22
Understanding the Compilation Process...................................................................................................... 25
Fixing Code That Does Not Work................................................................................................................... 32

XC32 Toolchain and MPLAB X IDE............................................................................................................................. 35
4.1.
4.2.
4.3.
4.4.
4.5.

5.

Device Description........................................................................................................................................... 10
Compiler Description and Documentation...................................................................................................10
Compiler and Other Development Tools......................................................................................................11

How To's....................................................................................................................................................................... 12
3.1.
3.2.
3.3.
3.4.
3.5.
3.6.

4.

Conventions Used in This Guide...................................................................................................................... 7
Recommended Reading.................................................................................................................................... 8

Device Support...............................................................................................................................................104
Device Header Files....................................................................................................................................... 104
Configuration Bit Access............................................................................................................................... 104
ID Locations.................................................................................................................................................... 105
Using SFRs From C Code............................................................................................................................... 106

Code Coverage.......................................................................................................................................................... 109

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 2

XC32 Compiler for PIC32M

9.

Supported Data Types and Variables..................................................................................................................... 110
9.1.
9.2.
9.3.
9.4.
9.5.
9.6.
9.7.
9.8.
9.9.
9.10.
9.11.

Identifiers........................................................................................................................................................110
Data Representation..................................................................................................................................... 110
Integer Data Types.........................................................................................................................................110
Floating-Point Data Types.............................................................................................................................111
Structures and Unions.................................................................................................................................. 113
Pointer Types................................................................................................................................................. 115
Complex Data Types......................................................................................................................................117
Constant Types and Formats....................................................................................................................... 117
Standard Type Qualifiers.............................................................................................................................. 119
Compiler-Specific Qualifiers......................................................................................................................... 120
Variable Attributes.........................................................................................................................................120

10. Memory Allocation and Access................................................................................................................................125
10.1.
10.2.
10.3.
10.4.
10.5.
10.6.
10.7.
10.8.

Address Spaces.............................................................................................................................................. 125
Variables in Data Memory............................................................................................................................ 125
Auto Variable Allocation and Access........................................................................................................... 127
Variables in Program Memory..................................................................................................................... 128
Variable in Registers...................................................................................................................................... 129
Application-Defined Memory Regions........................................................................................................ 129
Dynamic Memory Allocation........................................................................................................................ 133
Memory Models............................................................................................................................................. 133

11. Floating-point Support............................................................................................................................................. 135
12. Fixed-Point Arithmetic Support............................................................................................................................... 136
12.1. Enabling Fixed-Point Arithmetic Support....................................................................................................136
12.2. Data Types...................................................................................................................................................... 136
12.3. Fixed-point Library Functions.......................................................................................................................138
12.4. Integer Representations............................................................................................................................... 138
12.5. SIMD Variables............................................................................................................................................... 138
12.6. Accessing Elements in SIMD Variables........................................................................................................139
12.7. Array Alignment and Data Layout............................................................................................................... 141
12.8. Operations on Fixed-Point Variables...........................................................................................................141
12.9. Operations on SIMD Variables..................................................................................................................... 141
12.10. DSP Built-In Functions................................................................................................................................. 142
12.11. DSP Control Register....................................................................................................................................143
12.12. Using Accumulators..................................................................................................................................... 143
12.13. Mixed-Mode Operations............................................................................................................................. 144
12.14. Auto-Vectorization to SIMD.........................................................................................................................144
12.15. FIR Filter Example Project............................................................................................................................145
12.16. Unsupported Features.................................................................................................................................147
13. Operators and Statements...................................................................................................................................... 148
13.1.
13.2.
13.3.
13.4.
13.5.

Integral Promotion........................................................................................................................................ 148
Type References.............................................................................................................................................149
Labels as Values............................................................................................................................................. 150
Conditional Operator Operands.................................................................................................................. 150
Case Ranges................................................................................................................................................... 150

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 3

XC32 Compiler for PIC32M

14. Register Usage...........................................................................................................................................................152
14.1. Register Usage............................................................................................................................................... 152
14.2. Register Conventions.................................................................................................................................... 152
15. Stack............................................................................................................................................................................154
15.1. Software Stack................................................................................................................................................154
15.2. Call Frame....................................................................................................................................................... 154
15.3. Stack Guidance...............................................................................................................................................155
16. Functions....................................................................................................................................................................160
16.1.
16.2.
16.3.
16.4.
16.5.
16.6.
16.7.
16.8.
16.9.

Writing Functions........................................................................................................................................... 160
Function Attributes and Specifiers.............................................................................................................. 160
Allocation of Function Code......................................................................................................................... 165
Changing the Default Function Allocation.................................................................................................. 166
Function Size Limits....................................................................................................................................... 166
Function Parameters..................................................................................................................................... 166
Function Return Values................................................................................................................................. 168
Calling Functions............................................................................................................................................169
Inline Functions..............................................................................................................................................169

17. Interrupts................................................................................................................................................................... 171
17.1.
17.2.
17.3.
17.4.
17.5.
17.6.
17.7.
17.8.
17.9.

Interrupt Operation.......................................................................................................................................171
Writing an Interrupt Service Routine...........................................................................................................171
Associating a Handler Function with an Exception Vector....................................................................... 175
Exception Handlers....................................................................................................................................... 177
Context Switching.......................................................................................................................................... 178
Latency............................................................................................................................................................ 179
Nesting Interrupts......................................................................................................................................... 179
Enabling/Disabling Interrupts...................................................................................................................... 179
ISR Considerations.........................................................................................................................................179

18. Main, Runtime Start-up and Reset.......................................................................................................................... 181
18.1. The Main Function......................................................................................................................................... 181
18.2. Runtime Start-Up Code................................................................................................................................. 181
19. Library Routines........................................................................................................................................................ 197
19.1. Smart IO Routines..........................................................................................................................................197
19.2. Using Library Routines.................................................................................................................................. 198
20. Mixing C/C++ and Assembly Language.................................................................................................................. 199
20.1. Mixing Assembly Language and C Variables and Functions.................................................................... 199
20.2. Using Inline Assembly Language................................................................................................................. 201
20.3. Predefined Macros........................................................................................................................................ 203
21. Optimizations............................................................................................................................................................ 206
21.1. Optimization Feature Summary...................................................................................................................206
22. Preprocessing............................................................................................................................................................ 208
22.1. C/C++ Language Comments......................................................................................................................... 208
22.2. Preprocessor Directives................................................................................................................................ 208
22.3. Pragma Directives..........................................................................................................................................209

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 4

XC32 Compiler for PIC32M

22.4. Predefined Macros........................................................................................................................................ 211
23. Linking Programs...................................................................................................................................................... 215
23.1. Replacing Library Symbols............................................................................................................................215
23.2. Linker-Defined Symbols................................................................................................................................ 215
23.3. Default Linker Script...................................................................................................................................... 215
24. Embedded Compiler Compatibility Mode..............................................................................................................230
24.1.
24.2.
24.3.
24.4.
24.5.
24.6.
24.7.

Compiling in Compatibility Mode................................................................................................................ 230
Syntax Compatibility......................................................................................................................................230
Data Type........................................................................................................................................................231
Operator......................................................................................................................................................... 231
Extended Keywords.......................................................................................................................................231
Intrinsic Functions......................................................................................................................................... 232
Pragmas.......................................................................................................................................................... 233

25. Common C Interface.................................................................................................................................................234
25.1.
25.2.
25.3.
25.4.
25.5.

Background - The Desire for Portable Code...............................................................................................234
Using the CCI.................................................................................................................................................. 236
C Language Standard Refinement...............................................................................................................236
C Language Standard Extensions................................................................................................................ 243
Compiler Features......................................................................................................................................... 256

26. C Implementation-Defined Behavior......................................................................................................................257
26.1. Overview......................................................................................................................................................... 257
26.2. Translation......................................................................................................................................................257
26.3. Environment................................................................................................................................................... 257
26.4. Identifiers........................................................................................................................................................257
26.5. Characters...................................................................................................................................................... 258
26.6. Integers........................................................................................................................................................... 258
26.7. Floating-Point................................................................................................................................................. 259
26.8. Arrays and Pointers....................................................................................................................................... 259
26.9. Hints................................................................................................................................................................ 260
26.10. Structures, Unions, Enumerations, and Bit Fields.................................................................................... 260
26.11. Qualifiers....................................................................................................................................................... 260
26.12. Declarators....................................................................................................................................................261
26.13. Statements.................................................................................................................................................... 261
26.14. Pre-Processing Directives............................................................................................................................ 261
26.15. Library Functions..........................................................................................................................................261
26.16. Architecture...................................................................................................................................................264
27. C++ Implementation-Defined Behavior................................................................................................................. 266
28. Deprecated Features................................................................................................................................................ 273
28.1. Variables in Specified Registers................................................................................................................... 273
28.2. Defining Global Register Variables.............................................................................................................. 273
28.3. Specifying Registers for Local Variables......................................................................................................274
29. Built-In Functions...................................................................................................................................................... 275
29.1. Built-In Function Descriptions...................................................................................................................... 275

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 5

XC32 Compiler for PIC32M

30. Built-In DSP Functions.............................................................................................................................................. 284
31. PIC32 DSP Library......................................................................................................................................................289
31.1.
31.2.
31.3.
31.4.
31.5.
31.6.
31.7.
31.8.

Overview......................................................................................................................................................... 289
Fixed-Point Types...........................................................................................................................................290
Saturation, Scaling, and Overflow................................................................................................................290
Array Alignment and Length Restrictions................................................................................................... 290
Vector Math Functions.................................................................................................................................. 290
Filtering Functions......................................................................................................................................... 300
Frequency Domain Transform Functions................................................................................................... 305
Video Processing Functions..........................................................................................................................309

32. PIC32 Debug-Support Library..................................................................................................................................313
32.1. Overview......................................................................................................................................................... 313
32.2. Configuring Debug Input/Output for the Target And Tool....................................................................... 313
32.3. PIC32 Debugging Support Header...............................................................................................................313
33. DSP Wrapper Functions........................................................................................................................................... 317
33.1. Overview......................................................................................................................................................... 317
33.2. PIC32 DSP Wrapper Functions List.............................................................................................................. 317
33.3. Differences Between Wrapper Functions and dsPIC® DSP Library..........................................................317
34. ASCII Character Set................................................................................................................................................... 319
35. Document Revision History..................................................................................................................................... 320
The Microchip Website.................................................................................................................................................... 323
Product Change Notification Service............................................................................................................................. 323
Customer Support............................................................................................................................................................ 323
Product Identification System.........................................................................................................................................324
Microchip Devices Code Protection Feature................................................................................................................. 324
Legal Notice....................................................................................................................................................................... 324
Trademarks....................................................................................................................................................................... 325
Quality Management System.......................................................................................................................................... 326
Worldwide Sales and Service.......................................................................................................................................... 327

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 6

XC32 Compiler for PIC32M
Preface

1.

Preface
®

MPLAB XC32 C/C++ Compiler for PICM MCUs documentation and support information is discussed
in this section.

1.1

Conventions Used in This Guide
The following conventions may appear in this documentation. In most cases, formatting conforms to
the OASIS Darwin Information Typing Architecture (DITA) Version 1.3 Part 3: All-Inclusive Edition, 19
June 2018.
Table 1-1. Documentation Conventions
Description

Implementation

References

Examples

MPLAB® XC32 C/C++ Compiler User's Guide for PIC32M

DITA: cite

MCUs.

Emphasized text

Italics

...is the only compiler...

A window, window pane or dialog
name.

DITA: wintitle

the Output window.
the New Watch dialog.

A field name in a window or dialog.

DITA: uicontrol

Select the Optimizations option category.

A menu name or item.

DITA: uicontrol

Select the File menu and then Save.

A menu path.

DITA: menucascade,
uicontrol

File > Save

A tab

DITA: uicontrol

Click the Power tab.

A software button.

DITA: uicontrol

Click the OK button.

A key on the keyboard.

DITA: uicontrol

Press the F1 key.

File names and paths.

DITA: filepath

C:\Users\User1\Projects

Source code: inline.

DITA: codeph

Remember to #define START at the beginning of
your code.

Source code: block.

DITA: codeblock

An example is:
#include <xc.h>
main(void) {
while(1);
}

User-entered data.

DITA: userinput

Type in a device name, for example PIC18F47Q10.

Keywords

DITA: codeph

static, auto, extern

Command-line options.

DITA: codeph

-Opa+, -Opa-

Bit values

DITA: codeph

0, 1

Constants

DITA: codeph

0xFF, 'A'

A variable argument.

DITA: codeph + option

file.o, where file can be any valid file name.

Optional arguments

Square brackets [ ]

xc8 [options] files

Choice of mutually exclusive
arguments; an OR selection.

Curly brackets and pipe
character: { | }

errorlevel {0|1}

Replaces repeated text.

Ellipses...

var_name [, var_name...]

Represents code supplied by user.

Ellipses...

void main (void)
{ ...
}

A number in verilog format, where N
is the total number of digits, R is the
radix and n is a digit.

N‘Rnnnn

4‘b0010, 2‘hF1

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 7

XC32 Compiler for PIC32M
Preface

...........continued
Description

Implementation

Device Dependent insignia. Specifies
that a feature is not supported on
all devices. Devices supported will be
listed in the title or text.

1.2

[DD]

Examples
xmemory attribute

Recommended Reading
The MPLAB® XC32 language toolsuite for PIC32 MCUs consists of a C compilation driver (xc32gcc), a C++ compilation driver (xc32-g++), an assembler (xc32-as), a linker (xc32-ld), and an
archiver/librarian (xc32-ar). This document describes how to use the MPLAB XC32 C/C++ Compiler.
Other useful documents are listed below. The following Microchip documents are available and
recommended as supplemental reference resources.
Release Notes (Readme Files)
For the latest information on Microchip tools, read the associated Release Notes (HTML files)
included with the software.
MPLAB® XC32 Assembler, Linker and Utilities User’s Guide (DS50002186)
A guide to using the 32-bit assembler, object linker, object archiver/librarian and various utilities.
Microchip Unified Standard Library Reference Guide (DS50003209)
This guide details the functions, types, and preprocessor macros provided by the standard libraries
that ship with the compiler.
PIC32 Configuration Settings
Lists the Configuration Bit settings for the Microchip PIC32 devices supported by the #pragma
config of the MPLAB XC32 C/C++ Compiler.
Device-Specific Documentation
The Microchip website contains many documents that describe 32-bit device functions and features.
Among these are:
•

Individual and family data sheets

•

Family reference manuals

•

Programmer’s reference manuals

C Standards Information
International Standardization Organization (ISO) and International Electrotechnical Commission (IEC)
– ISO/IEC 9899:1999 Programming languages — C. ISO Central Secretariat, Chemin de Blandonnet 8,
CP 401, 1214 Vernier, Geneva, Switzerland.
This standard specifies the form and establishes the interpretation of programs expressed in the
programming language C. Its purpose is to promote portability, reliability, maintainability and
efficient execution of C language programs on a variety of computing systems.
C++ Standards Information
Stroustrup, Bjarne, C++ Programming Language: Special Edition, 3rd Edition. Addison-Wesley
Professional; Indianapolis, Indiana, 46240.
ISO/IEC 14882:2014 C++ Standard. The ISO C++ Standard is standardized by ISO (The International
Standards Organization) in collaboration with ANSI (The American National Standards Institute), BSI
(The British Standards Institute) and DIN (The German national standards organization).

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 8

XC32 Compiler for PIC32M
Preface

This standard specifies the form and establishes the interpretation of programs expressed in the
programming language C++. Its purpose is to promote portability, reliability, maintainability and
efficient execution of C++ language programs on a variety of computing systems.
C Reference Manuals
Harbison, Samuel P. and Steele, Guy L., C A Reference Manual, Fourth Edition, Prentice-Hall,
Englewood Cliffs, N.J. 07632.
Kernighan, Brian W. and Ritchie, Dennis M., The C Programming Language, Second Edition. Prentice
Hall, Englewood Cliffs, N.J. 07632.
Kochan, Steven G., Programming In ANSI C, Revised Edition. Hayden Books, Indianapolis, Indiana
46268.
Plauger, P.J., The Standard C Library, Prentice-Hall, Englewood Cliffs, N.J. 07632.
Van Sickle, Ted., Programming Microcontrollers in C, First Edition. LLH Technology Publishing, Eagle
Rock, Virginia 24085.
GCC Documents
Important:
1. Features and options described in the following GCC and Binutils
documentation might not be officially supported by MPLAB XC32. It
is recommended that only features described in the Microchip XC32
documentation be used.
gcc.gnu.org/onlinedocs/
sourceware.org/binutils/

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 9

XC32 Compiler for PIC32M
Compiler Overview

2.

Compiler Overview
The MPLAB® XC32 C/C++ Compiler for PIC32M MCUs is defined and described in this section.

2.1

Device Description
The MPLAB XC32 C/C++ Compiler fully supports most Microchip PIC32M and MEC 14 devices.

2.2

Compiler Description and Documentation
The MPLAB XC32 C Compiler is a full-featured, optimizing compiler that translates standard
C programs into 32-bit device assembly language code. The toolchain supports the PIC32M
microcontroller families. The compiler also supports many command-line options and language
extensions that allow full access to the 32-bit device hardware capabilities, and affords fine control
of the compiler's code generator.
The compiler is based on GCC, the GNU Compiler Collection, from the Free Software Foundation.
The compiler is available for several popular operating systems, including Windows®, Linux® and
macOS®.
The compiler can run in Free or PRO operating mode. The PRO operating mode is a licensed mode
and requires an activation key and Internet connectivity to enable it. Free mode is available for
unlicensed customers. The basic compiler operation, supported devices and available memory are
identical across all modes. The modes only differ in the level of optimization employed by the
compiler.

2.2.1

Conventions
Throughout this manual, the term “the compiler” is often used. It can refer to either all, or some
subset of, the collection of applications that form the MPLAB XC32 C Compiler. Often it is not
important to know, for example, whether an action is performed by the parser or code generator
application, and it is sufficient to say it was performed by “the compiler.”
It is also reasonable for “the compiler” to refer to the command-line driver (or just driver) as this
is the application that is always executed to invoke the compilation process. The C/ASM language
driver for the MPLAB XC32 C Compiler package is called xc32-gcc. The C/C++/ASM language driver
is called xc32-g++. The drivers and their options are discussed in 5.7. Driver Option Descriptions.
Following this view, “compiler options” should be considered command-line driver options, unless
otherwise specified in this manual.
Similarly “compilation” refers to all, or some part of, the steps involved in generating source code
into an executable binary image.

2.2.2

Language Standards
The MPLAB XC32 compiler is a fully validated tool that conforms to the ISO/IEC 9899:1990 C
Programming Language Standard (referred to in this document as C90) as well the ISO/IEC
9899:1999 C Programming Language Standard (C99) for programming languages. In addition, it
conforms to the ISO/IEC 14882:2014 C++ Programming Language Standard (C++14). The compiler
also supports many PIC32 MCU-oriented language extensions that allow full access to the 32-bit
device hardware capabilities, and affords fine control of the compiler's code generator.

2.2.3

Optimization
The compiler uses a set of sophisticated optimization passes that employ many advanced
techniques for generating efficient, compact code from C/C++ source. The optimization passes
include high-level optimizations that are applicable to any C/C++ code, as well as PIC32M MCUspecific optimizations that take advantage of the particular features of the device architecture.
For more on optimizations, see 21. Optimizations.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 10

XC32 Compiler for PIC32M
Compiler Overview

2.2.4

ISO/IEC C Library Support
The MPLAB XC32 C Compiler provides libraries of functions, macros, types, and objects that can
assist with your code development.
The Microchip Unified Standard Library is used for C projects. This library is C99 compliant.
The same library implementation is used as the C library (libc) within the standard C++ library
(libstdc++) when building C++ projects.
Several math libraries are available, handling devices with and without a hardware floating-point
unit.
The Standard C libraries are described in the separate Microchip Unified Standard Library Reference
Guide document, whose content is relevant for all MPLAB XC C compilers.

2.2.5

ISO/IEC C++ Library Support
The MPLAB XC32 C Compiler is distributed with a ISO/IEC 14882:2011 compliant Standard C++
Library (libstdc++) based on the GNU C++ Library. The Microchip Unified Standard Library is used
as the C library (libc) within the standard C++ library when building C++ projects.
The Standard C libraries are described in the separate Microchip Unified Standard Library Reference
Guide document, whose content is relevant for all MPLAB XC C compilers.

2.2.6

Compiler Driver
The compiler includes a powerful command-line driver program. Using the driver program,
application programs can be compiled, assembled and linked in a single step.

2.3

Compiler and Other Development Tools
The compiler works with many other Microchip tools including:
•

MPLAB XC32 assembler and linker - see the MPLAB® XC32 Assembler, Linker and Utilities User’s
Guide (DS50002186).

•

MPLAB X IDE (v5.05 or higher).

•

The MPLAB Simulator.

•

All Microchip debug tools and programmers.

•

Demo boards and starter kits that support 32-bit devices.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 11

XC32 Compiler for PIC32M
How To's

3.

How To's
This section contains help and references for situations that are frequently encountered when
building projects for Microchip 32-bit devices. Click the links at the beginning of each section to
assist finding the topic relevant to your question. Some topics are indexed in multiple sections.
Start here:

3.1

•

3.1. Installing and Activating the Compiler

•

3.2. Invoking the Compiler

•

3.3. Writing Source Code

•

3.4. Getting My Application To Do What I Want

•

3.5. Understanding the Compilation Process

•

3.6. Fixing Code That Does Not Work

Installing and Activating the Compiler
This section details questions that might arise when installing or activating the compiler.

3.1.1

•

3.1.1. How Do I Install and Activate My Compiler?

•

3.1.2. How Can I Tell if the Compiler has Activated Successfully?

•

3.1.3. Can I Install More Than One Version of the Same Compiler?

How Do I Install and Activate My Compiler?
Installation and activation of the license are performed simultaneously by the XC compiler installer.
The guide Installing and Licensing MPLAB XC C Compilers (DS50002059) is available on https://
www.microchip.com/compilers, under the Documentation tab. It provides details on single-user and
network licenses, as well as how to activate a compiler for evaluation purposes.
The default install path is different on these operating systems:
Windows:"C:\Program Files\Microchip\xc32\vx.xx\bin\xclm" -status
macOS: macOS: "/Applications/microchip/xc32/vx.xx/bin/xclm" -status
Linux: Linux: "/opt/microchip/xc32/vx.xx/bin/xclm" -status
Where vx.xx is is the version of the compiler.

3.1.2

How Can I Tell if the Compiler has Activated Successfully?
If you think the compiler may not have installed correctly or is not working, it is best to verify its
operation outside of MPLAB X IDE to isolate possible problems. Try running the compiler from the
command line to check for correct operation. You do not actually have to compile code.
From your terminal or command-line prompt, run the license manager xclm with the option
-status. This option instructs the license manager to print all MPLAB XC licenses installed on
your system and exit. So, for example, depending on your operating system, type the following line,
replacing the path information with a path that is relevant to your installation.
Windows:"C:\Program Files\Microchip\xc32\vx.xx\bin\xclm" -status
macOS: macOS: "/Applications/microchip/xc32/vx.xx/bin/xclm" -status
Linux: Linux: "/opt/microchip/xc32/vx.xx/bin/xclm" -status
The license manager should run, print all of the MPLAB XC compiler license available on your
machine, and quit. Confirm that the your license is listed as activated (for example, Product:swxc32pro) Note: if it is not activated properly, the compiler will continue to operate, but only in the

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 12

XC32 Compiler for PIC32M
How To's

Free mode. If an error is displayed, or the compiler indicates Free mode, then activation was not
successful.

3.1.3

Can I Install More Than One Version of the Same Compiler?
Yes, the compilers and installation process has been designed to allow you to have more than one
version of the same compiler installed. For MPLAB X IDE, you can easily swap between version by
changing options in the IDE (see 3.2.4. How Can I Select Which Compiler I Want to Build With?.)
Compilers should be installed into a directory whose name is related to the compiler version. This is
reflected in the default directory specified by the installer. For example, the MPLAB XC32 compilers
v1.00 and v1.10 would typically be placed in separate directories.
C:\Program Files\Microchip\xc32\v1.00\
C:\Program Files\Microchip\xc32\v1.10\

3.2

Invoking the Compiler
This section discusses how the compiler is run, both on the command-line and from the IDE. It
includes information about how to get the compiler to do what you want in terms of options and the
build process itself.
3.2.1. How Do I Compile from Within MPLAB X IDE?
3.2.2. How Do I Compile on the Command-Line?
3.2.3. How Do I Compile Using a Make Utility?
3.2.4. How Can I Select Which Compiler I Want to Build With?
3.2.5. How Can I Change the Compiler's Operating Mode?
3.2.6. How Do I Build Libraries?
3.2.7. How Do I Know What Compiler Options Are Available and What They Do?
3.2.8. How Do I Know What the Build Options in MPLAB X IDE Do?
3.2.9. What is Different About an MPLAB X IDE Debug Build?
See also 3.3.3.4. How Do I Stop the Compiler From Using Certain Memory Locations?
See also 3.4.3. What Do I Need to Do When Compiling to Use a Debugger?
See also 3.5.17. How Do I Use Library Files in My Project?
See also 3.5.19. What Optimizations Are Employed by the Compiler?

3.2.1

How Do I Compile from Within MPLAB X IDE?
See the following documentation for information on how to set up a project:
4.4. Project Setup - MPLAB X IDE

3.2.2

How Do I Compile on the Command-Line?
The compiler driver is called xc32-gcc for all 32-bit devices; for example, in Windows, it is named
xc32-gcc.exe. This application should be invoked for all aspects of compilation. It is located in the
bin directory of the compiler distribution. Avoid running the individual compiler applications (such
as the assembler or linker) explicitly. You can compile and link in the one command, even if your
project is spread among multiple source files.
The driver is introduced in 5.1. Invoking The Compiler. See 3.2.4. How Can I Select Which Compiler
I Want to Build With? to ensure you are running the correct driver if you have more than one
installed. The command-line options to the driver are detailed in 5.7. Driver Option Descriptions.
The files that can be passed to the driver are listed and described in 5.1.3. Input File Types.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 13

XC32 Compiler for PIC32M
How To's

3.2.3

How Do I Compile Using a Make Utility?
When compiling using a make utility (such as make), the compilation is usually performed as a
two-step process: first generating the intermediate files, and then the final compilation and link step
to produce one binary output. This is described in 5.2.3. Multi-Step C Compilation.

3.2.4

How Can I Select Which Compiler I Want to Build With?
The compilation and installation process has been designed to allow you to have more than one
compiler installed at the same time For MPLAB X IDE, you can create a project and then build this
project with different compilers by simply changing a setting in the project properties.
In MPLAB X IDE, you select which compiler to use when building a project by opening the Project
Properties window (File>Project Properties) and selecting the Configuration category (Conf:
[default]). A list of MPLAB XC32 compiler versions is shown in the Compiler Toolchain, on the far
right. Select the MPLAB XC32 compiler you require.
Once selected, the controls for that compiler are then shown by selecting the XC32 global options,
XC32 Compiler and XC32 Linker categories. These reveal a pane of options on the right; each
category has several panes which can be selected from a pull-down menu that is near the top of the
pane.

3.2.5

How Can I Change the Compiler's Operating Mode?
The compiler’s operating mode (Free, Evaluation, or PRO) is based on its level of optimizations
(see 21. Optimizations) which can be specified as a command line option (see 5.7.7. Options
for Controlling Optimization.) If you are building under MPLAB X IDE, go to the Project Properties
window, click on the compiler name (xc32-gcc for C language projects or xc32-g++ for C++ language
projects), and select the Optimization option category to set optimization levels - see 4.4.3. xc32-gcc
(32-bit C Compiler).
When building your project, the compiler will emit a warning message if you have selected an option
that is not available for your licensed operating mode. The compiler will continue compilation with
the option disabled.

3.2.6

How Do I Build Libraries?
When you have functions and data that are commonly used in applications, you can make all
the C source and header files available so other developers can copy these into their projects.
Alternatively, you can build these modules into object files and package them into library archives,
which, along with the accompanying header files, can then be built into an application.
Libraries can be more convenient because there are fewer files to manage. However, libraries do
need to be maintained. MPLAB XC32 uses *.a library archives. Be sure to rebuild your library objects
when you move your project to a new release of the compiler toolchain.
Using the compiler driver, libraries can begin to be built by listing all the files that are to be included
into the library on the command line. None of these files should contain a main() function, nor
settings for configuration bits or any other such data.
For information on how to create your own libraries, see 5.4.2.2. User-Defined Libraries.

3.2.7

How Do I Know What Compiler Options Are Available and What They Do?
A list of all compiler options can be obtained by using the --help option on the command line.
Alternatively, all options are listed in 5.7. Driver Option Descriptions in this user’s guide. If you are
compiling in MPLAB X IDE, see 4.4. Project Setup.

3.2.8

How Do I Know What the Build Options in MPLAB X IDE Do?
Most of the widgets and controls in the MPLAB X IDE Project Properties window, XC32 options, map
directly to one command-line driver option or suboption. See 4.4. Project Setup for a list of options
and any corresponding command-line options.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 14

XC32 Compiler for PIC32M
How To's

3.2.9

What is Different About an MPLAB X IDE Debug Build?
The main difference between a command-line debug build and an MPLAB X IDE debug build is the
setting of a preprocessor macro called __DEBUG to be 1 when a debug is selected. This macro is not
defined if it is not a debug build.
You may make code in your source conditional on this macro using #ifdef directives, etc (see
5.7.8. Options for Controlling the Preprocessor) so that you can have your program behave
differently when you are still in a development cycle. Some compiler errors are easier to track down
after performing a debug build.
In MPLAB X IDE, memory will be reserved for your debugger only when you perform a debug build.
See 3.4.3. What Do I Need to Do When Compiling to Use a Debugger?.

3.3

Writing Source Code
This section addresses issues pertaining to the source code you write. It has been subdivided into
sections listed below.

3.3.1

•

3.3.1. C Language Specifics

•

3.3.2. Device-Specific Features

•

3.3.3. Memory Allocation

•

3.3.4. Variables

•

3.3.5. Functions

•

3.3.6. Interrupts

•

3.3.7. Assembly Code

C Language Specifics
This section discusses commonly asked source code issues that directly relate to the C language
itself.
•

3.3.1.1. When Should I Cast Expressions?

•

3.3.1.2. Can Implicit Type Conversions Change The Expected Results Of My Expressions?

•

3.3.1.3. How Do I Enter Non-English Characters Into My Program?

•

3.3.1.4. How Can I Use A Variable Defined In Another Source File?

•

3.3.1.5. How Do I Port My Code To Different Device Architectures?

3.3.1.1 When Should I Cast Expressions?
Expressions can be explicitly cast using the cast operator -- a type in round brackets, for example,
(int). In all cases, conversion of one type to another must be done with caution and only when
absolutely necessary.
Consider the example:
unsigned long l;
unsigned short s;
s = l;

Here, a long type is being assigned to an int type and the assignment will truncate the value in
l. The compiler will automatically perform a type conversion from the type of the expression on
the right of the assignment operator (long) to the type of the value on the left of the operator
(short).This is called an implicit type conversion. The compiler typically produces a warning
concerning the potential loss of data by the truncation.
A cast to type short is not required and should not be used in the above example if a long to
short conversion was intended. The compiler knows the types of both operands and performs the

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 15

XC32 Compiler for PIC32M
How To's

conversion accordingly. If you did use a cast, there is the potential for mistakes if the code is later
changed. For example, if you had:
s = (short)l;

the code works the same way; but if in the future, the type of s is changed to a long, for example,
then you must remember to adjust the cast, or remove it, otherwise the contents of l will continue
to be truncated by the assignment, which may not be correct. Most importantly, the warning issued
by the compiler will not be produced if the cast is in place.
Only use a cast in situations where the types used by the compiler are not the types that you
require. For example, consider the result of a division assigned to a floating-point variable:
int i, j;
float fl;
fl = i/j;

In this case, integer division is performed, then the rounded integer result is converted to a float
format. So if i contained 7 and j contained 2, the division yields 3 and this is implicitly converted to
a float type (3.0) and then assigned to fl. If you wanted the division to be performed in a float
format, then a cast is necessary:
fl = (float)i/j;

(Casting either i or j forces the compiler to encode a floating-point division.) The result assigned to
fl now is 3.5.
An explicit cast can suppress warnings that might otherwise have been produced. This can also be
the source of many problems. The more warnings the compiler produces, the better chance you
have of finding potential bugs in your code.

3.3.1.2 Can Implicit Type Conversions Change The Expected Results Of My Expressions?
Yes! The compiler will always use integral promotion and there is no way to disable this (see
13.1. Integral Promotion). In addition, the types of operands to binary operators are usually
changed so that they have a common type, as specified by the C Standard. Changing the type of
an operand can change the value of the final expression, so it is very important that you understand
the type C Standard conversion rules that apply when dealing with binary operators. You can
manually change the type of an operand by casting; see 3.3.1.1. When Should I Cast Expressions?

3.3.1.3 How Do I Enter Non-English Characters Into My Program?
The ANSI standard and MPLAB XC C do not support extended characters set in character and
string literals in the source character set. See 9.8. Constant Types and Formats to see how these
characters can be entered using escape sequences.

3.3.1.4 How Can I Use A Variable Defined In Another Source File?
Provided the variable defined in the other source file is not static (see 10.2.2. Static Variables) or
auto (see 10.3. Auto Variable Allocation and Access), adding a declaration for that variable into the
current file will allow you to access it. A declaration consists of the keyword extern in addition to
the type and the name of the variable, as specified in its definition, for example,
extern int systemStatus;

This is part of the C language. Your favorite C textbook will give you more information.
The position of the declaration in the current file determines the scope of the variable. That is, if you
place the declaration inside a function, it will limit the scope of the variable to that function. If you
place it outside of a function, it allows access to the variable in all functions for the remainder of the
current file.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 16

XC32 Compiler for PIC32M
How To's

Often, declarations are placed in header files and then they are #included into the C source code
(see 22.2. Preprocessor Directives).

3.3.1.5 How Do I Port My Code To Different Device Architectures?
Porting code to different devices within an architectural family requires a minimum update to
application code. However, porting between architectural families can require significant rewrite.
In an attempt to reduce the work to port between architectures, a Common C Interface, or CCI, has
been developed. If you use these coding styles, your code will more easily migrate upward. For more
on CCI, see 25. Common C Interface.

3.3.2

Device-Specific Features
This section discusses the code that needs to be written to set up or control a feature that is specific
to Microchip PIC devices.
•

3.3.2.1. How Do I Set the Configuration Bits?

•

3.3.2.2. How Do I Determine the Cause of Reset?

•

3.3.2.3. How Do I Access SFRS?

•

3.3.3.4. How Do I Stop the Compiler From Using Certain Memory Locations?

See also the following linked information in other sections.
•

3.4.3. What Do I Need to Do When Compiling to Use a Debugger?

3.3.2.1 How Do I Set the Configuration Bits?
These should be set in your code using either a macro or pragma. Earlier versions of MPLAB IDE
allowed you to set these bits in a dialog, but MPLAB X IDE requires that they be specified in your
source code. Config bits are set in source code using the config pragma. See 7.3. Configuration Bit
Access, for more information on the config pragma.

3.3.2.2 How Do I Determine the Cause of Reset?
The bits in the Reset Control (RCON) Register allow you to determine the cause of a Reset. See the
data sheet for your target device for a description of the RCON register.

3.3.2.3 How Do I Access SFRS?
The compiler ships with header files, see 7.4. ID Locations, that define variables which are mapped
over the top of memory-mapped SFRs. Since these are C variables, they can be used like any other C
variable and no new syntax is required to access these registers.
Bits within SFRs can also be accessed. Bit-fields are available in structures which map over the SFR
as a whole. See 9.5.2. Bit Fields in Structures.
The name assigned to the variable is usually the same as the name specified in the device data
sheet. See 3.3.2.4. How Do I Find The Names Used To Represent SFRs And Bits? if these names are
not recognized.

3.3.2.4 How Do I Find The Names Used To Represent SFRs And Bits?
Special function registers, and the bits within them, are accessed via special variables that map over
the register (see 3.3.2.3. How Do I Access SFRS?). However, the names of these variables sometimes
differ from those indicated in the data sheet for the device you are using.
View the device-specific header file which allows access to these special variables. Begin by
searching for the data sheet SFR name. If that is not found, search on what the SFR represents,
as comments in the header often spell out what the macros under the comment do.

3.3.3

Memory Allocation
Here are questions relating to how your source code affects memory allocation.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 17

XC32 Compiler for PIC32M
How To's

•

3.3.3.1. How Do I Position Variables at an Address I Nominate?

•

3.3.3.2. How Do I Position Functions at an Address I Nominate?

•

3.3.3.3. How Do I Place Variables in Program Memory?

•

3.3.3.4. How Do I Stop the Compiler From Using Certain Memory Locations?

•

3.5.15. Why Are Some Objects Positioned Into Memory That I Reserved?

3.3.3.1 How Do I Position Variables at an Address I Nominate?
The easiest way to do this is to make the variable absolute by using the address attribute (see
9.11. Variable Attributes) or the __at() CCI construct (see 25.4.2. Absolute Addressing). This
means that the address you specify is used in preference to the variable’s symbol in generated code.
Since you nominate the address, you have full control over where objects are positioned, but you
must also ensure that absolute variables do not overlap.
See also 10.3. Auto Variable Allocation and Access for information on moving auto variables,
10.2.1. Non-Auto Variable Allocation for moving non-auto variables and 10.4. Variables in Program
Memory for moving program-space variables.

3.3.3.2 How Do I Position Functions at an Address I Nominate?
The easiest way to do this is to make the functions absolute, by using the address attribute (see
16.2.1. Function Attributes). This means that the address you specify is used in preference to the
function’s symbol in generated code. Since you nominate the address, you have full control over
where functions are positioned, but must also ensure that absolute functions do not overlap.

3.3.3.3 How Do I Place Variables in Program Memory?
The const qualifier implies that the qualified variable is read only. See the -membedded-data
option in 5.7.1. Options Specific to PIC32M Devices for information about allocating 'const' qualified
variables to program memory (Flash). As a consequence of this any variables, except for auto
variables or function parameters, qualified const are placed in program memory, thus freeing
valuable data RAM (see 10.4. Variables in Program Memory). Variables qualified const can also be
made absolute, so that they can be positioned at an address you nominate.

3.3.3.4 How Do I Stop the Compiler From Using Certain Memory Locations?
Concatenating an address attribute with the noload attribute can be used to block out sections of
memory. Also, you can use the option -mreserve. For more on variable attributes and options, see
the following sections in this user’s guide:
9.11. Variable Attributes
5.7.1. Options Specific to PIC32M Devices
®

See the MPLAB XC32 Assembler, Linker and Utilities User’s Guide (DS50002186) for details on linker
scripts.

3.3.4

Variables
This examines questions that relate to the definition and usage of variables and types within a
program.
•

3.3.4.1. Why Are My Floating-point Results Not Quite What I Am Expecting?

•

3.3.4.2. How Can I Access Individual Bits of a Variable?

•

3.3.4.3. How Long Can I Make My Variable and Macro Names?

•

3.4.4. How Do I Share Data Between Interrupt and Main-line Code?

•

3.3.3.1. How Do I Position Variables at an Address I Nominate?

•

3.3.3.3. How Do I Place Variables in Program Memory?

•

3.4.8. How Can I Rotate a Variable?

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 18

XC32 Compiler for PIC32M
How To's

•

3.5.14. How Do I Find Out Where Variables and Functions Have Been Positioned?

3.3.4.1 Why Are My Floating-point Results Not Quite What I Am Expecting?
First, make sure that if you are watching floating-point variables in MPLAB IDE that the type and size
of these match how they are defined. In MPLAB XC32, the float type is 32 bits wide, the double
and long double types are 64-bits wide, as discussed in 9.4. Floating-Point Data Types.
Since floating-point variables only have a finite number of bits to represent the values they are
assigned, they will hold an approximation of their assigned value. A floating-point variable can only
hold one of a set of discrete real number values. If you attempt to assign a value that is not in this
set, it is rounded to the nearest value. The more bits used by the mantissa in the floating-point
variable, the more values can be exactly represented in the set and the average error due to the
rounding is reduced.
Whenever floating-point arithmetic is performed, rounding also occurs. This can also lead to results
that do not appear to be correct.

3.3.4.2 How Can I Access Individual Bits of a Variable?
There are several ways of doing this. The simplest and most portable way is to define an integer
variable and use macros to read, set, or clear the bits within the variable using a mask value and
logical operations, such as the following.
#define
#define
#define

testbit(var, bit)
setbit(var, bit)
clrbit(var, bit)

(!!(var) & (1 <<(bit)))
((var) |= (1 << (bit)))
((var) &= ~(1 << (bit)))

These, respectively, test to see if bit number, bit, in the integer, var, is set; set the corresponding
bit in var; and clear the corresponding bit in var. Alternatively, a union of an integer variable and
a structure with bit-fields (see 9.5.2. Bit Fields in Structures) can be defined, for example,
union both {
unsigned char byte;
struct {
unsigned b0:1, b1:1, b2:1, b3:1, b4:1, b5:1, b6:1, b7:1;
} bitv;
} var;

This allows you to access byte as a whole (using var.byte), or any bit within that variable
independently (using var.bitv.b0 through var.bitv.b7).

3.3.4.3 How Long Can I Make My Variable and Macro Names?
The C Standard indicates that only a number of initial characters in an identifier are significant, but
it does not actually state what this number is and it varies from compiler to compiler. For MPLAB
XC32, no limit is imposed, but for CCI there is a limit (see 25.3.5. The Number of Significant Initial
Characters in an Identifier). CCI Compliant names are more portable across Microchip architectures.
If two identifiers only differ in the non-significant part of the name, they are considered to represent
the same object, which will almost certainly lead to code failure.

3.3.5

Functions
This section examines questions that relate to functions.
•

3.3.5.1. What Is the Optimum Size for Functions?

•

3.5.11. How Can I Tell How Big a Function Is?

•

3.5.13. How Do I Know What Resources Are Being Used by Each Function?

•

3.5.14. How Do I Find Out Where Variables and Functions Have Been Positioned?

•

3.3.6.1. How Do I Use Interrupts in C?

•

3.3.5.2. How Do I Stop An Unused Function Being Removed?

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 19

XC32 Compiler for PIC32M
How To's

•

3.3.5.3. How Do I Make a Function Inline?

3.3.5.1 What Is the Optimum Size for Functions?
Generally speaking, the source code for functions should be kept small as this aids in readability and
debugging. It is much easier to describe and debug the operation of a function which performs a
small number of tasks. Also smaller-sized functions typically have less side effects, which can be the
source of coding errors. On the other hand, in the embedded programming world, a large number
of small functions, and the calls necessary to execute them, may result in excessive memory and
stack usage. Therefore a compromise is often necessary.
Function size can cause issues with memory paging, as addressed in 16.5. Function Size Limits. The
smaller the functions, the easier it is for the linker to allocate them to memory without errors.

3.3.5.2 How Do I Stop An Unused Function Being Removed?
The __attribute__((keep)) may be applied to a function. The keep attribute will prevent the
®
linker from removing the function with --gc-sections, even if it is unused. See the “MPLAB XC32
Assembler, Linker and Utilities User’s Guide” (DS50002186) for more information on section garbage
collection using the --gc-sections option.

3.3.5.3 How Do I Make a Function Inline?
The XC32 compiler does not inline any functions when not optimizing.
By declaring a function inline, you can direct the XC32 compiler to make calls to that function faster.
One way XC32 can achieve this is to integrate that function's code into the code for its callers.
This makes execution faster by eliminating the function-call overhead; in addition, if any of the
actual argument values are constant, their known values may permit simplifications at compile time
so that not all of the inline function's code needs to be included. The effect on code size is less
predictable; object code may be larger or smaller with function inlining, depending on the particular
case.
To declare a function inline, use the inline keyword in its declaration, like this:
static inline int
inc (int *a)
{
return (*a)++;
}

When a function is both inline and static, if all calls to the function are integrated into the caller, and
the function's address is never used, then the function's own assembler code is never referenced.
In this case, XC32 does not actually output assembler code for the function. Some calls cannot be
integrated for various reasons (in particular, calls that precede the function's definition cannot be
integrated, and neither can recursive calls within the definition). If there is a non-integrated call, then
the function is compiled to assembler code as usual. The function must also be compiled as usual
if the program refers to its address, because that can't be inlined. Enable optimization level -O1 or
greater to enable function inlining.

3.3.6

Interrupts
Interrupt and interrupt service routine questions are discussed in this section.
•

3.3.6.1. How Do I Use Interrupts in C?

•

3.5.6. How Can I Make My Interrupt Routine Faster?

•

3.4.4. How Do I Share Data Between Interrupt and Main-line Code?

3.3.6.1 How Do I Use Interrupts in C?
First, be aware of what interrupt hardware is available on your target device. 32-bit devices
implement several separate interrupt vector locations and use a priority scheme. For more
information, see 17.1. Interrupt Operation.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 20

XC32 Compiler for PIC32M
How To's

In C source code, a function can be written to act as the interrupt service routine by using the
interrupt attribute. Such functions save/restore program context before/after executing the
function body code and a different return instruction is used. For more on writing interrupt
functions, see 17.2. Writing an Interrupt Service Routine. To populate the interrupt vector table,
use the vector or at_vector attribute. An __ISR() macro is provided in the sys/attribs.h header
file that simplifies the usage of the interrupt and vector attributes.
Prior to any interrupt occurring, your program must ensure that peripherals are correctly configured
and that interrupts are enabled. For details, see 17.8. Enabling/Disabling Interrupts.
For all other interrupt related tasks, including specifying the interrupt vector, context saving, nesting
and other considerations, consult 17. Interrupts.

3.3.7

Assembly Code
This section examines questions that arise when writing assembly code as part of a C project.
•

3.3.7.1. How Should I Combine Assembly and C Code?

•

3.3.7.2. What Do I Need Other Than Instructions in an Assembly Source File?

•

3.3.7.3. How Do I Access C Objects from Assembly Code?

•

3.3.7.4. How Can I Access SFRs From Within Assembly Code?

•

3.3.7.5. What Things Must I Manage When Writing Assembly Code?

3.3.7.1 How Should I Combine Assembly and C Code?
Ideally, any hand-written assembly should be written as separate routines that can be called. This
offers some degree of protection from interaction between compiler-generated and hand-written
assembly code. Such code can be placed into a separate assembly module that can be added to
your project, as specified in 20.1. Mixing Assembly Language and C Variables and Functions.
If necessary, assembly code can be added in-line with C code by using either of two forms of the asm
instruction; simple or extended. An explanation of these forms, and some examples, are shown in
20.2. Using Inline Assembly Language.
Macros are provided which in-line several simple instructions, as discussed in 20.3. Predefined
Macros. More complex in-line assembly that changes register contents and the device state should
be used with caution.
See 14.1. Register Usage for those registers used by the compiler.

3.3.7.2 What Do I Need Other Than Instructions in an Assembly Source File?
Assembly code typically needs assembler directives as well as the instructions themselves. The
®
operation of all the directives is described in the “MPLAB XC32 Assembler, Linker and Utilities User’s
Guide” (DS50002186). Two common directives are discussed below.
All assembly code must be placed in a section, using the .section directive, so it can be manipulated
®
as a whole by the linker and placed in memory. See the “Linker Processing” chapter of the “MPLAB
XC32 Assembler, Linker and Utilities User’s Guide” (DS50002186) for more information.
Another commonly used directive is .global which is used to make symbols accessible across
multiple source files. Find more on this directive in the aforementioned user’s guide.

3.3.7.3 How Do I Access C Objects from Assembly Code?
Most C objects are accessible from assembly code. There is a mapping between the symbols used in
the C source and those used in the assembly code generated from this source. Your assembly
should access the assembly-equivalent symbols which are detailed in 20.1. Mixing Assembly
Language and C Variables and Functions.
Instruct the assembler that the symbol is defined elsewhere by using the .global assembler
directive. This is the assembly equivalent of a C declaration, although no type information is present.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 21

XC32 Compiler for PIC32M
How To's

This directive is not needed and should not be used if the symbol is defined in the same module as
your assembly code.
Any C variable accessed from assembly code will be treated as if it were qualified volatile (see
9.9.2. Volatile Type Qualifier). Specifying the volatile qualifier in C code is preferred as it makes it
clear that external code may access the object.

3.3.7.4 How Can I Access SFRs From Within Assembly Code?

The safest way to gain access to SFRs in assembly code is to have symbols defined in your assembly
code that equate to the corresponding SFR address. For the XC32 compiler, the xc.h include file can
be used from either preprocessed assembly code or C/C++ code.
There is no guarantee that you will be able to access symbols generated by the compilation of C
code, even code that accesses the SFR you require.

3.3.7.5 What Things Must I Manage When Writing Assembly Code?

There are several things that you must manage if you are hand-writing assembly code.

•

You must place any assembly code you write into a section. See the “Linker Processing” chapter
®
of the “MPLAB XC32 Assembler, Linker and Utilities User’s Guide” (DS50002186) for more
information.
Assembly code that is placed in-line with C code will be placed in the same section as the
compiler-generated assembly and you should not place this into a separate section.

•

3.4

You must ensure that any registers you write to in assembly code are not already in use by
compiler-generated code. If you write assembly in a separate module, then this is less of an
issue as the compiler will, by default, assume that all registers are used by these routines (see
14.1. Register Usage, registers). No assumptions are made for in-line assembly (see 20.1. Mixing
Assembly Language and C Variables and Functions) and you must be careful to save and restore
any resources that you use (write) and which are already in use by the surrounding compilergenerated code.

Getting My Application To Do What I Want
This section provides programming techniques, applications and examples. It also examines
questions that relate to making an application perform a specific task.

3.4.1

•

3.4.1. What Can Cause Glitches on Output Ports?

•

3.4.2. How Do I Link Bootloaders and Downloadable Applications?

•

3.4.3. What Do I Need to Do When Compiling to Use a Debugger?

•

3.4.4. How Do I Share Data Between Interrupt and Main-line Code?

•

3.4.5. How Can I Prevent Misuse of My Code?

•

3.4.6. How Do I Use Printf to Send Text to a Peripheral?

•

3.4.7. How Can I Implement a Delay in My Code?

•

3.4.8. How Can I Rotate a Variable?

What Can Cause Glitches on Output Ports?
In most cases, this is caused by using ordinary variables to access port bits or the entire port itself.
These variables should be qualified volatile. See 9.9.2. Volatile Type Qualifier.
The value stored in a variable mapped over a port (hence the actual value written to the port)
directly translates to an electrical signal. It is vital that the values held by these variables only change
when the code intends them to, and that they change from their current state to their new value in a
single transition. The compiler attempts to write to volatile variables in one operation.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 22

XC32 Compiler for PIC32M
How To's

3.4.2

How Do I Link Bootloaders and Downloadable Applications?
Exactly how this is done depends on the device you are using and your project requirements, but
the general approach when compiling applications that use a bootloader is to allocate discrete
program memory space to the bootloader and application so they have their own dedicated
memory. In this way the operation of one cannot affect the other. This will require that either the
bootloader or the application is offset in memory. That is, the Reset and interrupt location are offset
from address 0 and all program code is offset by the same amount.
Typically the application code is offset, and the bootloader is linked with no offset so that it
populates the Reset and interrupt code locations. The bootloader Reset and interrupt code merely
contains code which redirects control to the real Reset and interrupt code defined by the application
and which is offset.
The contents of the Hex file for the bootloader can be merged with the code of the application by
using loadable projects in MPLAB X IDE. (See MPLAB X IDE documentation for details.) This results
in a single Hex file that contains the bootloader and application code in the one image. Check for
warnings from this application about overlap, which may indicate that memory is in use by both
bootloader and the downloadable application.
See the PIC32 Bootloader Application Note (DS01388) on the Microchip website.

3.4.3

What Do I Need to Do When Compiling to Use a Debugger?
You can use debuggers, such as the MPLAB PICkit™ 4 or ICD 4 in-circuit debuggers or the MPLAB
REAL ICE™ in-circuit emulator, to debug code built with the MPLAB XC32 compiler. These debuggers
use some of the data and program memory of the device for its own use, so it is important that your
code does not also use these resources.
The command-line option -g (see 5.7.6. Options for Debugging) is used to tell the compiler to
generate debugging information. The compiler can then reserve the memory used by the debugger
so that your code will not be placed in these locations.
In the MPLAB X IDE, the appropriate debugger option is specified if you perform a Debug Run. It will
not be specified if you perform a regular Run, Build Project, or Clean and Build.
Since some device memory is being reserved for use by the debugger, there is less available for your
program and it is possible that your code or data may no longer fit in the device when a debugger
is selected. For 32-bit devices, some boot flash memory is required for debugging. In addition,
some data memory (RAM) is used by the debug tool and may impact the variable allocation in your
application.
The specific memory locations used by the debuggers are attributes of MPLAB X IDE, the debug
tool in use and the target device. If you move a project to a new version of the IDE, the resources
required may change. For this reason, you should not manually reserve memory for the debugger,
or make any assumptions in your code as to what memory is used. A summary of the debugger
requirements is available in the MPLAB X IDE help files.
To verify that the resources reserved by the compiler match those required by the debugger, you
may view the boot-flash, application-flash and data-memory usage in the map file or memory-usage
report.
To create a map file in MPLAB X IDE, open the Project Properties window (File>Project Properties)
and click on the linker category (xc32-ld). Under “Option Categories,” select “Diagnostics.” Next to
“Generate map file,” enter a path and name for the map file. The logical place to put the map file is
in the project folder.
Debug Run your code to generate the map file. View in your favorite text viewer.
See also 3.5.15. Why Are Some Objects Positioned Into Memory That I Reserved?.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 23

XC32 Compiler for PIC32M
How To's

3.4.4

How Do I Share Data Between Interrupt and Main-line Code?
Variables accessed from both interrupt and main-line code can easily become corrupted or mis-read
by the program. The volatile qualifier (see 9.9.2. Volatile Type Qualifier) tells the compiler to
avoid performing optimizations on such variables. This will fix some of the issues associated with
this problem.
The other issues relates to whether the compiler/device can access the data atomically. With
32-bit PIC devices, this is rarely the case. An atomic access is one where the entire variable is
accessed in only one instruction. Such access is uninterruptible. You can determine if a variable is
®
being accessed atomically by looking at the assembler list file (see the MPLAB XC32 Assembler,
Linker and Utilities User’s Guide, DS50002186, for more information). If the variable is accessed
in one instruction, it is atomic. Since the way variables are accessed can vary from statement to
statement it is usually best to avoid these issues entirely by disabling interrupts prior to the variable
being accessed in main-line code, then re-enable the interrupts afterwards. See 17.8. Enabling/
Disabling Interrupts for more information. When writing to Special Function Registers (SFRs), use the
SET/CLR/INV registers as described in 7.4. ID Locations.

3.4.5

How Can I Prevent Misuse of My Code?
First, many devices with flash program memory allow all or part of this memory to be write
protected. The device configuration bits need to be set correctly for this to take place, so see
7.3. Configuration Bit Access, 25.4.14. Specifying Configuration Bits for CCI, and your device data
sheet.
Second, you can prevent third-party code being programmed at unused locations in the program
memory by filling these locations with a value rather than leaving them in their default
unprogrammed state. You can chose a fill value that corresponds to an instruction or set all the bits
so as the values cannot be further modified. (Consider what will happen if your program somehow
reaches and starts executing from these filled values. What instruction will be executed?)
Use the --fill command to fill unused memory. Find usage information for this command in
5.7.10. Options for Linking.

3.4.6

How Do I Use Printf to Send Text to a Peripheral?
The printf function does two things: it formats text based on the format string and placeholders
you specify, and sends (prints) this formatted text to a destination (or stream). You may choose the
printf output go to an LCD, SPI module or USART, for example.
For more on the ANSI C function printf, see the 32-bit Language Tool Libraries manual (DS51685).
To check what is passed to the printf function, you may attempt to statically analyze format
strings passed to the function by using the -msmart-io option (5.7.1. Options Specific to PIC32M
Devices). Also you may use the -Wformat option to specify a warning when the arguments supplied
to the function do not have types appropriate to the format string specified (see 5.7.5. Options for
Controlling Warning and Errors).
If you wish to create your own printf-type function, you will need to use the attributes format and
format_arg as discussed in 16.2.1. Function Attributes.

3.4.7

How Can I Implement a Delay in My Code?
If an accurate delay is required, or if there are other tasks that can be performed during the delay,
then using a timer to generate an interrupt is the best way to proceed.
Microchip does not recommend using a software delay on PIC32 devices as there are many
variables that can affect timing such as the configuration of the L1 cache, prefetch cache, & Flash
wait states. On PIC32 devices, you may choose to poll the core timer, which increments every two
instruction cycles.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 24

XC32 Compiler for PIC32M
How To's

3.4.8

How Can I Rotate a Variable?
The C language does not have a rotate operator, but rotations can be performed using the shift and
bitwise OR operators. Since the 32-bit devices have a rotate instruction, the compiler will look for
code expressions that implement rotates (using shifts and ORs) and use the rotate instruction in the
generated output wherever possible.
If you are using CCI, you should consult 25.3.10. Bitwise Operations on Signed Values and
25.3.11. Right-Shifting Signed Values if you will be using signed variables.
For the following example C code:
int rotate_left (unsigned a, unsigned s)
{
return (a << s) | (a >> (32 - s));
}

the compiler may generate assembly instructions similar to the following:
rotate_left:
subu
$2,$0,$5
jr
$31
ror
$2,$4,$2

3.5

Understanding the Compilation Process
This section tells you how to find out what the compiler did during the build process, how it encoded
output code, where it placed objects, etc. It also discusses the features that are supported by the
compiler.
•

3.5.1. What's the Difference Between the Free and PRO Modes?

•

3.5.2. How Can I Make My Code Smaller?

•

3.5.3. How Can I Reduce RAM Usage?

•

3.5.4. How Can I Make My Code Faster?

•

3.5.5. How Does the Compiler Place Everything in Memory?

•

3.5.6. How Can I Make My Interrupt Routine Faster?

•

3.5.7. How Big Can C Variables Be?

•

3.5.8. What Optimizations Will Be Applied to My Code?

•

3.5.9. What Devices are Supported by the Compiler?

•

3.5.10. How Do I Know What Code the Compiler Is Producing?

•

3.5.11. How Can I Tell How Big a Function Is?

•

3.5.13. How Do I Know What Resources Are Being Used by Each Function?

•

3.5.14. How Do I Find Out Where Variables and Functions Have Been Positioned?

•

3.5.15. Why Are Some Objects Positioned Into Memory That I Reserved?

•

3.5.16. How Do I Know How Much Memory Is Still Available?

•

3.5.17. How Do I Use Library Files in My Project?

•

3.5.18. How Do I Customize the C Runtime Startup Code?

•

3.5.19. What Optimizations Are Employed by the Compiler?

•

3.5.20. Why Do I Get Out-of-Memory Errors When I Select a Debugger?

•

3.6.1. How Do I Set Up Warning/Error Messages?

•

3.6.2. How Do I Find the Code that Caused Compiler Errors or Warnings in My Program?

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 25

XC32 Compiler for PIC32M
How To's

3.5.1

•

3.6.3. How Can I Stop Spurious Warnings From Being Produced?

•

3.6.4. Why Can’t I Even Blink an LED?

•

3.6.5. What Can Cause Corrupted Variables and Code Failure When Using Interrupts?

•

3.2.6. How Do I Build Libraries?

•

3.2.9. What is Different About an MPLAB X IDE Debug Build?

•

3.3.5.2. How Do I Stop An Unused Function Being Removed?

•

3.5.17. How Do I Use Library Files in My Project?

•

3.5.18. How Do I Customize the C Runtime Startup Code?

•

3.5.19. What Optimizations Are Employed by the Compiler?

•

3.5.20. Why Do I Get Out-of-Memory Errors When I Select a Debugger?

What's the Difference Between the Free and PRO Modes?
These modes, or editions, mainly differ in the optimizations that are performed when compiling
(see 21. Optimizations). Compilers operating in Free mode can compile for all the same devices
as supported by the Pro mode. The code compiled in Free or PRO modes can use all the available
memory for the selected device. What will be different is the size and speed of the generated
compiler output. Free mode output will be less efficient when compared to that produced in Pro
mode.

3.5.2

How Can I Make My Code Smaller?
There are a number of ways that this can be done, but results vary from one project to the next.
Use the assembly list file to observe the assembly code produced by the compiler to verify that
®
the following tips are relevant to your code. For information on the list file, see the MPLAB XC32
Assembler, Linker and Utilities User’s Guide (DS50002186).
Use the smallest data types possible as less code is needed to access these (this also reduces RAM
usage). For examples, a short integer type exists for this compiler. See 9. Supported Data Types and
Variables for all data types and sizes.
There are two sizes of floating-point type, which are discussed in the same section. Replace floatingpoint variables with integer variables wherever possible. For many applications, scaling a variable's
value makes eliminating floating-point operations possible.
Use unsigned types, if possible, instead of signed types, particularly if they are used in expressions
with a mix of types and sizes. Try to avoid an operator acting on operands with mixed sizes
whenever possible.
Whenever you have a loop or condition code, use a “strong” stop condition, that is, the following:
for(i=0; i!=10; i++)

is preferable to:
for(i=0; i<10; i++)

A check for equality (== or !=) is usually more efficient to implement than the weaker < comparison.
In some situations, using a loop counter that decrements to zero is more efficient than one that
starts at zero and counts up by the same number of iterations. So you might be able to rewrite the
above as:
for(i=10; i!=0; i--)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 26

XC32 Compiler for PIC32M
How To's

Ensure that you enable all the optimizations allowed for the edition of your compiler (see
21. Optimizations). If you have a PRO edition, you can use the -Os option (see 5.7.7. Options
for Controlling Optimization) to optimize for size. Otherwise, pick the highest optimization available.
Consider also the PRO-edition standard link-time optimizer, controlled by the -flto option. This
optimization adds internal bytecode representations of the code to special sections in the object
file that are then processed as if they had been part of the same translation unit. This can allow
the compiler to make certain assumptions about the program code and improved the effectively of
some optimizations.
Consider using the a compressed ISA mode such as MIPS16 or microMIPS if it is supported on your
device. Use the -mips16 or -mmicromips option for your project to make the compiler default to
these modes. Use the mips16 or micromips function attributes to change the mode at the function
level. You may also choose the optimized and compressed variants of the libraries in the linker
options. Be aware of what optimizations the compiler performs so you can take advantage of them
and don’t waste your time manually performing optimizations in C code that the compiler already
handles, for example, don’t turn a multiply-by-4 operation into a shift-by-2 operation as this sort of
optimization is already detected.

3.5.3

How Can I Reduce RAM Usage?
Consider using auto variables rather than global or static variables as there is the potential that
these may share memory allocated to other auto variables that are not active at the same time.
Memory allocation of auto variables is made on a stack, described in 10.3. Auto Variable Allocation
and Access.
Rather than pass large objects to, or from, functions, pass pointers which reference these objects.
This is particularly true when larger structures are being passed.
Objects that do not need to change throughout the program can be located in program memory
using the const qualifier (see 10.4. Variables in Program Memory). This frees up precious RAM, but
slows execution.

3.5.4

How Can I Make My Code Faster?
To a large degree, smaller code is faster code, so efforts to reduce code size often decrease
execution time. To accomplish this, see 3.5.2. How Can I Make My Code Smaller? and 3.5.6. How
Can I Make My Interrupt Routine Faster?. However, there are ways some sequences can be sped up
at the expense of increased code size.
Depending on your compiler edition (see 21. Optimizations), you may be able to use the -O3 option
(see 5.7.7. Options for Controlling Optimization) to optimize for speed. This will use alternate output
in some instances that is faster, but larger.
Generally, the biggest gains to be made in terms of speed of execution come from the algorithm
used in a project. Identify which sections of your program need to be fast. Look for loops that
might be linearly searching arrays and choose an alternate search method such as a hash table and
function. Where results are being recalculated, consider if they can be cached.

3.5.5

How Does the Compiler Place Everything in Memory?
In most situations, assembly instructions and directives associated with both code and data are
grouped into sections, and these are then positioned into containers which represent the device
memory. To see what sections objects are placed in, use the option -ai to view this information in
the assembler listing file.
The exception is for absolute variables, which are placed at a specific address when they are defined
and which are not placed in a section. For setting absolute variables, use the address() attribute
specified under 9.11. Variable Attributes.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 27

XC32 Compiler for PIC32M
How To's

3.5.6

How Can I Make My Interrupt Routine Faster?
Consider suggestions made in 3.5.2. How Can I Make My Code Smaller? (code size) for any interrupt
code. Smaller code is often faster code.
In addition to the code you write in the ISR, there is the code the compiler produces to switch
context. This is executed immediately after an interrupt occurs and immediately before the interrupt
returns, so must be included in the time taken to process an interrupt. This code is optimal in that
only registers used in the ISR will be saved by this code. Thus, the fewer registers used in your ISR
will mean potentially less context switch code to be executed.
Generally simpler code will require fewer resources than more complicated expressions. Use the
assembly list file to see which registers are being used by the compiler in the interrupt code.
®
For information on the list file, see the MPLAB XC32 Assembler, Linker and Utilities User’s Guide
(DS50002186).
Avoid calling other functions from the ISR. In addition to the extra overhead of the function call,
the compiler also saves all general purpose registers that may or may not be used by the called
function. Consider having the ISR simply set a flag and return. The flag can then be checked in
main-line code to handle the interrupt. This has the advantage of moving the complicated interruptprocessing code out of the ISR so that it no longer contributes to its register usage. Always use
the volatile qualifier (see 9.9.2. Volatile Type Qualifier for variables shared by the interrupt and
main-line code, see 3.4.4. How Do I Share Data Between Interrupt and Main-line Code?.

3.5.7

How Big Can C Variables Be?
This question specifically relates to the size of individual C objects, such as arrays or structures. The
total size of all variables is another matter.
To answer this question you need to know in which memory space the variable will be located.
With the default -membedded-data option, objects qualified const will be located in program
memory; other objects will be placed in data memory. Program memory object sizes are discussed
in 10.4.1. Size Limitations of const Variables. Objects in data memory are broadly grouped
into autos and non-autos and the size limitations of these objects, respectively, are discussed in
10.2.1. Non-Auto Variable Allocation and 10.2.3. Non-Auto Variable Size Limits.

3.5.8

What Optimizations Will Be Applied to My Code?
Code optimizations available depend on the edition of your compiler (see 21. Optimizations). A
description of optimization options can be found under 5.7.7. Options for Controlling Optimization.

3.5.9

What Devices are Supported by the Compiler?
New devices are usually added with each compiler release. Check the readme document for a full
list of devices supported by a compiler release.

3.5.10 How Do I Know What Code the Compiler Is Producing?
The assembly list file may be set up, using assembler listing file options, to contain a great deal of
information about the code, such as the assembly output for almost the entire program, including
library routines linked in to your program; section information; symbol listings and more.
The list file may be produced as follows:
•

On the command line, create a basic list file using the option:
-Wa, -a=projectname.lst

•

For MPLAB X IDE, right click on your project and select “Properties.” In the Project Properties
window, click on “xc32-as” under “Categories.” From “Option categories,” select “Listing file
options” and ensure “List to file” is checked.

By default, the assembly list file will have a .lst extension.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 28

XC32 Compiler for PIC32M
How To's
®

For information on the list file, see the “MPLAB XC32 Assembler, Linker and Utilities User’s Guide”
(DS50002186).

3.5.11 How Can I Tell How Big a Function Is?
This size of a function (the amount of assembly code generated for that function) can be determined
from the assembly list file. See 3.5.10. How Do I Know What Code the Compiler Is Producing? for
more on creating an assembly listing file.

3.5.12 How Can I Find Stack Usage Information For Each Function of My Program?
The compiler's stack guidance feature analyzes your program and reports on the estimated
maximum depth of any stack that has been used. If you need stack depth information displayed
individually for each function in your program, you will need to perform an additional step after you
build.
Use the MPLAB XC32 -mchp-stack-usage option when you build your program. Then use the
xc32-objdump utility and its -D option with the object file containing the functions whose stack
depth is required. You might need to use the compiler's -save-temps option when you build the
project so that the object files needed for this utility are not deleted after compilation.
For example, to see the stack information for all the functions in the main.o module, the following
commands could be issued.
xc32-gcc -mprocessor=32MZ2048ECH100 -save-temps -mchp-stack-usage main.c init.c
xc32-objdump -D main.o

The output of xc32-objdump utility might show you something similar to the following.
XC32 stack usage information:
<func1>:
used_stack: 0x70
flags: 0x0
kind: STATIC
<main>:
used_stack: 0x8
flags: 0x0
kind: STATIC
XC32 Stack Usage Version: 0x1

3.5.13 How Do I Know What Resources Are Being Used by Each Function?
In the assembly list file there is information printed for every C function, including library functions.
See 3.5.10. How Do I Know What Code the Compiler Is Producing? for more on creating an assembly
listing file.
To see information on functions calls, you can view the Call Graph in MPLAB X IDE
(Window>Output>Call Graph). You must be in debug mode to see this graph. Right click on a
function and select “Show Call Graph” to see what calls this function and what it calls.
Auto, parameter and temporary variables used by a function may overlap with those from other
functions as these are placed in a compiled stack by the compiler, see 10.3. Auto Variable Allocation
and Access.

3.5.14 How Do I Find Out Where Variables and Functions Have Been Positioned?
You can determine where variables and functions have been positioned from either the assembly
list file (generated by the assembler) or the map file (generated by the linker). Only global symbols
are shown in the map file; all symbols (including locals) are listed in the assembly list file.
There is a mapping between C identifiers and the symbols used in assembly code, which are the
symbols shown in both of these files. The symbol associated with a variable is assigned the address
of the lowest byte of the variable; for functions it is the address of the first instruction generated for
that function.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 29

XC32 Compiler for PIC32M
How To's
®

For more on assembly list files and linker map files, see the MPLAB XC32 Assembler, Linker and
Utilities User’s Guide (DS50002186).

3.5.15 Why Are Some Objects Positioned Into Memory That I Reserved?
Most variables and function are placed into sections that are defined in the linker script. See
the “MPLAB® XC32 Assembler, Linker and Utilities User’s Guide” (DS50002186) for details on linker
scripts. However, some variables and function are explicitly placed at an address rather than being
linked anywhere in an address range, as described in 3.3.3.1. How Do I Position Variables at an
Address I Nominate? and 3.3.3.2. How Do I Position Functions at an Address I Nominate?.
Check the assembly list file to determine the names of sections that hold objects and code. Check
the linker options in the map file to see if sections have been linked explicitly or if they are
®
linked anywhere in a class. See the “MPLAB XC32 Assembler, Linker and Utilities User’s Guide”
(DS50002186) for information on each of these files.

3.5.16 How Do I Know How Much Memory Is Still Available?
A memory usage summary is available from the compiler after compilation (--report-mem option),
from MPLAB X IDE in the Dashboard window. All of these summaries indicate the amount of
memory used and the amount still available, but none indicate whether this memory is one
contiguous block or broken into many small chunks. Small blocks of free memory cannot be used
for larger objects and so out-of-memory errors may be produced even though the total amount of
memory free is apparently sufficient for the objects to be positioned.
Additionally, a Memory Report by Module, showing the memory usage (text, data, and bss sections)
per object file, is provided. This report indicates the size in the final ELF file attributable to each input
object. A miscellaneous entry showing those sections whose input object file cannot be determined
or the type of memory cannot be established is also shown.
Consult the linker map file to determine exactly what memory is still available in each linker class.
This file also indicates the largest contiguous block in that class if there are memory page divisions.
®
See the MPLAB XC32 Assembler, Linker and Utilities User’s Guide (DS50002186) for information on
the map file.

3.5.17 How Do I Use Library Files in My Project?
See 3.2.6. How Do I Build Libraries? for information on how you build your own library files. The
compiler will automatically include any applicable standard library into the build process when you
compile, so you never need to control these files.
To use one or more library files that were built by yourself or a colleague, include them in the list of
files being compiled on the command line. The library files can be specified in any position in the file
list relative to the source files, but if there is more than one library file, they will be searched in the
order specified in the command line.
For example:
xc32-gcc -mprocessor=32MZ2048ECH100 main.c int.c mylib.a
If you are using MPLAB IDE to build a project, add the library file(s) to the Libraries folder that will
shown in your project, in the order in which they should be searched. The IDE will ensure that they
are passed to the compiler at the appropriate point in the build sequence.

3.5.18 How Do I Customize the C Runtime Startup Code?
Some applications may require an application-specific version of the C runtime startup code. For
instance, you may want to modify the startup code for an application loaded by a bootloader.
To customize the startup code for your application:
1. Start with the default startup code, a copy of which is located in the pic32m-libs.zip file located
at:

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 30

XC32 Compiler for PIC32M
How To's

<install-directory>/pic32-libs/
Once the file is unzipped, the source code can be found at:
pic32m-libs/libpic32/startup/crt0.S
2. Make a copy of this crt0.S file, rename it, and add it to your project.
3. Change your MPLAB X project to exclude the default startup code by enabling the “Do not link
startup code” under XC32 xc32-ld Option categories: Libraries page as shown below. When you
build your project, the MPLAB X IDE will build your new application-specific copy of the startup
code rather than linking in the default code.
Figure 3-1. Startup Code Properties Setting

4. You can now edit the assembly code in your new copy of the crt0.S file. The default source
code uses macros defined in the device-specific header files, which are included by xc.h. These
macros define various device specific behavior. Be sure to take this device-specific code into
account when customizing your copy of the code.
Table 3-1. Device-Specific Macros
Device-Specific Macro

Description

__PIC32_SRS_SET_COUNT

Defined to the number of Register Sets implemented on the device.
The default startup code uses this value to determine how many
register sets to use for $GP-register initialization.

__PIC32_HAS_L1CACHE

Defined if the device features an L1 cache.

__PIC32_HAS_MIPS32R2

Defined if the device supports the MIPS32r2 Instruction Set.

__PIC32_HAS_MICROMIPS

Defined if the device supports the microMIPS compressed
Instruction Set.

__PIC32_HAS_DSPR2

Defined if the device supports the DSPr2 Application-Specific
Extension.

__PIC32_HAS_FPU64

Defined if the device supports the single- and double-precision
hardware Floating Point Unit.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 31

XC32 Compiler for PIC32M
How To's

...........continued
Device-Specific Macro

Description

__PIC32_HAS_SSX

Defined if the device does not require initialization of the bus matrix
registers in order to support execution from data memory.

__PIC32_HAS_MMU_MZ_FIXED

Defined if the device features a Memory Management Unit that
should be pre-initialized to a standard SQI and EBI mapping.

__PIC32_HAS_INIT_DATA

Defined if the device requires data initialization by copying from a
template located in Flash to RAM.

3.5.19 What Optimizations Are Employed by the Compiler?
Code optimizations available depend on the edition of your compiler (see 21. Optimizations). A
description of optimization options can be found under 5.7.7. Options for Controlling Optimization.

3.5.20 Why Do I Get Out-of-Memory Errors When I Select a Debugger?
If you use a hardware tool debugger such as MPLAB PICkit 4 in-circuit debugger or MPLAB ICD 4
in-circuit debugger memory is required for the on-board debug executive.

3.5.21 How Do I Stop My Project's Checksum From Changing?
The checksum that represents your built project (whether this is generated by the MPLAB X IDE
or by tools such as Hexmate) is calculated from the generated output of the compiler. Indeed,
the algorithms used to obtain the checksum are specifically designed so that even small changes
in this output are almost guaranteed to produce a different checksum result. Checksums are not
calculated from your project’s source code. To ensure that your checksum does not change from
build to build, you must ensure that the output of the compiler does not change.
The following actions and situations could cause changes in the compiled output and hence changes
in your project’s checksum.
•

Changing the source code, header files, or library code used by the project between builds.

•

Changing the order in which source files or libraries are compiled or linked between builds.

•

Having source code that makes using of macros such as __DATE__ and __TIME__, which
produce output that is dependent on when the project was built.

•

Moving the location of source files between builds, where those files use macros such as
__FILE__, which produces output that is dependent on where the source file is located.

•

Changing the compiler options between builds.

•

Changing the compiler version between builds.

Note that the checksum algorithms used by tools such as Hexmate and the MPLAB X IDE can
change, which can result in a different checksum for the same compiler output. Such changes are
rare, but check the compiler and IDE release notes to see if the tools have been modified.

3.6

Fixing Code That Does Not Work
This section examines issues relating to projects that do not build due to compiler errors, or those
that build, but do not work as expected.
•

3.6.1. How Do I Set Up Warning/Error Messages?

•

3.6.2. How Do I Find the Code that Caused Compiler Errors or Warnings in My Program?

•

3.6.3. How Can I Stop Spurious Warnings From Being Produced?

•

3.6.4. Why Can’t I Even Blink an LED?

•

3.6.5. What Can Cause Corrupted Variables and Code Failure When Using Interrupts?

•

3.2. Invoking the Compiler

•

3.6.5. What Can Cause Corrupted Variables and Code Failure When Using Interrupts?

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 32

XC32 Compiler for PIC32M
How To's

•

3.6.1

3.5.15. Why Are Some Objects Positioned Into Memory That I Reserved?

How Do I Set Up Warning/Error Messages?
To control message output, see 5.7.5. Options for Controlling Warning and Errors.

3.6.2

How Do I Find the Code that Caused Compiler Errors or Warnings in My Program?
In most instances, where the error is a syntax error relating to the source code, the message
produced by the compiler indicates the offending line of code (see 5.6. Compiler Messages). If you
are compiling in MPLAB X IDE, then you can double-click the message and have the editor take you
to the offending line. But identifying the offending code is not always so easy.
In some instances, the error is reported on the line of code following the line that needs attention.
This is because a C statement is allowed to extend over multiple lines of the source file. It is possible
that the compiler cannot be able to determine that there is an error until it has started to scan to
statement following. So in the following code
input = PORTB
if(input>6)
// ...

// oops - forgot the semicolon

The missing semicolon on the assignment statement will be flagged on the following line that
contains the if() statement.
In other cases, the error might come from the assembler, not the code generator. If the assembly
code was derived from a C source file, then the compiler will try to indicate the line in the C source
file that corresponds to the assembly that is at fault. If the source being compiled is an assembly
module, the error directly indicates the line of assembly that triggered the error. In either case,
remember that the information in the error relates to some problem is the assembly code, not the C
code.
Finally, there are errors that do not relate to any particular line of code at all. An error in a compiler
option or a linker error are examples of these. If the program defines too many variables, there is no
one particular line of code that is at fault; the program as a whole uses too much data. Note that the
name and line number of the last processed file and source can be printed in some situations even
though that code is not the direct source of the error.
At the top of each message description, on the right in brackets, is the name of the application that
produced this message. Knowing the application that produced the error makes it easier to track
down the problem. The compiler application names are indicated in 4. XC32 Toolchain and MPLAB X
IDE.
If you need to see the assembly code generated by the compiler, look in the assembly list file. For
®
information on where the linker attempted to position objects, see the map file. See the MPLAB
XC32 Assembler, Linker and Utilities User’s Guide (DS50002186) for information about the list and
map files.

3.6.3

How Can I Stop Spurious Warnings From Being Produced?
Warnings indicate situations that could possibly lead to code failure. Always check your code to
confirm that it is not a possible source of error. In many situations the code is valid and the warning
is superfluous. In this case, you may:
•

Inhibit specific warnings by using the -Wno- version of the option.

•

Inhibit all warnings with the -w option.

•

In MPLAB X IDE, inhibit warnings in the Project Properties window under each tool category. Also
look in the Tool Options window, Embedded button, Suppressible Messages tab.

See 5.7.5. Options for Controlling Warning and Errors for details.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 33

XC32 Compiler for PIC32M
How To's

3.6.4

Why Can’t I Even Blink an LED?
Even if you have set up the TRIS register and written a value to the port, there are several things that
can prevent such a seemingly simple program from working.

3.6.5

•

Make sure that the device’s configuration registers are set up correctly, as discussed in
7.3. Configuration Bit Access. Make sure that you explicitly specify every bit in these registers
and don’t just leave them in their default state. All the configuration features are described in
your device data sheet. If the configuration bits that specify the oscillator source are wrong, for
example, the device clock may not even be running.

•

If the internal oscillator is being used, in addition to Configuration bits there may be SFRs you
need to initialize to set the oscillator frequency and modes, see 7.4. ID Locations and your device
data sheet.

•

To ensure that the device is not resetting because of the watchdog time, either turn off the timer
in the configuration bits or clear the timer in your code. There are library functions you can use
to handle the watchdog timer, described in the 32-bit Language Tool Libraries manual (DS51685).
If the device is resetting, it may never reach the lines of code in your program that blink the LED.
Turn off any other features that may cause device Reset until your test program is working.

•

The device pins used by the port bits are often multiplexed with other peripherals. A pin might
be connected to a bit in a port, or it might be an analog input, or it might be the output of a
comparator, for example. If the pin connected to your LED is not internally connected to the port
you are using, then your LED will never operate as expected. The port function tables in your
device data sheets will show other uses for each pin which will help you identify peripherals to
investigate.

What Can Cause Corrupted Variables and Code Failure When Using Interrupts?
This is usually caused by having variables used by both interrupt and main-line code. If the compiler
optimizes access to a variable or access is interrupted by an interrupt routine, then corruption can
occur. See 3.4.4. How Do I Share Data Between Interrupt and Main-line Code? for more information.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 34

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

4.

XC32 Toolchain and MPLAB X IDE
The 32-bit language tools may be used together under MPLAB X IDE to provide GUI development of
application code for the PIC32 MCU families of devices. The tools are:

4.1

•

MPLAB XC32 C/C++ Compiler

•

MPLAB XC32 Assembler

•

MPLAB XC32 Object Linker

•

MPLAB XC32 Object Archiver/Librarian and other 32-bit utilities

MPLAB X IDE and Tools Installation
In order to use the 32-bit language tools with MPLAB X IDE, you must install:
•

MPLAB X IDE - which is available for free on the Microchip website.

•

MPLAB XC32 C/C++ Compiler - which includes all of the 32-bit language tools. The compiler is
available for free (Free and Evaluation editions) or for purchase (Pro edition) on the Microchip
website.
Important: This version of the C compiler requires MPLAB X IDE v5.05 or higher.

The 32-bit language tools will be installed, by default, in the directory:
•

Windows OS - C:\Program Files\Microchip\xc32\vx.xx

•

Mac OS - /Applications/microchip/xc32/vx.xx

•

Linux OS - /opt/microchip/xc32/vx.xx

where vx.xx is the version number.
The executables for each tool will be in the bin subdirectory. For Windows, these will include:
•

C Compiler driver - xc32-gcc.exe

•

C++ compiler driver - xc32-g++.exe

•

Assembler - xc32-as.exe

•

Object Linker - xc32-ld.exe

•

Object Archiver/Librarian - xc32-ar.exe

•

Other Utilities - xc32-utility.exe

All device include (header) files are located in the /pic32mx/include/proc subdirectory. These
files are automatically incorporated when you #include the <xc.h> header file.
Code examples are located in the examples directory.

4.2

MPLAB X IDE Setup
Once MPLAB X IDE is installed on your PC, launch the application and check the settings below to
ensure that the 32-bit language tools are properly recognized.
1. From the MPLAB X IDE menu bar, select Tools>Options to open the Options dialog. Click on the
“Embedded” button and select the “Build Tools” tab.
2. Click on “XC32” under “Toolchain.” Ensure that the paths are correct for your installation.
3. Click the OK button.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 35

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

Figure 4-1. XC32 Tool Suite Locations in Windows® OS

4.3

MPLAB X IDE Projects
A project in MPLAB X IDE is a group of files needed to build an application, along with their
associations to various build tools. Below is a generic MPLAB X IDE project.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 36

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

Figure 4-2. Compiler Project Relationships

In this MPLAB X IDE project, C source files are shown as input to the compiler. The compiler will
generate source files for input into the assembler. For more information on the compiler, see the
compiler documentation.
Assembly source files are shown as input to the C preprocessor. The resulting source files are input
to the assembler. The assembler will generate object files for input into the linker or archiver. For
more information on the assembler, see the assembler documentation.
Object files can be archived into a library using the archiver/librarian. For more information on the
archiver, see the archiver/librarian documentation.
The object files and any library files, as well as a linker script file (generic linker scripts are added
automatically), are used to generate the project output files via the linker. The output file that may
be generated by the linker is a debug file (.elf) used by the simulator and debug tools which may
be input into the bin2hex utility to produce an executable file (.hex). For more information on linker
script files and using the object linker, see the linker documentation.
For more on projects and related workspaces, see MPLAB X IDE documentation.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 37

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

4.4

Project Setup
To set up an MPLAB X IDE project for the first time, use the built-in Project Wizard (File>New
Project). In this wizard, you will be able to select a language toolsuite that uses the 32-bit language
tools. For more on the wizard, and MPLAB X IDE projects, see MPLAB X IDE documentation.
Once you have a project set up, you may then set up properties of the tools in MPLAB X IDE.
1. From the MPLAB X IDE menu bar, select File>Project Properties to open a window to set/check
project build options.
2. Under “Conf:[default]”, select a tool from the tool collection to set up.
– 4.4.1. XC32 (Global Options)
– 4.4.2. xc32-as (32-bit Assembler)
– 4.4.3. xc32-gcc (32-bit C Compiler)
– 4.4.4. xc32-g++ (32-bit C++ Compiler)
– 4.4.5. xc32-ld (32-Bit Linker)

4.4.1

XC32 (Global Options)
Set up global options for all 32-bit language tools. See also 4.4.8. Options Page Features.
Table 4-1. XC32 (Global Options) All Options Category
Option

Description

Command Line

Override default device support

Select “Do not override” to build the
project with a default DFP. Select
“Compiler location” to use the relevant
DFP shipped with the compiler. DFPs
provide device-specific information,
such as register names and addresses,
which can be used by code in the
project.

-mdfp

Don’t delete intermediate files

Don’t delete intermediate Files. Place
them in the object directory and name
them based on the source file.

-save-temps[=dir]

Link-Time Optimizations

When these optimzations are enabled,
the build will be constrained in the
following ways:
- The per-file build settings will be
ignored

-f[no-]lto

- The build will no longer be an
incremental one (full build only)
Use GP relative addressing threshold

Put definitions of externally-visible data
in a small data section if that data is no
bigger than num bytes.

-G num

Common include dirs

Directory paths entered here will be
appended to the already existing
include paths of the compiler.

-I dir

Relative paths are from the MPLAB X IDE
project directory.

4.4.2

xc32-as (32-bit Assembler)
Select a category and set up assembler options. Note that the options specified are for the
assembler tool (xc32-as) and are not for the xc32-gcc option. For additional options, see MPLAB®
XC32 Assembler, Linker And Utilities User’s Guide documentation. See also 4.4.8. Options Page
Features.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 38

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

Table 4-2. XC32-AS General Options Category
Option

Description

Command Line

Have symbols in production build

Generate debugging information for source-level
debugging in MPLAB X.

--gdwarf-2 See the MPLAB®
XC32 Assembler, Linker and
Utilities User's Guide

Keep local symbols

Check to keep local symbols, that is, labels
beginning with .L (upper case only).

--keep-locals
See the MPLAB® XC32 Assembler,

Uncheck to discard local symbols.

Linker and Utilities User's Guide

Exclude floating-point library

Exclude support for floating-point operations
reducing code size for applications that do not
require floating-point support.

-mno-float

Generate MIPS16 16-bit code

Changes the assembler's default assembly mode so -mips16 See the MPLAB® XC32
it will attempt to build for the MIPS16 ISA. You can
Assembler, Linker and Utilities
still override this setting with the .set isa-mode
User's Guide
directives.

Generate microMIPS compressed
code

Changes the assembler's default assembly mode so -mmicromips See the MPLAB®
it will attempt to build for the microMIPS ISA. You
XC32 Assembler, Linker and
can still override this setting with the .set isaUtilities User's Guide
mode directives.

Preprocessor macro definitions

Project-specific preprocessor macro defines passed
via the compiler's –D option.

Assembler symbols

Define symbol sym to a given value.

-Dmacro[=defn] See the

MPLAB® XC32 Assembler, Linker
and Utilities User's Guide
--defsym sym=value
See the MPLAB® XC32 Assembler,

Linker and Utilities User's Guide
-I dir See the MPLAB® XC32

Preprocessor Include directories

Add a directory to the list of those searched for
headers included by the preprocessor. Relative
paths are from MPLAB X project directory.

Assembler Include directories

Add a directory to the list of those searched for files -Idir
specified in .include directives. Relative paths are See the MPLAB ®XC32 Assembler,
Linker and Utilities User's Guide.
from MPLAB X project directory.

Assembler, Linker and Utilities
User's Guide

You may add as many directories as necessary
to include a variety of paths. The current working
directory is always searched first and then -I
directories in the order in which they were specified
(left to right) here.

Table 4-3. XC32-AS Other Options Category
Option

Description

Command Line

Diagnostics level

Select warnings to display in the Output window.
Select “Generate warnings” to have the usual
warnings issued by the compiler; “Suppress
warnings”to have only errors displayed, and "Fatal
Warnings" to have the assembler treat warnings as
if they were errors.

--[no-]warn
--fatal-warnings
See the MPLAB® XC32
Assembler, Linker and Utilities
User's Guide

Include source code

Check for a high-level language listing. High-level
-ah See the MPLAB® XC32
listings require that the assembly source code is
Assembler, Linker and Utilities
generated by a compiler, a debugging option like -g User's Guide
is given to the compiler, and assembly listings (-al)
are requested.
Uncheck for a regular listing.

Expand macros

Check to expand macros in a listing.
Uncheck to collapse macros.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

-am See the MPLAB® XC32
Assembler, Linker and Utilities
User's Guide

DS50002799E - 39

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

...........continued
Option

Description

Command Line

Include false conditionals

Check to include false conditionals (.if, .ifdef)
in a listing.
Uncheck to omit false conditionals.

-ac
See the MPLAB® XC32

Omit forms processing

Include assembly

List symbols

Omit debugging directives

List to file

4.4.3

Assembler, Linker and Utilities
User's Guide

Check to turn off all forms processing
that would be performed by the listing
directives .psize, .eject, .title and .sbttl.
Uncheck to process by listing directives.

-an
See the MPLAB® XC32

Check for an assembly listing. This -a suboption
may be used with other suboptions.

-al
See the MPLAB® XC32

Assembler, Linker and Utilities
User's Guide

Uncheck to exclude an assembly listing.

Assembler, Linker and Utilities
User's Guide

Check for a symbol table listing.
Uncheck to exclude the symbol table from the
listing.

-as
See the MPLAB® XC32

Check to omit debugging directives from a listing.
This can make the listing cleaner.
Uncheck to included debugging directives.

-ad
See the MPLAB® XC32

Assembler, Linker and Utilities
User's Guide

Use this option if you want the assembly listing for
any assembly source files in the project.
They will have the same basename as the source,
with a .lst extension.

Assembler, Linker and Utilities
User's Guide
-a=file.lst
See the MPLAB® XC32

Assembler, Linker and Utilities
User's Guide

xc32-gcc (32-bit C Compiler)
A subset of command-line options may be specified in MPLAB X IDE. Select a category and set up
compiler options.
See also 4.4.8. Options Page Features.
Table 4-4. XC32-GCC General Category
Option

Description

Command Line

Have symbols in production build

Build for debugging in a production
build image.

-g

Enable App IO

Support the APPIN/APPOUT debugging
feature with REAL ICE.

-mappio-debug

Isolate each function in a section

-ffunction-sections
This option is often used with the
linker's --gc-sections option to
remove unreferenced functions.
Check to place each function into its
own section in the output file. The name
of the function determines the section’s
name in the output file.
Note: When you specify this option, the
assembler and linker may create larger
object and executable files and will also
be slower.
Uncheck to place multiple functions in a
section.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 40

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

...........continued
Option

Description

Command Line

Place data into its own section

-fdata-sections
This option is often used with
the linker's --gc-sections option
to remove unreferenced staticallyallocated variables.
Place each data item into its own section
in the output file.
The name of the data item determines
the name of the section. When you
specify this option, the assembler and
linker may create larger object and
executable files and will also be slower.

Enable toplevel reordering

Allows the compiler to reorder toplevel functions, variables, and asm
statements, in which case, they might
not be output in the same order that
they appear in the input file.

-ftoplevel-reorder

Use indirect calls

Enable full-range calls.

-mlong-calls

Generate MIPS16 16-bit code

Generate code for the MIPS16
instruction set, reducing code size.

-[mno-]mips16

Generate microMIPS compressed code

Generate code using the microMIPS™
instructions. This feature is available
only in the PRO edition.

-m[no-]micromips

Exclude floating-point library

-mno-float
Exclude support for floating-point
operations reducing code size for
applications that do not require floatingpoint support.

Note that some of the compiler options specified by fields in Project Property Categories other than
Optimization can affect the size and execution speed of your project. Consider using the Compiler
Advisor, accessible via the MPLAB X IDE Tools > Analysis > Compiler Advisor menu item, to compare
the size of your project when built with different combination of compiler options.
Table 4-5. XC32-GCC Optimization Category
Option

Description

Command Line

Optimization Level

-O0 -O1 -O2 -O3 -Os
Select an optimization level. Your
compiler edition may support only some
optimizations. Equivalent to -On option,
where n is an option below:
0 - Do not optimize. The compiler’s goal
is to reduce the cost of compilation
and to make debugging produce the
expected results.
1 - Optimize. Optimizing compilation
takes somewhat longer and a lot more
host memory for a large function. The
compiler tries to reduce code size and
execution time.
2 - Optimize even more. The
compiler performs nearly all supported
optimizations that do not involve a
space-speed trade-off.
3 - Optimize yet more favoring speed
(superset of O2).
s - Optimize yet more favoring size
(superset of O2).

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 41

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

...........continued
Option

Description

Command Line

Unroll loops

This option often increases execution
speed at the expense of larger code
size.
Check to perform the optimization of
loop unrolling. This is only done for
loops whose number of iterations can
be determined at compile time or run
time.

-funroll-loops

Uncheck to not unroll loops.
Omit frame pointer

Check to not keep the Frame Pointer in
a register for functions that don’t need
one.
Uncheck to keep the Frame Pointer.

-fomit-frame-pointer

Pre-optimization instruction scheduling

Default for optimization level:
- Disable

-f[no-]schedule-insns

- Enable
Post-optimization instruction scheduling Default for optimization level:
- Disable

-f[no-]schedule-insns2

- Enable
Use common tentative definitions

Controls the placement of global
variables defined without an initializer.

-f[no-]common

Table 4-6. XC32-GCC Preprocessing and Messages Category
Option

Description

Command Line

Preprocessor macros

Project-specific preprocessor macro
defines passed via the compiler's –D
option.

-Dmacro=defn

Include directories

Search these directories for projectspecific include files.

-I dir

Make warnings into errors

Check to halt compilation based on
warnings as well as errors.
Uncheck to halt compilation based on
errors only.

-Werror

Additional warnings

Check to enable all warnings.
Uncheck to disable warnings.

-Wall

Enable address-attribute warning

4.4.4

-Waddress-attribute-use

support-ansi

Check to issue all warnings demanded
by strict ANSI C.
Uncheck to issue all warnings.

-ansi

strict-ansi

Issue all the warnings demanded by
strict ISO C and ISO C++; reject
all programs that use forbidden
extensions, and some other programs
that do not follow ISO C and ISO C++.

-pedantic

Use CCI syntax

Enable support for the CCI syntax (see
25. Common C Interface).

-mcci

Use IAR syntax

Enable support for syntax used by other -mext=IAR
toolchain vendors.

xc32-g++ (32-bit C++ Compiler)
A subset of command-line options may be specified in MPLAB X IDE. Select a category and set up
C++ options.
See also 4.4.8. Options Page Features.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 42

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

Table 4-7. XC32-G++ C++ Specific Category
Option

Description

Command Line

Generate run time type
descriptor information

-frtti
Enable generation of information about every class
with virtual functions for use by the C++ runtime type
identification features (dynamic_cast and typeid).
If you don't use those parts of the language, you
can save some space by disabling this option. Note
that exception handling uses the same information,
but it will generate it as needed. The dynamic_cast
operator can still be used for casts that do not
require runtime type information, that is, casts to
void * or to unambiguous base classes.

Enable C++ exception handling Enable exception handling. Generates extra code
needed to propagate exceptions.

-fexceptions

Check that the pointer
returned by operator 'new' is
non-null

Check that the pointer returned by operator new
is non-null before attempting to modify the storage
allocated.

-fcheck-new

Generate code to check
for violation of exception
specification

Generate code to check for violation of exception
specifications at runtime. Using this option may
increase code size in production builds.

-fenforce-eh-specs

Table 4-8. XC32-G++ General Category
Option

Description

Command Line

Have symbols in production
build

Build for debugging in a production build image.

-g

Enable App IO

Support the APPIN/APPOUT debugging feature with
REAL ICE.

-mappio-debug

Isolate each function in a
section

Place each function into its own section in the output -ffunction-sections
file if the target supports arbitrary sections. The
name of the function or the name of the data item
determines the section's name in the output file.
This option is useful when combined with the linker’s
--gc-sections option to remove unreferenced
functions.

Place data into its own section

Place each data item into its own section in the
output file if the target supports arbitrary sections.
The name of the function or the name of the
data item determines the section's name in the
output file. This option is useful when combined
with the linker’s --gc-sections option to remove
unreferenced variables.

-fdata-sections

Enable toplevel reordering

Allows the compiler to reorder top-level functions,
variables, and asm statements, in which case, they
might not be output in the same order that they
appear in the input file.

-ftoplevel-reorder

Use indirect calls

Enable full-range calls.

-mlong-calls

Generate MIPS16 16-bit code

By default, generate code for the MIPS16 instruction
set, reducing code size.

-mips16

Generate microMIPS
compressed code

Generate code using the microMIPS™ instructions.
This feature is available only in the PRO edition.

-m[no-]micromips

Exclude floating-point library

Exclude support for floating-point operations
reducing code size for applications that do not
require floating-point support.

-mno-float

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 43

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

Table 4-9. XC32-G++ Optimization Category
Option

Description

Command Line

Optimization Level

Select an optimization level. Your compiler edition
may support only some optimizations. Equivalent to
-On option, where n is an option below:
0 - Do not optimize. The compiler’s goal is to reduce
the cost of compilation and to make debugging
produce the expected results.

-O0 -O1 -O2 -O3 -Os

1 - Optimize. Optimizing compilation takes
somewhat longer and a lot more host memory for
a large function. The compiler tries to reduce code
size and execution time.
2 - Optimize even more. The compiler performs
nearly all supported optimizations that do not
involve a space-speed trade-off.
3 - Optimize yet more favoring speed (superset of
O2).
s - Optimize yet more favoring size (superset of O2).
Unroll loops

Check to perform the optimization of loop unrolling.
This is only done for loops whose number of
iterations can be determined at compile time or run
time.
Uncheck to not unroll loops.

Omit frame pointer

Check to not keep the Frame Pointer in a register for -fomit-frame-pointer
functions that don’t need one.
Uncheck to keep the Frame Pointer.

Pre-optimization instruction
scheduling

Default for optimization level:
- Disable

-funroll-loops

-f[no-]schedule-insns

- Enable
Post-optimization instruction
scheduling

Default for optimization level:
- Disable

-f[no-]schedule-insns2

- Enable

Table 4-10. XC32-G++ Preprocessing and Messages Category
Option

Description

Command Line

Preprocessor macros

Project-specific preprocessor macro defines passed via the
compiler’s –D option.

-Dmacro[=defn]

Include directories

Search these directories for project-specific include files.

-I path

Make warnings into errors Check to halt compilation based on warnings as well as errors.

-Werror

Uncheck to halt compilation based on errors only.
Additional warnings

Check to enable all warnings.

-Wall

Uncheck to disable warnings.
Enable address-attribute
warning

4.4.5

-Waddress-attributeuse

strict-ansi

Issue all the warnings demanded by strict ISO C and ISO C++;
reject all programs that use forbidden extensions, and some other
programs that do not follow ISO C and ISO C++.

-pedantic

Use CCI syntax

Enable support for the CCI syntax (25. Common C Interface).

-mcci

Use IAR syntax

Enable support for syntax used by other toolchain vendors.

-mext=IAR

xc32-ld (32-Bit Linker)
A subset of command-line options may be specified in MPLAB X IDE. Select a category and set up
linker options.
See also 4.4.8. Options Page Features.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 44

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

Table 4-11. XC32-LD General Category
Option

Description

Command Line

Heap Size (bytes)

Specify the size of the heap in bytes. Allocate a runtime heap of size bytes for use by C programs. The
heap is allocated from unused data memory. If not
enough memory is available, an error is reported.

-Wl,-defsym=_min_heap_size=size
See MPLAB® XC32 Assembler, Linker
and Utilities User's Guide.

Minimum stack size (bytes)

Specify the minimum size of the stack in bytes. By
default, the linker allocates all unused data memory
for the run-time stack. Alternatively, the programmer
may allocate the stack by declaring two global
symbols: __SP_init and __SPLIM_init. Use this
option to ensure that at least a minimum sized stack
is available. The actual stack size is reported in the
link map output file. If the minimum size is not
available, an error is reported.

-Wl,-defsym=_min_stack_size=size
See MPLAB® XC32 Assembler,
Linker and Utilities User's Guide.

Allow overlapped sections

Check to not check section addresses for overlaps.
Uncheck to check for overlaps.

--[no-]check-sections See

Remove unused sections

Check to enable garbage collection of unused input
sections (on some targets).
Uncheck to disable garbage collection.

Use response file to link

Pass linker options in a file rather than on the
command line. On Windows systems, this option
allows you to properly link projects with a large
number of object files that would normally overrun
the command-line length limitation of the Windows
OS.

Write Start Linear Address
record

Set the start linear address for a type 5 records in
HEX files.

Additional driver options

Type here any additional driver options that do not
have dedicated GUI widgets in the Project Properties
dialog. The string entered here will be emitted
verbatim with the other driver options.

MPLAB® XC32 Assembler, Linker and
Utilities User's Guide.
--[no-]gc-sections See MPLAB®

XC32 Assembler, Linker and Utilities
User's Guide.

--write-sla
See MPLAB® XC32 Assembler, Linker
and Utilities User's Guide.

Place code in data init template Place code sections into the data-initialization
template stored in the .dinit section.

--code-in-dinit

Allocate data-init section to
serial memory

--dinit-in-serial-mem

Allocate the .dinit template section to a
memory region named serial_mem rather than
kseg0_program_mem.

Table 4-12. XC32-LD Libraries Category
Option

Description

Command Line

Optimization level of Standard
Libraries

Select an optimization level. Your compiler edition
may support only some optimizations. Equivalent to
-On option, where n is an option below:
0 - Do not optimize. The compiler’s goal is to reduce
the cost of compilation and to make debugging
produce the expected results.

-On
See MPLAB® XC32 Assembler, Linker
and Utilities User's Guide.

1 - Optimize. Optimizing compilation takes
somewhat longer and a lot more host memory for
a large function. The compiler tries to reduce code
size and execution time.
2 - Optimize even more. The compiler performs
nearly all supported optimizations that do not
involve a space-speed trade-off.
3 - Optimize yet more favoring speed (superset of
O2).
s - Optimize yet more favoring size (superset of O2).

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 45

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

...........continued
Option

Description

Command Line

System Libraries

Add libraries to be linked with the project files. You
may add more than one.

--library=name
See MPLAB® XC32 Assembler, Linker
and Utilities User's Guide.

Library directories

Add a library directory to the library search path. You --library-path="name"
may add more than one.
See MPLAB® XC32 Assembler, Linker
and Utilities User's Guide.

Exclude Standard Libraries

-nostdlib
Check to not use the standard system startup files
or libraries when linking. Only use library directories See MPLAB® XC32 Assembler, Linker
specified on the command line.
and Utilities User's Guide.
Uncheck to use the standard system startup files and
libraries.

Do no link crt0 startup code

Exclude the default startup code because the project -nostartfiles
provides application-specific startup code.
See MPLAB® XC32 Assembler, Linker
and Utilities User's Guide.

Do not link device startup code
Link MIPS16 libraries

Link the libraries precompiled for the MIPS16
instruction set, reducing code size.

-mips16
See MPLAB® XC32 Assembler, Linker
and Utilities User's Guide.

Link microMIPS™ compressed
startup code and libraries

Generate code using the microMIPS™ instructions.
This feature is available only in the PRO edition.

-mmicromips See MPLAB® XC32
Assembler, Linker and Utilities User's
Guide.

Table 4-13. XC32-LD Fill Flash Memory Category
Option

Description

Command Line

Which areas to fill

Specify which area of Flash memory to fill.
No Fill - None (default).

--fill=sequence See MPLAB®
XC32 Assembler, Linker and Utilities
User's Guide.

Fill All Unused - Fill all unused memory.
Provide Range to fill - Fill a range of memory. Enter
a range under “Memory Address Range.”
How to fill it

Specify how to fill Flash memory.
Provide sequence of values - provide a sequence
under the Sequence option.

--fill=sequence See MPLAB®

XC32 Assembler, Linker and Utilities
User's Guide.

Constant or incrementing value - provide
a constant, increment/decrement or increment/
decrement constant under the same-named option.
Sequence

When Provide sequence of values is selected, enter --fill=sequence See MPLAB®
a sequence. The form is n1, n2, .... where n1 uses C
XC32 Assembler, Linker and Utilities
syntax. Example: 0x10, 25, 0x3F, 16.
User's Guide.

Constant

When Constant or incrementing value is selected, --fill=sequence See MPLAB®
enter a constant. Specify the constant using C syntax XC32 Assembler, Linker and Utilities
(for example, 0x for hex, 0 for octal). Example: 0x10 is User's Guide.
the same as 020 or 16.

Increment/Decrement

When Constant or incrementing value is selected,
you can select to increment or decrement the initial
value of “Constant” on each consecutive address.
No Incrementing - do not change constant value.

--fill=sequence See MPLAB®
XC32 Assembler, Linker and Utilities
User's Guide.

Increment Const - increment the constant value by
the amount specified under the option “Increment/
Decrement Constant.”
Decrement Const - decrement the constant value by
the amount specified under the option “Increment/
Decrement Constant.”

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 46

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

...........continued
Option

Description

Command Line

Increment/Decrement
Constant

When Increment Const or Decrement Const is
selected, enter a constant increment or decrement
value. Specify the constant using C syntax (for
example, 0x for hex, 0 for octal). Example: 0x10 is
the same as 020 or 16.

--fill=sequence See MPLAB®
XC32 Assembler, Linker and Utilities
User's Guide.

Memory Address Range

When Provide Range to fill is selected, enter the
range here. Specify range as Start:End where Start
and End use C syntax. Example 0x100:0x1FF is the
same as 256:511.

--fill=sequence See MPLAB®

XC32 Assembler, Linker and Utilities
User's Guide.

Table 4-14. XC32-LD Diagnostics Category
Option

Description

Command Line

Generate map file

Create a map file.

-Map="file" See MPLAB® XC32
Assembler, Linker and Utilities User's
Guide.

Display memory usage

Check to print memory usage report.

--report-mem See MPLAB® XC32

Generate cross-reference file

Uncheck to not print a report.

Assembler, Linker and Utilities User's
Guide.

Check to create a cross-reference table.

--cref See MPLAB® XC32 Assembler,
Linker and Utilities User's Guide.

Uncheck to not create this table.
Warn on section realignment

Check to warn if start of section changes --warn-section-align See MPLAB®
due to alignment.
XC32 Assembler, Linker and Utilities
User's Guide.
Uncheck to not warn.

Trace Symbols

Add/remove trace symbols.

-Y symbol or
--trace-symbol=symbol See MPLAB®
XC32 Assembler, Linker and Utilities
User's Guide.

Table 4-15. XC32-LD Symbols and Macros Category
Option

Description

Command Line

Linker symbols

Create a global symbol in the output file containing
--defsym=sym See MPLAB® XC32
the absolute address (expr). You may use this
Assembler, Linker and Utilities User's
option as many times as necessary to define multiple Guide.
symbols in the command line. A limited form of
arithmetic is supported for the expr in this context:
you may give a hexadecimal constant or the name of
an existing symbol, or use + and - to add or subtract
hexadecimal constants or symbols.

Preprocessor macro definitions Add linker macros.

-Dmacro See MPLAB® XC32

Symbols

-S or

Assembler, Linker and Utilities User's
Guide.

Specify symbol information in the output.

--strip-debug; -s or
--strip-all See MPLAB® XC32
Assembler, Linker and Utilities User's
Guide.

4.4.6

xc32-ar (Library Archiver)
A subset of command-line options may be specified in MPLAB X IDE. Select a category and set up
linker options.
See also 4.4.8. Options Page Features.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 47

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

Table 4-16. XC32-AR General Category

4.4.7

Option

Description

Command Line

Break line into multiple lines

When using the Windows compiler to archive many
file into libraries, the link command line might go
over the 8191 character line limit. This option has
XC32 break up the command line into smaller lines
to avoid this limitation.

n/a

Analysis
Select a category and set up analysis options.
See also 4.4.8. Options Page Features.
Table 4-17. Analysis General Options Category

4.4.8

Option

Description

Command Line

Code coverage instrumentation

Enable the code coverage feature.

-mcodecov

Stack guidance

Check to enable the stack guidance feature, which
gives an estimate of stack usage.

-mchp-stack-usage

Options Page Features
The Options section of the Properties page has the following features for all tools:
Table 4-18. Page Features Options

4.5

Reset

Reset the page to default values.

Additional options

Enter options in a command-line (non-GUI) format.

Option Description

Click on an option name to see information on the option in this window. Not
all options have information in this window.

Generated Command Line

Click on an option name to see the command-line equivalent of the option in
this window.

Project Example
In this example, you will create an MPLAB X IDE project with two C code files.

4.5.1

Run the Project Wizard
In MPLAB X IDE, select File>New Project to launch the wizard.
1. Choose Project: Select “Microchip Embedded” for the category and “Standalone Project” for the
project. Click Next> to continue.
2. Select Device: Select the dsPIC30F6014. Click Next> to continue.
3. Select Header: There is no header for this device so this is skipped.
4. Select Tool: Choose a development tool from the list. Tool support for the selected device is
shown as a colored circle next to the tool. Mouse over the circle to see the support as text. Click
Next> to continue.
5. Select Compiler: Choose a version of the XC32 toolchain. Click Next> to continue.
6. Select Project Name and Folder: Enter a project name, such as MyXC32Project. Then select a
location for the project folder. Click Finish to complete the project creation and setup.
Once the Project Wizard has completed, the Project window should contain the project tree. For
more on projects, see the MPLAB X IDE documentation.

4.5.2

Set Build Options
Select File>Project Properties or right click on the project name and select “Properties” to open the
Project Properties dialog.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 48

XC32 Compiler for PIC32M
XC32 Toolchain and MPLAB X IDE

1. Under “Conf:[default]>XC32 (Global Options)”, select “xc32-gcc.”
2. Under “Conf:[default]>XC32 (Global Options)”, select “xc32-ld.”
3. Select “Diagnostics” from the “Option Categories.” Then enter a file name to “Generate map file,”
that is, example.map.
4. Click the OK button on the bottom of the dialog to accept the build options and close the dialog.

4.5.3

Build the Project
Right-click on the project name, “MyXC32Project,” in the project tree and select “Build” from the
pop-up menu. The Output window displays the build results.
If the build did not complete successfully, check these items:
1. Review the previous steps in this example. Make sure you have set up the language tools
correctly and have all the correct project files and build options.
2. If you modified the sample source code, examine the Build tab of the Output window for syntax
errors in the source code. If you find any, click on the error to go to the source code line that
contains that error. Correct the error, and then try to build again.

4.5.4

Output Files
View the project output files by opening the files in MPLAB X IDE.
1. Select File>Open File. In the Open dialog, find the project directory.
2. Under “Files of type” select “All Files” to see all project files.
3. Select File>Open File. In the Open dialog, select “example.map.” Click Open to view the linker
map file in an MPLAB X IDE editor window. For more on this file, see the linker documentation.
4. Select File>Open File. In the Open dialog, return to the project directory and then
go to the dist>default>production directory. Notice that there is only one hex file,
“MyXC32Project.X.production.hex.” This is the primary output file. Click Open to view the hex
file in an MPLAB X IDE editor window. For more on this file, see the Utilities documentation.
There is also another file, “MyXC32Project.X.production.elf.” This file contains debug information
and is used by debug tools to debug your code. For information on selecting the type of debug
file, see 4.4.1. XC32 (Global Options).

4.5.5

Further Development
Usually, your application code will contain errors and not work the first time. Therefore, you will
need a debug tool to help you develop your code. Using the output files previously discussed,
several debug tools exist that work with MPLAB X IDE to help you do this. You may choose
from simulators, in-circuit emulators or in-circuit debuggers, either manufactured by Microchip
Technology or third-party developers. Please see the documentation for these tools to learn how
they can help you. When debugging, you will use Debug>Debug Project to run and debug your code.
Please see MPLAB X IDE documentation for more information.
Once you have developed your code, you will want to program it into a device. Again, there are
several programmers that work with MPLAB X IDE to help you do this. Please see the documentation
for these tools to see how they can help you. When programming, you will use “Make and Program
Device Project” button on the debug toolbar. Please see MPLAB X IDE documentation concerning
this control.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 49

XC32 Compiler for PIC32M
Command-line Driver

5.

Command-line Driver
The MPLAB XC32 C Compiler command-line driver, xc32-gcc, can be invoked to perform all aspects
of compilation, including C code generation, assembly and link steps. Its use is the recommended
way to invoke the compiler, as it hides the complexity of all the internal applications and provides
a consistent interface for all compilation steps. Even if an IDE is used to assist with compilation, the
IDE will ultimately call xc32-gcc.
If you are developing a project that contains C++ source code, an alternate driver called xc32-g++
is supplied and that will link in an alternate set of libraries. Its operation is similar to the xc32-gcc
driver.
This chapter describes the steps that the driver takes during compilation, the files that the driver can
accept and produce, as well as the command-line options that control the compiler’s operation.

5.1

Invoking The Compiler
This section explains how to invoke xc32-gcc on the command line and discusses the input files
that can be passed to the compiler.
Environment variables that can be set to specify certain aspects of the compiler's behavior are also
explained.

5.1.1

Driver Command-line Format
The xc32-gcc driver can be used to compile and assemble C and assembly source files, as well as
link object files and library archives to form a final program image.
The xc32-g++ driver must instead be used when the module source is written in C++.
The driver has the following basic command format:
xc32-gcc [options] files

So, for example, to compile and link the C source file hello.c, you could use the command:
xc32-gcc -mprocessor=32MZ2048ECH100 -O2 -o hello.elf hello.c

The format for the C++ driver is similar.
xc32-g++ [options] files

And this driver is used in a similar way, for example:
xc32-g++ -mprocessor=32MZ2048ECH100 -O2 -o hello.elf hello.cpp

Throughout this manual, it is assumed that the compiler applications are in your console’s search
path. See 5.1.2. Environment Variables for information on the environment variable that specifies
the search locations. Alternatively, use the full directory path along with the driver name when
executing the compiler.
It is customary to declare options (identified by a leading dash “-” or double dash “--”) before the
files’ names; however, this is not mandatory.
Command-line options are case sensitive, with their format and description being supplied in
5.7. Driver Option Descriptions. Many of the command-line options accepted by xc32-gcc are
common to all the MPLAB XC compilers, to allow greater portability between devices and compilers.
The files can be any mixture of C/C++ and assembler source files, as well as relocatable object files
and archive files. While the order in which these files are listed does not directly affect the operation
of the program, it can affect the allocation of code or data. Note, that the order of the archive files

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 50

XC32 Compiler for PIC32M
Command-line Driver

will dictate the order in which they are searched, and in some situations, this might affect which
modules are linked in to the program.
It is recommended that C-only projects use the xc32-gcc driver. If you have C++ source code or a
mix of C and C++ source, always use xc32-g++ driver to ensure the correct libraries are linked in.

5.1.2

Environment Variables
The environment variables in this section are optional, but if defined, they will be used by the
compiler. The compiler driver (or other subprogram) may choose to determine an appropriate
value for some of the following environment variables if they are not set. The driver (or other
subprogram) takes advantage of internal knowledge about the installation of the compiler. As long
as the installation structure remains intact, with all subdirectories and executables remaining in the
same relative position, the driver or subprogram will be able to determine a usable value.
The XC32-style variables should be used for new projects; however, the PIC32-style variables may be
used for legacy projects.
Table 5-1. Compiler-Related Environment Variables
Variable

Description

XC32_C_INCLUDE_PATH or
PIC32_C_INCLUDE_PATH

This variable’s value is a semicolon-separated list of directories, much like your host
terminal's PATH environment variable. When the compiler searches for header files, it tries
the directories listed in the variable, after the directories specified with -I but before the
standard header file directories.
If the environment variable is undefined, the preprocessor chooses an appropriate value
based on the standard installation. By default, the following directories are searched for the
following include files:
<install-path>\pic32mx\include.

XC32_COMPILER_PATH or
PIC32_COMPILER_PATH

The value of this variable is a semicolon-separated list of directories, much like your host
terminal's PATH environment variable. The compiler tries the directories thus specified when
searching for subprograms, if it can’t find the subprograms using PIC32M_EXEC_PREFIX.

XC32_EXEC_PREFIX or
PIC32_EXEC_PREFIX

If this environment variable is set, it specifies a prefix to use in the names of subprograms
executed by the compiler. No directory delimiter is added when this prefix is combined with
the name of a subprogram, but you can specify a prefix that ends with a slash if you wish.
If the compiler cannot find the subprogram using the specified prefix, it tries looking in your
PATH environment variable.
If the environment variable is not set or set to an empty value, the compiler driver chooses
an appropriate value based on the standard installation. If the installation has not been
modified, this will result in the driver being able to locate the required subprograms.
Other prefixes specified with the -B command line option take precedence over the user- or
driver-defined value of the variable.
Under normal circumstances it is best to leave this value undefined and let the driver locate
subprograms itself.

XC32_LIBRARY_PATH or
PIC32_LIBRARY_PATH

This variable’s value is a semicolon-separated list of directories, much like PATH. This variable
specifies a list of directories to be passed to the linker. The driver’s default evaluation of this
variable is:
<install-path>\lib;
<install-path>\pic32mx\lib

TMPDIR

5.1.3

If this variable is set, it specifies the directory to use for temporary files. The compiler uses
temporary files to hold the output of one stage of compilation that is to be used as input
to the next stage: for example, the output of the preprocessor, which is the input to the
compiler proper.

Input File Types
The xc32-gcc driver distinguishes source files, intermediate files and library files solely by the file
type, or extension. The following case-sensitive extensions, listed below are recognized.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 51

XC32 Compiler for PIC32M
Command-line Driver

Table 5-2. Input File Types
Extension

File format

.c

C source file

.i

Preprocessed C source file

.cpp

C++ source file

.ii

Preprocessed C++ source file

.s

Assembler source file

.S

Assembly source file requiring preprocessing

.o

Relocatable object code file

.a

Archive (library) file

other

A file to be passed to the linker

There are no compiler restrictions imposed on the names of source files, but be aware of case,
name-length, and other restrictions that are imposed by your host operating system.
Avoid using the same base name for assembly and C/C++ source files, even if they are located in
different directories. So, for example, if a project contains a C source file called init.c, do not also
add to the project an assembly source file with the name init.s. Avoid, also, having source files
with the same base name as the MPLAB X IDE project name.
The terms source file and module are often used interchangeably, but they refer to the source code
at different points in the compilation sequence.
A source file is a file that contains all or part of a program. It may contain C/C++ code, as well as
preprocessor directives and commands. Source files are initially passed to the preprocessor by the
compiler driver.
A module is the output of the preprocessor for a given source file, after the inclusion of any header
files specified by#include preprocessor directives, and after the processing and subsequent
removal of other preprocessor directives (with the possible exception of some commands for
debugging). Thus, a module is usually the amalgamation of a source file and several header files,
and it is this output that is passed to the remainder of the compiler applications. A module is also
referred to as a translation unit.
Like assembly source files, these terms can also be applied to assembly files, which can be
preprocessed and can include other header files.

5.2

The C Compilation Sequence
When you compile a project, many internal applications are called by the driver to do the work. This
section introduces these internal applications and describes how they relate to the build process,
especially when a project consists of multiple source files. This information should be of particular
interest if you are using a make system to build projects.

5.2.1

The Compiler Applications
The main internal compiler applications are shown in the illustration below. This shows the tool
chain employed for both PIC32M as well as PIC32C/SAM devices.
All the internal applications are controlled by the command line driver, xc32-gcc, which calls the
internal applications (located in the compiler’s bin directories) when required. An understanding of
the internal operation of the compiler, while not necessary, does assist with using the tool.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 52

XC32 Compiler for PIC32M
Command-line Driver

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 53

XC32 Compiler for PIC32M
Command-line Driver

5.2.2

Single-Step C Compilation
Full compilation of one or more C source files, including the link step, can be performed in just one
command using the xc32-gcc driver.

5.2.2.1 Compiling a Single C File

The following is a simple C program that adds two numbers. To illustrate how to compile and link a
program consisting of a single C source file, copy the code into any text editor and save it as a plain
text file with the name ex1.c.
#include <xc.h>
unsigned int
add(unsigned int a, unsigned int b)
{
return a + b;
}
int
main(void)
{
unsigned int x, y, z;
x = 2;
y = 5;
z = add(x, y);
}

return 0;

In the interests of clarity, this code does not specify device configuration bits, nor has any useful
purpose.
Compile the program by typing the following command at the prompt in your favorite terminal.
For the purpose of this discussion, it is assumed that in your terminal you have changed into
the directory containing the source file you just created, and that the compiler is installed in the
standard directory location and is in your host's search path.
xc32-gcc -mprocessor=32MZ2048ECH100

-o ex1.elf ex1.c

This command compiles the ex1.c source file for a 32MZ2048ECH100 device and has the output
written to ex1.elf, which may be loaded into the MPLAB X IDE.
If a hex file is required, for example, to load into a device programmer, then use the following
command:
xc32-bin2hex ex1.elf

This creates an Intel hex file named ex1.hex.
The driver will compile the source file, regardless of whether it has changed since the last build
command. Development environments (such as MPLAB X IDE) and make utilities must be employed
to achieve incremental builds (see 5.2.3. Multi-Step C Compilation).
Unless otherwise specified, an ELF file (this is by default called a.out) is produced as the final
output.

5.2.2.2 Compiling Multiple C Files

This section demonstrates how to compile and link a project, in a single step, that consists of
multiple C source files.
Copy the example code shown into a text file called add.c.
/* add.c */
#include <xc.h>
unsigned int

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 54

XC32 Compiler for PIC32M
Command-line Driver
add(unsigned int a, unsigned int b)
{
return a + b;
}

And place the following code in another file, ext.c.
/* ex1.c */
#include <xc.h>
unsigned int add(unsigned int a, unsigned int b);
int
main(void) {
unsigned int x, y, z;
x = 2;
y = 5;
z = add(x, y);
}

return 0;

In the interests of clarity, this code does not specify device configuration bits, nor has any useful
purpose.
Compile both files by typing the following at the prompt:
xc32-gcc -mprocessor=32MZ2048ECH100

-o ex1.elf ex1.c add.c

This command compiles the modules ex1.c and add.c in the one step. The compiled modules are
linked with the relevant compiler libraries and the executable file ex1.elf is created.

5.2.3

Multi-Step C Compilation
A multi-step compilation method can be employed to build projects consisting of one or more C
source files. Make utilities can use this feature, taking note of which source files have changed since
the last build to speed up compilation. Incremental builds are also be performed by integrated
development environments, such as the MPLAB X IDE when selecting the Build Project icon or menu
item.
Make utilities typically call the compiler multiple times: once for each source file to generate an
intermediate file and once to perform the second stage compilation, which links the intermediate
files to form the final output. If only one source file has changed since the last build, the
intermediate file corresponding to the unchanged source file need not be regenerated.
For example, the files ex1.c and add.c are to be compiled using a make utility. The command lines
that the make utility could use to compile these files might be something like:
xc32-gcc -mprocessor=32MZ2048ECH100 -c ex1.c
xc32-gcc -mprocessor=32MZ2048ECH100 -c add.c
xc32-gcc -mprocessor=32MZ2048ECH100

-o ex1.elf ex1.o add.o

The -c option used with the first two commands will compile the specified file into the intermediate
file format, but not link. The resultant intermediate files are linked in the final step to create the
final output ex1.elf. All the files that constitute the project must be present when performing the
second stage of compilation.
The above example uses the command-line driver, xc32-gcc, to perform the final link step. You can
explicitly call the linker application, pic32m-ld, but this is not recommended as the commands are
complex and when driving the linker application directly, you must specify linker options, not driver
options, as shown above.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 55

XC32 Compiler for PIC32M
Command-line Driver

For more information on using the linker, see the MPLAB® XC32 Assembler, Linker and Utilities
User’s Guide relevant to your project.
You may also wish to generate intermediate files to construct your own library archive files.
See MPLAB® XC32 Assembler, Linker and Utilities User’s Guide relevant to your project for more
information on library creation.

5.3

The C++ Compilation Sequences
When you compile a project, many internal applications are called by the driver to do the work. This
section introduces these internal applications and describes how they relate to the build process,
especially when a project consists of multiple source files. This information should be of particular
interest if you are using a make system to build projects.

5.3.1

Single-step C++ Compilation
A single command-line instruction can be used to compile one file or multiple files.

5.3.1.1 Compiling a Single C++ File
The following is a simple C++ program. To illustrate how to compile and link a program consisting
of a single C++ source file, copy the code into any text editor and save it as a plain text file with the
name ex2.cpp.
/* ex2.cpp */
#include <xc.h>
#include <iostream>
#include <vector>
#include <deque>
#include <list>
#include <set>
#include <map>
#include <string>
#include <algorithm>
#include <iterator>
#include <functional>
#include <numeric>
using namespace std;
//Device - Specific Configuration - bit settings
#pragma config FPLLMUL=MUL_20, FPLLIDIV=DIV_2, FPLLODIV=DIV_1
#pragma config FWDTEN=OFF
#pragma config POSCMOD=HS, FNOSC=PRIPLL, FPBDIV=DIV_8
template < class T >
inline void
print_elements(const T & coll, const char *optcstr = "") {
typename T::const_iterator pos;
std::cout << optcstr;
for (pos = coll.begin(); pos != coll.end(); ++pos) {
std::cout << *pos << ' ';
}
std::cout << std::endl;
}
template < class T >
inline void
insert_elements(T & coll, int first, int last) {
for (int i = first; i <= last; ++i) {
coll.insert(coll.end(), i);
}
}
int
main(void) {
//Direct stdout to UART 1 for use with the simulator
__XC_UART = 1;
deque<int>coll;
insert_elements(coll, 1, 9);
insert_elements(coll, 1, 9);
print_elements(coll, "on entry: ");
// sortelements
sort(coll.begin(), coll.end());
print_elements(coll, "sorted: ");
//sorted reverse
sort(coll.begin(), coll.end(), greater < int >());

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 56

XC32 Compiler for PIC32M
Command-line Driver

}

print_elements(coll, "sorted >: ");
while (1);

The first line of the program includes the header file xc.h, which provides definitions for all Special
Function Registers (SFRs) on the target device. The second file of the program includes the header
file, which provides the necessary prototypes for the peripheral library.
Compile the program by typing the following command at the prompt in your favorite terminal.
For the purpose of this discussion, it is assumed that in your terminal you have changed into
the directory containing the source file you just created, and that the compiler is installed in the
standard directory location and is in your host's search path.
xc32-g++ -mprocessor=32MX795F512L -Wl,--defsym=_min_heap_size=0xF000 -o ex2.elf ex2.cpp

The option -o ex2.elf names the output executable file. This elf file may be loaded into MPLAB X
IDE.
If a hex file is required, for example, to load into a device programmer, then use the following
command
xc32-bin2hex ex2.elf

This creates an Intel hex file named ex2.hex.

5.3.2

Compiling Multiple C and C++ Files
This section demonstrates how to compile and link multiple C and C++ files in a single step.
File 1
/* main.cpp */
#include <xc.h>
#include <iostream>
using namespace std;
//Device - Specific Configuration - bit settings
#pragma config FPLLMUL=MUL_20, FPLLIDIV=DIV_2, FPLLODIV=DIV_1
#pragma config FWDTEN=OFF
#pragma config POSCMOD=HS, FNOSC=PRIPLL, FPBDIV=DIV_8
// add() must have C linkage
extern "C" {
extern unsigned int add(unsigned int a, unsigned int b);
}
int main(void) {
int myvalue = 6;
//Direct stdout to UART 1 for use with the simulator
__XC_UART = 1;
std::cout << "original value: " << myvalue << endl;
myvalue = add(myvalue, 3);
std::cout << "new value:
while (1);
}

File 2
/* ex3.c */
unsigned int
add(unsigned int a, unsigned int b)
{
return(a+b);
}

Compile both files by typing the following at the prompt:
xc32-g++ -mprocessor=32MX795F512L -o ex3.elf main.cpp ex3.c

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 57

XC32 Compiler for PIC32M
Command-line Driver

The command compiles the modules main.cpp and ex3.c. The compiled modules are linked with
the compiler libraries for C++ and the executable file ex3.elf is created.
Note: Use the xc32-g++ driver (as opposed to the xc32-gcc driver) in order to link the project with
the C++ support libraries necessary for the C++ source file in the project.

5.4

Runtime Files
In addition to the C/C++ and assembly source files and user-defined libraries specified on the
command line, the compiler can also link into your project compiler-generated source files and
pre-compiled library files, whose content falls into the following categories:
•

C/C++ standard library routines

•

Implicitly called arithmetic library routines

•

User-defined library routines

•

The runtime start-up code
®

Note: Some PIC32 target devices allow you to select to boot in either the MIPS32 or microMIPS™
ISA mode via a device configuration bit (BOOTISA). On these devices, if your BOOTISA bit is set to
microMIPS mode, pass the -mmicromips mode to the xc32-gcc/g++ compilation driver to tell it to
link with the microMIPS variant of the runtime start-up code. If your BOOTISA bit is set to MIPS32
mode, pass the -mno-micromips option to the compilation driver so that the MIPS32 variant of the
runtime start-up code is linked.

5.4.1

Location and Naming Convention
By default, the compiler uses the directory <install-directory>/lib/gcc/ to store the specific
libraries and the directory <install-directory>/pic32mx/lib to store the target-specific
libraries, based on the target device family.
The target libraries that are distributed with the compiler are built for the corresponding commandline options:
• Size vs. speed (-Os vs. -O3)
•

MIPS16 vs. MIPS32 vs. microMIPS ISA mode (-mips16 vs. -mno-mips16 vs. -mmicromips)

•

Software floating-point vs no floating-point support (-msoft-float vs. -mno-float)

The following examples provide details on which of the library subdirectories are searched.
If no optimization option has been specified or an optimization of level 2 or lower has been
specified, for example, xc32-gcc -O1 foo.c, then the libraries in the top-level of the library
subdirectories are used.
If -Os level optimizations have been chosen, for example, xc32-g++ -Os foo.cpp, then the
libraries in the size directories of the library subdirectories are used.
If -Os level optimizations and the MIPS16 instruction set option have both been chosen, for
example, xc32-gcc -Os -mips16 foo.c, then the libraries in the size/mips16 directories of
the library subdirectories are searched.

5.4.2

Library Files
The names of the C/C++ standard library files appropriate for the selected target device, and other
driver options, are determined by the driver.
The target libraries, called multilibs, are built multiple times with a permuted set of options. When
the compiler driver is called to compile and link an application, the driver chooses the version of the
target library that has been built with the same options.
By default, the 32-bit language tools use the directory <install-directory>/lib/gcc/ to store
the specific libraries and the directory <install-directory>/pic32mx/lib to store the target-

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 58

XC32 Compiler for PIC32M
Command-line Driver

specific libraries. Both of these directory structures contain subdirectories for each of the multilib
combinations specified above.
The target libraries that are distributed with the compiler are built for the corresponding commandline options:
•

Size vs speed (-Os vs. -O3)

•

MIPS16 vs MIPS32 vs microMIPS ISA mode (-mips16 vs. -mno-mips16 vs -mmicromips)

•

Software floating-point vs no floating-point support (-msoft-float vs -mno-float)

The following examples provide details on which of the multilibs subdirectories are chosen.
xc32-gcc foo.c
xc32-g++ foo.cpp

For this example, no command line options have been specified (that is, the default
command line options are being used). In this case, the .subdirectories are used.

xc32-gcc -Os foo.c
xc32-g++ -Os foo.cpp

For this example, the command line option for optimizing for size has been specified (that is,
-Os is being used). In this case, the ./size subdirectories are used.

xc32-gcc -O2 foo.c
xc32-g++ -O2 foo.cpp

For this example, the command line option for optimizing has been specified; however, this
command line option optimizes for neither size nor space (that is, -O2 is being used). In this
case, the .subdirectories are used.

xc32-gcc -Os -mips16
foo.c
xc32-g++ -Os -mips16
foo.cpp

For this example, the command line options for optimizing for size and for MIPS16 code
have been specified (that is, -Os and -mips16 are being used). In this case, the ./size/
mips16 subdirectories are used.

5.4.2.1 Standard Libraries
The C/C++ standard libraries contain a standardized collection of functions, such as string, math and
input/output routines. The range of these functions are described in 19. Library Routines.
These libraries also contain C/C++ routines that are implicitly called by the output code of the code
generator. These are routines that perform tasks such as floating-point operations and that may not
directly correspond to a C/C++ function call in the source code.

5.4.2.2 User-Defined Libraries
User-defined libraries may be created and linked in with programs as required. Library files are
more easy to manage and may result in faster compilation times, but must be compatible with
the target device and options for a particular project. Several versions of a library may need to be
created to allow it to be used for different projects.
User-created libraries that should be searched when building a project can be listed on the
command line along with the source files.
As with Standard C/C++ library functions, any functions contained in user-defined libraries should
have a declaration added to a header file. It is common practice to create one or more header files
that are packaged with the library file. These header files can then be included into source code
when required.

5.4.3

Peripheral Library Functions
For PIC32MX devices only:
Many of the peripherals of the PIC32 devices are supported by the peripheral library functions
provided with the compiler tools. Please refer to the MPLAB® Harmony Libraries for new
projects. For legacy support, these PLIB Libraries will be available for download from http://
www.microchip.com/pic32_peripheral_lib.
For All PIC32M devices:
MPLAB Harmony includes a set of peripheral libraries, drivers and system services that are
readily accessible for application development. For access to the peripheral header files, go to the

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 59

XC32 Compiler for PIC32M
Command-line Driver

Microchip web site (www.microchip.com), click on the Design Support tab and download MPLAB
Harmony and MPLAB Code Configurator. The path to the peripheral libraries is:
For Windows: C:\microchip\harmony\<version>\framework\peripheral
For Mac/Linux: ~\microchip\harmony\<version>\framework\peripheral

5.4.4

Runtime Startup Code Files
The runtime startup code is contained in multiple modules, to support architectural differences
between device families. Some of the runtime code is built from source code when you build your
program; in other cases, prebuilt modules are linked in to provided the appropriate functionality.
The crt0.o runtime object module is built from source code contained in crt0.S and is used
for both C and C++ programs. A copy of this source file is located in each available device family
pack (DFP) and is built when you use the -mdfp option. If this option is not used, the source file
shipped with the compiler is built. If you need to see a copy of this source file, unzip the pic32mlibs.zip file located at <install-directory>/pic32-libs/. The source code can be found at
pic32m-libs/libpic32/startup/crt0.S. If you build a project and do not specify a processor,
no startup code is linked in with the program. This module contains the code that is executed at the
very beginning of the C runtime startup sequence.
The crti.o and crtn.o modules also perform actions at runtime startup for C++ programs.
They are located in the <install-directory>/pic32mx/lib/ directory. They contain routines
to run before main() (contained in .init sections) and after main() (contained in .fini sections)
respectively. The sections within these modules must be linked in a specific order after sections
defined in the crt0 code. The crtbegin.o and crtend.o modules contain code that handles static
constructors and destructors, and are located in the <install-directory>/lib/gcc/pic32mx/
<gcc-version>/ directory.

5.4.5

Startup and Initialization

®

Note: Some PIC32 target devices allow you to select to boot in either the MIPS32 or microMIPS™
ISA mode via a device configuration bit (BOOTISA). On these devices, if your BOOTISA bit is set to
microMIPS mode, pass the -mmicromips mode to the xc32-gcc/g++ compilation driver to tell it to
link with the microMIPS variant of the runtime start-up code. If your BOOTISA bit is set to MIPS32
mode, pass the -mno-micromips option to the compilation driver so that the MIPS32 variant of the
runtime start-up code is linked.
The runtime startup code performs initialization tasks that must be executed before the main()
function in the C/C++ program is executed. For information on the tasks performed by this code, see
18. Main, Runtime Start-up and Reset.
The compiler will select the appropriate runtime startup code, based on the selected target device
and other compiler options.
•

The startup code initializes the L1 cache when available.

•

It enables the DSPr2 engine when available.

•

It also initializes the Translation Lookaside Buffer (TLB) of the Memory Management Unit (MMU)
for the External Bus Interface (EBI) or Serial Quad Interface (SQI) when available. The devicespecific linker script creates a table of TLB initialization values that the startup code uses to
initialize the TLB at startup.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 60

XC32 Compiler for PIC32M
Command-line Driver

Important: When your target MCU is configured to use the microMIPS
compressed ISA at startup (and for interrupts/exceptions), be sure to pass the
-mmicromips option to xc32-gcc when linking, and use the micromips function
attribute on all of your Interrupt Service Routines (ISRs). Using the -mmicromips
option and the micromips attribute ensures that your startup code and ISR code
are compiled for the microMIPS ISA when the BOOTISA Configuration bit is set
to micromips. Likewise, be sure that you linkwith the MIPS32 startup code, and
your ISRs are not micromips attributed when the BOOTISA bit is set to MIPS32.
For C:
There is only one start-up module, which initializes the C runtime environment.
The source code for this is found in the pic32m-libs.zip file located at:
<install-directory>/pic32-libs/
Once the file is unzipped, the source code can be found at:
pic32m-libs/libpic32/startup/crt0.S.
It is precompiled into the following library location:
<install-directory>/pic32mx/lib/crt0.o.
Multilib versions of these modules exist in order to support architectural differences between device
families.
For C++:
Code from five object files link sequentially to create a single initialization routine, which initializes
the C++ runtime environment.
The PIC32M precompiled startup objects are located in the following location:
<install-directory>/pic32mx/lib/.
The files have the following names: cpprt0.o, crti.o, and crtn.o.
The GCC precompiled startup objects are located in the following location:
<install-directory>/lib/gcc/pic32mx/<gcc-version>/.
The files have the following names: crtbegin.o and crtend.o.
Multilib variations of these modules exist in order to support architectural differences between
device families and also optimization settings.
For more information about what the code in these start-up modules actual does, see
18.2. Runtime Start-Up Code.

5.5

Compiler Output
There are many files created by the compiler during the compilation. A large number of these are
intermediate files and some are deleted after compilation is complete, but many remain and are
used for programming the device, or for debugging purposes.

5.5.1

Output Files
The compilation driver can produce output files with the following extensions, which are casesensitive.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 61

XC32 Compiler for PIC32M
Command-line Driver

Table 5-3. File Names
Extensions

Definition

file.hex

Executable file

file.elf

ELF debug file

file.o

Object file (intermediate file)

file.s

Assembly code file (intermediate file)

file.i

Preprocessed C file (intermediate file)

file.ii

Preprocessed C++ file (intermediate file)

file.map

Map file

The names of many output files use the same base name as the source file from which they were
derived. For example the source file input.c will create an object file called input.o.
The main output file is an ELF file called a.elf, unless you override that name using the -o option.
If you are using an IDE, such as MPLAB X IDE, to specify options to the compiler, there is typically a
project file that is created for each application. The name of this project is used as the base name
for project-wide output files, unless otherwise specified by the user. However check the manual for
the IDE you are using for more details.
Note: Throughout this manual, the term project name will refer to the name of the project created
in the IDE.
The compiler is able to directly produce a number of the output file formats which are used by
Microchip development tools.
The default behavior of xc32-gcc and xc32-g++ is to produce an ELF output. To make changes to
the file’s output or the file names, see 5.7. Driver Option Descriptions.

5.5.2

Diagnostic Files
Two valuable files produced by the compiler are the assembly list file, produced by the assembler,
and the map file, produced by the linker.
The assembly list file contains the mapping between the original source code and the generated
assembly code. It is useful for information such as how C source was encoded, or how assembly
source may have been optimized. It is essential when confirming if compiler-produced code that
accesses objects is atomic, and shows the region in which all objects and code are placed.
The option to create a listing file in the assembler is -a (or -Wa,-a if passed to the driver). There
®
are many variants to this option, which may be found in the “MPLAB XC32 Assembler, Linker and
Utilities User’s Guide” (DS50002186). To pass the option from the compiler, see 5.7.9. Options for
Assembling.
There is one list file produced for each build. There is one assembler listing file for each translation
unit. This is a pre-link assembler listing so it will not show final addresses. Thus, if you require a list
file for each source file, these files must be compiled separately, see 5.2.3. Multi-Step C Compilation.
This is the case if you build using MPLAB IDE. Each list file will be assigned the module name and
extension .lst.
The map file shows information relating to where objects were positioned in memory. It is useful for
confirming that user-defined linker options were correctly processed, and for determining the exact
placement of objects and functions.
The option to create a map file in the linker is -Map file (or -Wl,-Map=file, if passed to the
®
driver), which can be found in the “MPLAB XC32 Assembler, Linker and Utilities User’s Guide”
(DS50002186). To pass the option from the compiler, see 5.7.10. Options for Linking.
There is one map file produced when you build a project, assuming the linker was executed and ran
to completion.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 62

XC32 Compiler for PIC32M
Command-line Driver

5.6

Compiler Messages
All compiler applications use textual messages to report feedback during the compilation process.
There are several types of messages, described below. The behavior of the compiler when
encountering a message of each type is also listed.
Warning Messages

Indicates source code or other situations that can be compiled, but is unusual and
might lead to runtime failures of the code. The code or situation that triggered the
warning should be investigated; however, compilation of the current module will
continue, as will compilation of any remaining modules.

Error Messages

Indicates source code that is illegal or that compilation of code cannot take place.
Compilation will be attempted for the remaining source code in the current module
(however the cause of the initial error might trigger further errors) and compilation of
the other modules in the project will take place, but the project will not be linked.

Fatal Messages

Indicates a situation in which compilation cannot proceed and which forces the
compilation process to stop immediately.

For information on options that control compiler output of errors, warnings or comments, see
5.7.4. Options for Controlling the C++ Dialect.

5.7

Driver Option Descriptions
Most aspects of the compilation process can be controlled using options passed to the commandline driver, xc32-gcc.
The GCC compiler on which the MPLAB XC32 C Compiler is based provides many options in addition
to those discussed in this document. It is recommended that you avoid any option that has not been
documented here, especially those that control the generation or optimization of code.
All single letter options are identified by a leading dash character, “-”, for example, -c. Some
single letter options specify an additional data field which follows the option name immediately
and without any whitespace, for example, -Idir. Options are case sensitive, so -c is a different
option to -C. All options are identified by single or double leading dash character, for example, -c or
--version.
Use the --help option to obtain a brief description of accepted options on the command line.
If you are compiling from within the MPLAB X IDE, it will issue explicit options to the compiler that
are based on the selections in the project's Project Properties dialog. The default project options
might be different to the default options used by the compiler when running on the command line,
so you should review these to ensue that they are acceptable.

5.7.1

Options Specific to PIC32M Devices
The options shown in the table below are useful when compiling for Microchip PIC32M devices with
the MPLAB XC32 compiler and are discussed in the sections that follow.
Table 5-4. PIC32M Device-Specific Options
Option

Definition

-G num

Specify the size threshold for placing permanent storage duration objects into the
small data sections.

-mappio-debug

Enable the APPIN/APPOUT debugging library functions for the Microchip debugger
and in-circuit emulator.

-mcci

Enable the Microchip Common C Interface compilation mode.

-m[no-]check-zero-division

Specifies whether to trap on integer division by zero.

-mcodecov=options

Instrument the output to provide code coverage information.

-mdfp=path

Specifies which device family pack to use.

-dspr2

Specifies use of revision 2 of the MIPS DSP ASE.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 63

XC32 Compiler for PIC32M
Command-line Driver

...........continued
Option

Definition

-m[no-]embedded-data

Specifies where objects are allocated.

-mframe-header-opt

Allows the compiler to omit a few instructions for functions not using their incoming
frame header.

-mgen-pie-static

Generate position-independent code suitable for statically linking into a positionindependent executable.

-m[no-]interlink-compressed

Generate code that is link compatible with MIPS16 and microMIPS code.

-m[no-]jals

Enable generation of microMIPS jals instructions, which have a shorter, 16-bit delay
slot.

-m[no-]long-calls

Disable use of the jal instruction.

-m[no-]memcpy

Force the use of the memcpy()function for non-trivial block moves.

-m[no-]micromips

Generate microMIPS code.

-[mno-]mips16

Generate MIPS16 code.

-mno-float

Do not use libraries with software floating-point.

-mno-hi-addr-opt

Disables certain optimizations associated with the access of special function registers.

-mperipheral-libs

Specifies which peripheral libraries are linked to the project.

-mprocessor

Selects the target device for which to compile.

-mreserve

Specifies the address ranges of memory to be reserved.

-msmart-io=[0|1|2]

Controls the feature set of the IO library linked in.

-mchp-stack-usage

Generation of stack usage information and warnings.

-mtext="scn-name"

Redirects the .text section into a section with a user-defined name.

-m[no-]uninit-const-in-rodata Place uninitialized const-qualified objects in the read-only data section.
Only the selected optimization level and with no license-imposed fall back to a lesser
level.

--nofallback

5.7.1.1 G: Specify Small Data Size Threshold Option

The -G num option specifies the size (in bytes) of the largest objects with permanent storage
duration that will be will be placed into the small data or bss sections instead of the normal data or
bss sections. Having objects in the small data/bss sections allows them to be accessed using a single
instruction.
All modules should be compiled with the same num value.

5.7.1.2 Appio-debug Option

The -mappio-debug option enables the APPIN/APPOUT debugging library functions for the
Microchip debugger and in-circuit emulator. This feature allows you to use the DBPRINTF()
and related functions and macros as described in the 32-bit Language Tool Libraries document
(DS51685).

Enable this option only when using a target PIC32 device that supports the APPIN/APPOUT feature.

5.7.1.3 Cci Option

The -mcci option enables the Microchip Common C Interface (CCI) compilation mode.
Enabling this mode requests the compiler to check all source code and compiler options for
compliance with the CCI. Code that complies with this interface can be more easily ported across all
MPLAB XC compilers. Code or options that do not conform to the CCI will be flagged by compiler
warnings.

5.7.1.4 Check-zero-division Option

The -mcheck-zero-division option requests the compiler to trap integer divisions by zero. This
is the default action if no option is specified. The -mno-check-zero-division form of this option
requests that no traps will take place.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 64

XC32 Compiler for PIC32M
Command-line Driver

5.7.1.5 Codecov Option

The -mcodecov=suboptions option embeds diagnostic code into the program’s output, allowing
analysis of the extent to which the program’s source code has been executed. See 8. Code Coverage
for more information.
A suboption must be specified and at this time, the only available suboption is ram.

5.7.1.6 Dfp Option

The -mdfp=path option indicates that device-support for the target device (indicated by the
-mprocessor option) should be obtained from the contents of a Device Family Pack (DFP), where
path is the path to the XC32 sub-directory of the DFP.
When this option has not been used, the xc32-gcc driver will where possible use the device-specific
files provided in the compiler distribution.

The Microchip development environments automatically uses this option to inform the compiler of
which device-specific information to use. Use this option on the command line if additional DFPs
have been obtained for the compiler.
A DFP might contain such items as device-specific header files, configuration bit data and libraries,
letting you take advantage of features on new devices without you having to otherwise update the
compiler. DFPs never contain executables or provide bug fixes or improvements to any existing
tools or standard library functions.

5.7.1.7 Dspr2 Option

The -mdspr2 option informs the compiler to revision 2 of the MIPS DSP Application Specific
Extensions, which provided instructions designed to improve the performance of DSP and media
applications. When the option is in effect, the preprocessor macros _mips_dsp and mips_dspr2
are defined, and the _mips_dsp_rev macro is defined to be 2. This is the default action if no option
is specified.
The -mno-dspr2 form of this option disables use of this extension.

5.7.1.8 Embedded-data Option

The -membedded-data option allocates const objects to the read-only data section (.rodata) first
if possible, then next in the small data section (.sdata) if possible, otherwise in the data section
(.data). This gives slightly slower code than the default, but reduces the amount of RAM required
when executing, and thus may be preferred for some embedded systems. This option does not
affect the placement of string literals. This is the default action if no option is specified.
The -mno-embedded-data form of this option will not allocate const objects to the read-only data
section.

5.7.1.9 Frame-header-opt Option

The -mframe-header-opt option allows the compiler to omit a few instructions for each function
that does not use its incoming frame header. This feature usually improves both execution speed
and code size.

5.7.1.10 Gen-pie-static Option

The -mgen-pie-static option generates position-independent code suitable for statically linking
into a Position-Independent Executable (PIE). Such code accesses all constant addresses through
a Global Offset Table (GOT). A special ELF loader, running on the target device, resolves the GOT
entries and loads the final executable image into memory.
Pass this option to the xc32-gcc compilation driver when compiling, assembling, and linking.

5.7.1.11 Hard-float Option

The -mhard-float option indicates to the compiler that floating-point calculations in generated
code should be performed by the hardware floating-point unit (FPU). A varient of the library that
utilises hardware floating-point instructions is also selected for link time.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 65

XC32 Compiler for PIC32M
Command-line Driver

This option does not typically need to be specified, as the compiler will use an appropriate library
and generate suitable floating-point code based on information provided by the Device Family Pack
associated with the selected device.

5.7.1.12 Interlink-compressed Option
The -minterlink-compressed option ensures that standard (uncompressed) MIPS ISA being
generated is link compatible with MIPS16 and microMIPS code. The -mno-interlink-compressed
form of this option does not ensure this compatibility, and the generated code cannot be used with
MIPS16 or microMIPS code.

5.7.1.13 Jals Option
The -mjals option enables the generation of microMIPS jals instructions, which have a shorter,
16-bit delay slot. The jal MIPS32 instruction requires a 32-bit instruction to fill its delay slot.
The -mno-jals option disables the generation of jals instructions. You might need to use this
option if you have link errors when attempting to link a microMIPS object/library with a MIPS32
object/library.

5.7.1.14 Libc-variant Option
The -mlibc-variant=variant option specified whether speed- or size-orientated string functions
are linked in with the program. Size-orientated functions are linked in if this option is not used.
Many of the library functions provided by <string.h> are available in two variants. The sizeorientated functions require less code to implement. These can be explicitly selected by using a
size argument to the option, for example -mlibc-variant=size. The speed-orientated functions
might be larger, but they execute quickly, resulting in improved program performance. They can be
selected by using a speed argument to the option.
All architectures implement the size-orientated function variants. Speed-orientated of the following
functions are available across all device architectures: memcmp(), memcpy(), memset(), strcmp(),
strcpy(), and strlen(). For cases where only the size-orientated variant is available, it will always
be selected regardless of the variant specified by this option.

5.7.1.15 Long-calls Option
The -mlong-calls option disables the use of the jal instruction. Calling functions using this
instruction is more efficient but requires the caller and callee functions to be in the same 256
megabyte segment. This option has no effect on abicalls code.
The -mno-long-calls form of this option allows the use of jal instructions. This is the default
action if no option is specified.

5.7.1.16 Malloc-variant Option
The -mmalloc-variant=scheme option indicates to the compiler the scheme of dynamic memory
allocation that should be employed for the program. See 10.7. Dynamic Memory Allocation for
more information on this type of memory allocation and the heap, from which allocation takes
place.
The -mmalloc-variant=lite form of this option selects a simple scheme that will yield the
smallest code size. It might, however, result in a fragmented heap when freeing allocated memory,
preventing further memory from being allocated at runtime. This is the default scheme if no option
is specified.
The -mmalloc-variant=binned option uses a more sophisticated allocation scheme that will
result in less fragmentation, but at the expense of increased code size.

5.7.1.17 Memcpy Option
The -mmemcpy option forces the compiler to use the memcpy() function for non-trivial block copies.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 66

XC32 Compiler for PIC32M
Command-line Driver

The -mno-memcpy form of this option allows the compiler to inline most constant-sized block
copies. This is the default action if no option is specified.

5.7.1.18 Micromips Option

The -mmicromips option informs the compiler to generate code using the microMIPS™ instructions.
This feature is available only in the PRO edition.
When your device is configured to boot into the microMIPS compressed Instruction Set
Architecture (ISA) mode (for example, if #pragma config BOOTISA=MICROMIPS was specified),
the -mmicromips option should be used when linking to select microMIPS startup code.
The -mno-micromips form of this option informs the compiler to use MIPS32 instructions.
The ISA can also be indicated on a per-function basis through the micromips and nomicromips
attributes.
On PIC32M devices, bit 0 of the program counter indicates the ISA mode. When this bit is clear, the
device is running in MIPS32 mode. When this bit is set, the device is running in either MIPS16 or
microMIPS mode, depending on the core of the selected device. This means that if you execute
a hard-coded jump, bit 0 must be set to the appropriate value for the destination function.
Hard-coded jumps are most commonly seen when jumping from a bootloader to a bootloaded
application.

5.7.1.19 Mips16/Mips16e Options

The -mips16 option generates MIPS16 code, suitable for MIPS16 or microMIPS Instruction Set
Architecture (ISA) mode. The -mips16e option is equivalent and is provided for backwards
compatibility with older toolchains. These options are only available in the PRO edition.
The -mno-mips16 option (note the slightly different 'no' form of this option, which includes an
additional 'm' character) will have all code built using the MIPS32 ISA.
On PIC32M devices, bit 0 of the program counter indicates the ISA mode. When this bit is clear, the
device is running in MIPS32 mode. When this bit is set, the device is running in either MIPS16 or
microMIPS mode, depending on the core of the selected device. This means that if you execute
a hard-coded jump, bit 0 must be set to the appropriate value for the destination function.
Hard-coded jumps are most commonly seen when jumping from a bootloader to a bootloaded
application.

5.7.1.20 No-float Option

The -mno-float option instructs the compiler to not link in libraries that contain software floatingpoint code.

5.7.1.21 No-hi-addr-opt Option

The -mno-hi-addr-opt option disables certain optimizations associated with the access of special
function registers (SFRs).

The employs a SFR Access Efficiency feature, which adds the address attribute to peripheral SFRs
defined in the processor header file. Compiler optimizations use this information to reduce the
number of registers required to access multiple SFRs from within a single function and to remove
redundant load instructions. This feature is enabled by default at optimization levels -O2, -Os, and
-O3.
If you are building a static library that accesses an SFR and you want that same prebuilt library
to work across devices that may have the SFRs located at a different address (for example, the
TMR1 SFR object is located at different addresses on different devices), compile your library with the
-mno-hi-addr-opt option. This will result in larger code, but the SFR address will be determined at
link time.

5.7.1.22 Peripheral-libs Option

The -mperipheral-libs requests that the standard peripheral libraries are linked in.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 67

XC32 Compiler for PIC32M
Command-line Driver

The -mno-peripheral-libs form of this option requests that the linked peripheral libraries are
specified via the device-specific linker script. This is the default action if no option is specified.

5.7.1.23 Processor Option

The -mprocessor=device option selects the target device for which to compile. A list of all
supported devices can be found the compiler release notes. Note that the name must be in upper
case, for example, -mprocessor=32MZ2048ECH100.

5.7.1.24 Reserve Option

The -mreserve=ranges option allows you to reserve memory normally used by the program. This
option has the general form:
-mreserve=space@start:end

where space dictates the regions in which reservation will take place; and start
and end are addresses, denoting the memory range to be excluded. For example,
-mreserve=data@0x80000200:0x800002FF will reserve memory in both kseg0_data_mem and
kseg1_data_mem regions.

5.7.1.25 Smart-io Option

The -msmart-io=level option in conjunction with the IO format string conversion specifications
detected in your program control the feature set (hence size) of the library code that is linked in
to perform formatted IO through functions like printf. See 19.1. Smart IO Routines for more
information on how the smart IO feature operates.
A numerical level of operation can be specified and these have the meaning shown in the following
table.
Table 5-5. Smart IO Implementation Levels
Level

Smart IO features; linked library

0

Disabled; Full-featured library (largest code size)

1

Enabled; Minimal-featured library (smallest code size)

2

Manual control; Integer-only library

When the smart IO feature is disabled (-msmart-io=0), a full implementation of the IO functions
will be linked into your program. All features of the IO library functions will be available, and these
may consume a significant amount of the available program and data memory on the target device.
The default setting is for smart IO to be enabled with a minimal feature set. This can be made
explicit by using either the -msmart-io=1 or -msmart-io option. When thus enabled, the compiler
will link in the least complex variant of the IO library that implements all of the IO functionality
required by the program, based on the conversion specifications detected in the program's IO
function format strings. This can substantially reduce the memory requirements of your program,
especially if you can eliminate in your program the use of floating-point features.
If the format string in a call to an IO function is not a string literal, the compiler will not be able to
detect the exact usage of the IO function and a full-featured variant of the IO library will be linked
into the program image, even with smart IO enabled.
These options should be used consistently across all program modules to ensure an optimal
selection of the library routines included in the program image.

5.7.1.26 Soft-float Option

The -msoft-float option indicates to the compiler that floating-point calculations in generated
code should be emulated rather than performed by the hardware floating-point unit (FPU). A variant
of the library that does not use hardware floating-point is also selected for link time.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 68

XC32 Compiler for PIC32M
Command-line Driver

This option does not typically need to be specified, as the compiler will use an appropriate library
and generate suitable floating-point code based on information provided by the Device Family Pack
associated with the selected device.

5.7.1.27 Stack Guidance Option
The -mchp-stack-usage option analyzes the program and reports on the estimated maximum
depth of any stack used by a program. The option can only be enabled with a PRO license.
See 15.3. Stack Guidance for more information on the stack guidance reports that are produced by
the compiler.

5.7.1.28 Text Option
The -mtext="scn-name[attributes]" option places text (program code) in a section named
scn-name, rather than the default .text section. Additionally, comma-separated attributes can be
specified along with the section name. No white space should appear around the = character in this
option.
For example, the following command line option redirects the .text section into a section called
MySectionName and specifies its link address.
xc32-gcc bootloader.c -mprocessor=32MX795F512L -mtext="MySectionName,address(0x9D00a000)"

This command is useful when used to map your code in a custom linker script as part of a
bootloader project.

5.7.1.29 Uninit-const-in-rodata Option
The -muninit-const-in-rodata option places uninitialized const-qualified objects in the readonly data section. This option is only meaningful in conjunction with the -membedded-data option.
The -mno-uninit-const-in-rodata form of this option places uninitialized const-qualified
objects in a text section. This is the default action if no option is specified.

5.7.1.30 Nofallback Option
The --nofallback option can be used to ensure that the compiler is not inadvertently executed
with optimizations below the that specified by the -O option.
For example, if an unlicensed compiler was requested to run with level s optimizations, without this
option, it would normally revert to a lower optimization level and proceed. With this option, the
compiler will instead issue an error and compilation will terminate. Thus, this option can ensure that
builds are performed with a properly licensed compiler.

5.7.2

Options for Controlling the Kind of Output
The options tabulated below control the kind of output produced by the compiler and are discussed
in the sections that follow.
Table 5-6. Kind-of-Output Control Options
Option

Definition

-c

Stop compilation before the link step, producing an intermediate file.

-E

Stop compilation after preprocessing, producing a preprocessed file.

--help

Print a description of the command line options.

-o file

Place the output in a file with the specified name.

-S

Stop compilation before the assembly step, producing an assembly file output.

-specs=file

Overrides the standard specs file.

-v

Print the commands executed during each stage of compilation.

--version

Show version information then quit.

-x

Specify the language of a source file regardless of its file extension.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 69

XC32 Compiler for PIC32M
Command-line Driver

5.7.2.1 C: Compile To Intermediate File

The -c option is used to generate an intermediate file for each source file listed on the command
line.
For all source files, compilation will terminate after executing the assembler, leaving behind
relocatable object files with a .o extension.
This option is often used to facilitate multi-step builds using a make utility.

5.7.2.2 E: Preprocess Only

The -E option is used to generate preprocessed C/C++ source files (also called modules or
translation units).
The preprocessed output is printed to stdout, but you can use the -o option to redirect this to a
file.
You might check the preprocessed source files to ensure that preprocessor macros have expanded
to what you think they should. The option can also be used to create C/C++ source files that do
not require any separate header files. This is useful when sending files to a colleague or to obtain
technical support without sending all the header files, which can reside in many directories.

5.7.2.3 Help

The --help option displays information on the xc32-gcc compiler options, then the driver will
terminate.
For example:
xc32-gcc --help
Microchip Language Tool Shell Version 4.20 (Build date: Sep 16 2022).
Copyright (c) 2012-2017 Microchip Technology Inc. All rights reserved
-omf=elf
Select elf object module format
Usage: pic32m-gcc [options] file...
Options:
-pass-exit-codes
Exit with highest error code from a phase.
--help
Display this information.
--target-help
Display target specific command line options.
--help={common|optimizers|params|target|warnings|[^]{joined|separate|undocumented}}[,...].
Display specific types of command line options.
(Use '-v --help' to display command line options of sub-processes).
--version
Display compiler version information.
-dumpspecs
Display all of the built in spec strings.
-dumpversion
Display the version of the compiler.
-dumpmachine
Display the compiler's target processor.
-print-search-dirs
Display the directories in the compiler's search path.
-print-libgcc-file-name Display the name of the compiler's companion library.

5.7.2.4 O: Specify Output File

The -o option specifies the base name and directory of the output file.
The option -o main.elf, for example, will place the generated output in a file called main.elf.
The name of an existing directory can be specified with the file name, for example -o build/
main.elf, so that the output file will appear in that directory.
You cannot use this option to change the type (format) of the output file.

5.7.2.5 S: Compile To Assembly

The -S option is used to generate an assembly file for each source file listed on the command line.

When this option is used, the compilation sequence will terminate early, leaving behind assembly
files with the same basename as the corresponding source file and with a .s extension.
For example, the command:
xc32-gcc -mprocessor=32MZ2048ECH100 -S test.c io.c

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 70

XC32 Compiler for PIC32M
Command-line Driver

will produce two assembly file called test.s and io.s, which contain the assembly code generated
from their corresponding source files.
This option might be useful for checking assembly code output by the compiler without the
distraction of line number and opcode information that will be present in an assembly list file.
The assembly files can also be used as the basis for your own assembly coding.

5.7.2.6 Specs Option
The -specs=file option allows the standard specs file to be overridden.
Spec files are plain-text files used to construct spec strings, which in turn control which programs
the compiler should invoke and which command-line options they need to be passed. The compiler
has a standard specs file which defines the options with which the compiler's internal applications
will execute.
After the compiler reads in the standard specs file, it processes file specified with this option in
order to override the defaults that the xc32-gcc driver program uses when building the commandline options to pass to xc32-as, xc32-ld, etc. More than one -specs option can be specified on
the command line, and they are processed in order, from left to right.

5.7.2.7 V: Verbose Compilation
The -v option specifies verbose compilation.
When this option is used, the name and path of the internal compiler applications will be displayed
as they are executed, followed by the command-line arguments that each application was passed.
You might use this option to confirm that your driver options have been processed as you expect, or
to see which internal application is issuing a warning or error.

5.7.2.8 Version Option
The --version option has the compiler display the version number of the MPLAB XC32 Toolchain
and the GNU copyright information. The compiler will then quit, without building any of the program
source code.

5.7.2.9 X: Specify Source Language Option
The -x language option specifies the language for the sources files that follow on the command
line.
The compiler usually uses the extension of an input file to determine the file’s content. This option
allows you to have the language of a file explicitly stated. The option remains in force until another
language is specified with a -x option, or the -x none option, which turns off the language
specification entirely for subsequent files. The allowable languages are tabulated below.
Table 5-7. Source file Language
Language

File language

assembler

Assembly source

assembler-with-cpp

Assembly with C preprocessor directives

c

C source

c++

C++ source

cpp-output

Preprocessed C source

c-header

C header file

none

Based entirely on the file’s extension

The -x assembler-with-cpp language option ensures assembly source files are preprocessed
before they are assembled, thus allowing the use of preprocessor directives, such as #include, and
C-style comments with assembly code. By default, assembly files not using a .S extension are not
preprocessed.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 71

XC32 Compiler for PIC32M
Command-line Driver

You can create precompiled header files with this option, for example:
xc32-gcc -mprocessor=32MZ2048ECH100 -x c-header init.h

will create the precompiled header called init.h.gch.

5.7.3

Options for Controlling the C Dialect
The options tabulated below define the type of C dialect used by the compiler and are discussed in
the sections that follow.
Table 5-8. C Dialect Control Options
Option

Definition

-ansi

Support all (and only) ANSI-standard C programs.

-aux-info filename

Generates function prototypes from a C module, placing the output in a file with the
specified name.

-f[no-]freestanding

Asserts that the project will be built for a freestanding (as opposed to a hosted)
environment.

-f[no-]asm

Restricts the recognition of certain keywords, freeing them to be used as identifiers.

-fno-builtin
-fno-builtin-function

Don’t recognize built-in functions that do not begin with __builtin_ as prefix.

-std=standard

Specifies the language standard with which to build programs

-f[no-]unsigned-char
-f[no-]signed-char

Changes the signedness of a plain char type.

-f[no-]signed-bitfields
Changes the signedness of a plain int bit-field. By default, such a bit field is signed.
-f[no-]unsigned-bitfields

5.7.3.1 Ansi Option

The -ansi option ensures the C program strictly conforms to the C90 standard.

When specified, this option disables certain GCC language extensions when compiling C source.
Such extension include C++ style comments, and keywords, such as asm and inline. The macro
__STRICT_ANSI__ is defined when this option is in use. See also -Wpedantic for information on
ensuring strict ISO compliance.

5.7.3.2 Aux-info Option

The -aux-info option generates function prototypes from a C module.
The -aux-info main.pro option, for example, prints to main.pro prototyped declarations for all
functions declared and/or defined in the module being compiled, including those in header files.
Only one source file can be specified on the command line when using this option so that the output
file is not overwritten. This option is silently ignored in any language other than C.
The output file also indicates, using comments, the source file and line number of each declaration,
whether the declaration was implicit, prototyped or unprototyped. This is done by using the codes I
or N for new-style and O for old-style (in the first character after the line number and the colon) and
whether it came from a declaration or a definition using the codes C or F (in the following character).
In the case of function definitions, a K&R-style list of arguments followed by their declarations is also
provided inside comments after the declaration.
For example, compiling with the command:
xc32-gcc -mprocessor=32MZ2048ECH100 -aux-info test.pro test.c

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 72

XC32 Compiler for PIC32M
Command-line Driver

might produce test.pro containing the following declarations, which can then be edited as
necessary:
/* test.c:2:NC */ extern int add (int, int);
/* test.c:7:NF */ extern int rv (int a); /* (a) int a; */
/* test.c:20:NF */ extern int main (void); /* () */

5.7.3.3 Freestanding Option

The -ffreestanding option asserts that the project will be built for a freestanding (as opposed to
a hosted) environment.
A freestanding environment is one in which the standard library may not be fully implemented, and
program start-up and termination are implementation defined.
This option is identical to the -fno-hosted option and implies the -fno-builtin option.
The -fno-freestanding option is identical to the -fhosted option and indicates that the project
will be built for a hosted environment.

5.7.3.4 Asm Option

The -fasm option reserves the use of asm, inline and typeof as keywords, preventing them from
being defined as identifiers. This is the default action if no option is specified.

The -fno-asm form of this option restricts the recognition of these keywords. You can, instead, use
the keywords __asm__, __inline__ and __typeof__, which have identical meanings.
The -ansi option implies -fno-asm.

5.7.3.5 No-builtin Option

The -fbuiltin option has the compiler produce specialized code that avoids a function call for
many built-in functions. The resulting code is often smaller and faster, but since calls to these
functions no longer appear in the output, you cannot set a breakpoint on those calls, nor can you
change the behavior of the functions by linking with a different library. This is the default behavior if
no option is specified.
The -fno-builtin option will prevent the compiler from producing special code for built-in
functions that are not prefixed with __builtin_.

The -fno-builtin-function form of this option allows you to prevent a built-in version of the
named function from being used. In this case, function must not begin with __builtin_. There is
no -fbuiltin-function form of this option.

5.7.3.6 Signed-bitfields Option

The -fsigned-bitfields option control the signedness of a plain int bit-field type.
By default, the plain int type, when used as the type of a bit-field, is equivalent to signed int.
This option specifies the type that will be used by the compiler for plain int bit-fields. Using
-fsigned-bitfields or the -fno-unsigned-bitfields option forces a plain int bit-field to be
signed.
Consider explicitly stating the signedness of bit-fields when they are defined, rather than relying on
the type assigned to a plain int bit-field type.

5.7.3.7 Signed-char Option

The -fsigned-char option forces plain char objects to have a signed type.

By default, the plain char type is equivalent to signed char, unless the -mext=cci option has
been used, in which case it is equivalent to unsigned char. The -funsigned-char (or -fnosigned-char option) makes this type explicit.
The -fsigned-char (or -fno-unsigned-char option) makes it explicit that plain char types are
to be treated as signed integers.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 73

XC32 Compiler for PIC32M
Command-line Driver

Consider explicitly stating the signedness of char objects when they are defined, rather than relying
on the type assigned to a plain char type by the compiler.

5.7.3.8 Std Option

The -std=standard option specifies the C standard to which the compiler assumes source code
will conform. The allowable standards are tabulated below.
Table 5-9. Acceptable Language Standards
Standard

Supports

c89 or c90

ISO C90 (ANSI) programs.

c99

ISO C99 programs.

gnu99

GNU dialect of ISO C99 programs

c++11

ISO C++11 programs

gnu++11

GNU dialect of ISO C++11 programs

c++14

ISO C++14 programs

gnu++14

GNU dialect of ISO C++14 programs

5.7.3.9 Unsigned-bitfields Option

The -funsigned-bitfields option control the signedness of a plain int bit-field type.
By default, the plain int type, when used as the type of a bit-field, is equivalent to signed int.
This option specifies the type that will be used by the compiler for plain int bit-fields. Using
the -funsigned-bitfields or the -fno-signed-bitfields option forces a plain int to be
unsigned.
Consider explicitly stating the signedness of bit-fields when they are defined, rather than relying on
the type assigned to a plain int bit-field type.

5.7.3.10 Unsigned-char Option

The -funsigned-char option forces a plain char objects to have an unsigned type.

By default, the plain char type is equivalent to signed char, unless the -mext=cci option has
been used, in which case it is equivalent to unsigned char. The -funsigned-char (or -fnosigned-char option) makes this type explicit.
Consider explicitly stating the signedness of char objects when they are defined, rather than relying
on the type assigned to a plain char type by the compiler.

5.7.4

Options for Controlling the C++ Dialect
The options tabulated below define the type of C++ dialect used by the compiler and are discussed
in the sections that follow. Note that the sections for those options also relevant for the C dialect are
located in the 5.7.3. Options for Controlling the C Dialect section.
Table 5-10. C++ Dialect Control Options
Option

Definition

-ansi

Support all (and only) C90 programs.

-aux-info filename

Generates function prototypes from a C module, placing the output in a file with the
specified name.

-f[no-]check-new

Check that the pointer returned by the new operator is non-null.

-f[no-]enforce-eh-specs

Specify generation of code to check for violation of exception specifications at runtime.

-f[no-]freestanding

Asserts that the project will be built for a freestanding (as opposed to a hosted)
environment.

-f[no-]asm

Restricts the recognition of certain keywords, freeing them to be used as identifiers.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 74

XC32 Compiler for PIC32M
Command-line Driver

...........continued
Option

Definition

-fno-builtin
-fno-builtin-function

Don’t recognize built-in functions that do not begin with __builtin_ as prefix.

-f[no-]rtti

Specifies if code for Run Time Type Identification features should be generated.

-std=standard

Specifies the language standard with which to build programs

-f[no-]unsigned-char
-f[no-]signed-char

Changes the signedness of a plain char type.

-f[no-]signed-bitfields
Changes the signedness of a plain int bit-field.
-f[no-]unsigned-bitfields

5.7.4.1 Check-new Option

The -fcheck-new option checks that the pointer returned by operator new is not NULL before
attempting to modify the storage allocated.
Typically, this check is not necessary. You can ensure that no checks are made by using the -fnocheck-new form of this option. This is the default action if no option is specified.

5.7.4.2 Enforce-eh-specs Option

The -fenforce-eh-specs option generates code to check for violation of exception specifications
at runtime. This is the default action if no option is specified.
The -fno-enforce-eh-specs form of this option omits generation of verification code, which
violates the C++ standard, but doing so might reduce the code size in production builds of validated
source. Even when specifying this option, the compiler will still optimize exception code based on
the specifications, so throwing an unexpected exception will result in undefined behavior.

5.7.4.3 Rtti Option

The -frtti option enables generation of information about every class with virtual functions for
use by the C++ Run Time Type Identification (RTTI) features, such as dynamic_cast and typeid
operators.
The -fno-rtti form of this option disables generation of this information. If you don't use
the RTTI features of the language, code size might be reduced by using this option. Note that
exception handling uses the same information, but it will generate this information as needed. The
dynamic_cast operator can still be used for casts that do not require RTTI, that is, casts to void *
or to unambiguous base classes.
Ensure that the same form of this option is specified at compile time for all modules and at link
time.

5.7.5

Options for Controlling Warning and Errors
Warnings are diagnostic messages that report constructions that are not inherently erroneous, but
that are risky or suggest there may have been an error.
You can request many specific warnings with options beginning -W; for example, -Wimplicit, to
request warnings on implicit declarations. Each of these specific warning options also has a negative
form beginning -Wno- to turn off warnings; for example, -Wno-implicit. This manual lists only
one of the two forms, whichever is not the default.
The options shown in the tables below are the more commonly used warning options that control
messages issued by the compile. In the (linked) sections that follow, the options that affect warnings
generally are discussed.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 75

XC32 Compiler for PIC32M
Command-line Driver

Table 5-11. Warning and Error Options Implied by All Warnings
Option

Definition

-fsyntax-only

Check the code for syntax, but don’t do anything beyond that.

-pedantic

Issue all the warnings demanded by strict ANSI C. Reject all programs that use forbidden
extensions.

-pedantic-errors

Like -pedantic, except that errors are produced rather than warnings.

-w

Inhibit all warning messages.

-Wall

Enable all warnings about constructions that some users consider questionable, and that are
easy to avoid, even in conjunction with macros.

-Waddress

Warn about suspicious uses of memory addresses. These include using the address of a function
in a conditional expression, such as void func(void); if (func), and comparisons against
the memory address of a string literal, such as if (x == "abc"). Such uses typically indicate
a programmer error: the address of a function always evaluates to true, so their use in a
conditional usually indicates that the programmer forgot the parentheses in a function call; and
comparisons against string literals result in unspecified behavior and are not portable in C, so
they usually indicate that the programmer intended to use strcmp.

-Warray-bounds

When combined with -02 or greater, warns for many instances out-of-bounds array indices and
pointer offsets. This feature cannot detect all cases. Enabled with -Wall command.

-Wchar-subscripts

Warn if an array subscript has type char.

-Wcomment

Warn whenever a comment-start sequence /* appears in a /*comment, or whenever a
Backslash-Newline appears in a // comment.

-Wdiv-by-zero

Warn about compile-time integer division by zero. To inhibit the warning messages, use -Wnodiv-by-zero. Floating-point division by zero is not warned about, as it can be a -legitimate way
of obtaining infinities and NaNs.
This is the default.

-Wformat

Check calls to printf and scanf, etc., to make sure that the arguments supplied have types
appropriate to the format string specified.

-Wformat-smartio=level

A level of 1 disables warnings thrown by Smart IO to indicate anomalies in IO function format
strings. A level of 0 enables these warnings.

-Wimplicit

Equivalent to specifying both -Wimplicit-int and -Wimplicit-function-declaration.

-Wimplicit-function- Give a warning whenever a function is used before being declared.
declaration
-Wimplicit-int

Warn when a declaration does not specify a type.

-Wmain

Warn if the type of main is suspicious. main should be a function with external linkage, returning
int, taking either zero, two, or three arguments of appropriate types.

-Wmissing-braces

Warn if an aggregate or union initializer is not fully bracketed. In the following example, the
initializer for a is not fully bracketed, but that for b is fully bracketed.
int a[2][2] = { 0, 1, 2, 3 };
int b[2][2] = { { 0, 1 }, { 2, 3 } };

-Wmultistatementmacros

Warns for unsafe macro expansion as a body of a statement such as if, else, while, switch, or for.
Enabled with -Wall command.

-Wno-multichar

Warn if a multi-character character constant is used. Usually, such constants are typographical
errors. Since they have implementation-defined values, they should not be used in portable
code. The following example illustrates the use of a multi-character character constant:
char
xx(void)
{
return('xx');
}

-Wparentheses

Warn if parentheses are omitted in certain contexts, such as when there is an assignment in
a context where a truth value is expected, or when operators are nested whose precedence
people often find confusing.

-Wreturn-type

Warn whenever a function is defined with a return-type that defaults to int. Also warn about
any return statement with no return-value in a function whose return-type is not void.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 76

XC32 Compiler for PIC32M
Command-line Driver

...........continued
Option

Definition

-Wsequence-point

Warn about code that may have undefined semantics because of violations of sequence point
rules in the C standard.
The C standard defines the order in which expressions in a C program are evaluated in terms
of sequence points, which represent a partial ordering between the execution of parts of the
program: those executed before the sequence point and those executed after it. These occur
after the evaluation of a full expression (one which is not part of a larger expression), after the
evaluation of the first operand of a &&, ||, ? : or , (comma) operator, before a function is called
(but after the evaluation of its arguments and the expression denoting the called function),
and in certain other places. Other than as expressed by the sequence point rules, the order
of evaluation of subexpressions of an expression is not specified. All these rules describe only
a partial order rather than a total order. For example, if two functions are called within one
expression with no sequence point between them, the order in which the functions are called is
not specified. However, the standards committee has ruled that function calls do not overlap.
It is not specified when between sequence points modifications to the values of objects take
effect. Programs whose behavior depends on this have undefined behavior. The C standard
specifies that “Between the previous and next sequence point, an object shall have its stored
value modified, at most once, by the evaluation of an expression. Furthermore, the prior value
shall be read only to determine the value to be stored.” If a program breaks these rules, the
results on any particular implementation are entirely unpredictable.
Examples of code with undefined behavior are a = a++;,
a[n] = b[n++] and a[i++] = i;. Some more complicated cases are not diagnosed by this
option and it may give an occasional false positive result, but in general it has been found fairly
effective at detecting this sort of problem in programs.

-Wsizeof-pointer-div Warns for suspicious divisions of the size of a pointer by the size of the elements it points to,
which looks like the usual way to compute the array size but won't work out correctly with
pointers.
-Wswitch

Warn whenever a switch statement has an index of enumeral type and lacks a case for one
or more of the named codes of that enumeration. The presence of a default label prevents this
warning. case labels outside the enumeration range also provoke warnings when this option is
used.

-Wsystem-headers

Print warning messages for constructs found in system header files. Warnings from system
headers are normally suppressed on the assumption that they usually do not indicate real
problems and would only make the compiler output harder to read. Using this command line
option tells the compiler to emit warnings from system headers as if they occurred in user code.
However, note that using -Wall in conjunction with this option does not warn about unknown
pragmas in system headers. For that, -Wunknown-pragmas must also be used.

-Wtrigraphs

Warn if any trigraphs are encountered (assuming they are enabled).

-Wuninitialized

Warn if an automatic variable is used without first being initialized.
These warnings are possible only when optimization is enabled, because they require data flow
information that is computed only when optimizing.
These warnings occur only for variables that are candidates for register allocation. Therefore,
they do not occur for a variable that is declared volatile, or whose address is taken, or whose
size is other than 1, 2, 4 or 8 bytes. Also, they do not occur for structures, unions or arrays, even
when they are in registers.
Note that there may be no warning about a variable that is used only to compute a value that
itself is never used, because such computations may be deleted by data flow analysis before the
warnings are printed.

-Wunknown-pragmas

Warn when a #pragma directive is encountered which is not understood by the compiler. If this
command line option is used, warnings will even be issued for unknown pragmas in system
header files. This is not the case if the warnings were only enabled by the -Wall command line
option.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 77

XC32 Compiler for PIC32M
Command-line Driver

...........continued
Option

Definition

-Wunused

Warn whenever a variable is unused aside from its declaration, whenever a function is declared
static but never defined, whenever a label is declared but not used, and whenever a statement
computes a result that is explicitly not used.
In order to get a warning about an unused function parameter, both -W and -Wunused must be
specified.
Casting an expression to void suppresses this warning for an expression. Similarly, the unused
attribute suppresses this warning for unused variables, parameters and labels.

-Wunused-function

Warn whenever a static function is declared but not defined or a non-inline static function is
unused.

-Wunused-label

Warn whenever a label is declared but not used. To suppress this warning, use the unused
attribute.

-Wunused-parameter

Warn whenever a function parameter is unused aside from its declaration. To suppress this
warning, use the unused attribute.

-Wunused-variable

Warn whenever a local variable or non-constant static variable is unused aside from its
declaration. To suppress this warning, use the unused attribute.

-Wunused-value

Warn whenever a statement computes a result that is explicitly not used. To suppress this
warning, cast the expression to void.

The following -W options are not implied by -Wall. Some of them warn about constructions that
users generally do not consider questionable, but which you might occasionally wish to check for.
Others warn about constructions that are necessary or hard to avoid in some cases, and there is no
simple way to modify the code to suppress the warning.
Table 5-12. Warning and Error Options Not Implied by All Warnings
Option

Definition

-Wextra

Enable extra warning flags that are not enabled by -Wall.

(formerly) -W
-Waggregate-return Warn if any functions that return structures or unions are defined or called.
-Wbad-functioncast

Warn whenever a function call is cast to a non-matching type. For example, warn if int foof() is
cast to anything *.

-Wcast-align

Warn whenever a pointer is cast, such that the required alignment of the target is increased. For
example, warn if a char * is cast to an int *.

-Wcast-qual

Warn whenever a pointer is cast, so as to remove a type qualifier from the target type. For example,
warn if a const char * is cast to an ordinary char *.

-Wconversion

Warn if a prototype causes a type conversion that is different from what would happen to the same
argument in the absence of a prototype. This includes conversions of fixed point to floating and
vice versa, and conversions changing the width or signedness of a fixed point argument, except
when the same as the default promotion.
Also, warn if a negative integer constant expression is implicitly converted to an unsigned type. For
example, warn about the assignment x = -1 if x is unsigned. But do not warn about explicit casts
like (unsigned) -1.

-Werror

Make all warnings into errors.

-Winline

Warn if a function can not be inlined, and either it was declared as inline, or else the -finlinefunctions option was given.

-Wlarger-than-len

Warn whenever an object of larger than len bytes is defined.

-Wlong-long
-Wno-long-long

Warn if long long type is used. This is default. To inhibit the warning messages, use -Wno-longlong. Flags -Wlong-long and -Wno-long-long are taken into account only when -pedantic flag
is used.

-Wmissingdeclarations

Warn if a global function is defined without a previous declaration. Do so even if the definition itself
provides a -prototype.

-Wmissing- format- If -Wformat is enabled, also warn about functions that might be candidates for format attributes.
attribute
Note these are only possible candidates, not absolute ones. This option has no effect unless
-Wformat is enabled.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 78

XC32 Compiler for PIC32M
Command-line Driver

...........continued
Option

Definition

-Wmissing-noreturn Warn about functions that might be candidates for attribute noreturn. These are only possible
candidates, not absolute ones. Care should be taken to manually verify functions. In fact, do not
ever return before adding the noreturn attribute, otherwise subtle code generation bugs could be
introduced.
-Wmissingprototypes

Warn if a global function is defined without a previous prototype declaration. This warning is issued
even if the definition itself provides a prototype (this option can be used to detect global functions
that are not declared in header files).

-Wnested-externs

Warn if an extern declaration is encountered within a function.

-Wno-deprecateddeclarations

Do not warn about uses of functions, variables and types marked as deprecated by using the
deprecated attribute.

-Wpadded

Warn if padding is included in a structure, either to align an element of the structure or to align the
whole structure.

-Wpointer-arith

Warn about anything that depends on the size of a function type or of void. The compiler assigns
these types a size of 1, for convenience in calculations with void *pointers and pointers to
functions.

-Wredundant-decls

Warn if anything is declared more than once in the same scope, even in cases where multiple
declaration is valid and changes nothing.

-Wshadow

Warn whenever a local variable shadows another local variable.

-Wsign-compare

Warn when a comparison between signed and unsigned values could produce an incorrect result
when the signed value is converted to unsigned. This warning is also enabled by -W. To get the
other warnings of -W without this warning, use -W -Wno-sign-compare.

-Wno-sign-compare
-Wstrictprototypes

Warn if a function is declared or defined without specifying the argument types (an old-style
function definition is permitted without a warning if preceded by a declaration which specifies the
argument types).

-Wtraditional

Warn about certain constructs that behave differently in traditional and ANSI C.
•

Macro arguments occurring within string constants in the macro body. These would substitute
the argument in traditional C, but are part of the constant in ANSI C.

•

A function declared external in one block and then used after the end of the block.

•

A switch statement has an operand of type long.

•

A nonstatic function declaration follows a static one. This construct is not accepted by some
traditional C compilers.

-Wundef

Warn if an undefined identifier is evaluated in an #if -directive.

-Wwrite-strings

Give string constants the type const char[length] so that copying the address of one into a
non-const char * pointer gets a warning. At compile time, these warnings help you find code
that you can try to write into a string constant, but only if you have been very careful about using
const in declarations and prototypes. Otherwise, it’s just a nuisance, which is why -Wall does not
request these warnings.

5.7.5.1 Syntax-only Option

The -fsyntax-only option checks the C source code for syntax errors, then terminates the
compilation.

5.7.5.2 Pedantic Option

The -pedantic option ensures that programs do not use forbidden extensions and that warnings
are issued when a program does not follow ISO C.

5.7.5.3 Pedantic-errors Option

The -pedantic-errors option works in the same way as the -pedantic option, only errors,
instead of warnings, are issued when a program is not ISO compliant.

5.7.5.4 W: Disable all Warnings Option

The -w option inhibits all warning messages, and thus should be used with caution.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 79

XC32 Compiler for PIC32M
Command-line Driver

5.7.5.5 Wall Option
The -Wall option enables all the warnings about easily avoidable constructions that some users
consider questionable, even in conjunction with macros.
Note that some warning flags are not implied by -Wall. Of these warnings, some relate to
constructions that users generally do not consider questionable, but which you might occasionally
wish to check. Others warn about constructions that are necessary or hard to avoid in some cases
and there is no simple way to modify the code to suppress the warning. Some of these warnings can
be enabled using the -Wextra option, but many of them must be enabled individually.

5.7.5.6 Wextra Option
The -Wextra option generates extra warnings in the following situations.
•

A nonvolatile automatic variable might be changed by a call to longjmp. These warnings are
possible only in optimizing compilation. The compiler sees only the calls to setjmp. It cannot
know where longjmp will be called. In fact, a signal handler could call it at any point in the
code. As a result, a warning may be generated even when there is in fact no problem, because
longjmp cannot in fact be called at the place that would cause a problem.

•

A function could exit both via return value; and return;. Completing the function body
without passing any return statement is treated as return;.

•

An expression-statement or the left-hand side of a comma expression contains no side effects.
To suppress the warning, cast the unused expression to void. For example, an expression such
as x[i,j] causes a warning, but x[(void)i,j] does not.

•

An unsigned value is compared against zero with < or <=.

•

A comparison like x<=y<=z appears. This is equivalent to (x<=y ? 1 : 0) <= z, which is a
different interpretation from that of an ordinary mathematical notation.

•

Storage-class specifiers like static are not the first things in a declaration. According to the C
Standard, this usage is obsolescent.

•

If -Wall or -Wunused is also specified, warn about unused arguments.

•

A comparison between signed and unsigned values could produce an incorrect result when the
signed value is converted to unsigned (but won’t warn if -Wno-sign-compare is also specified).

•

An aggregate has a partly bracketed initializer. For example, the following code would evoke such
a warning, because braces are missing around the initializer for x.h:
struct s { int f, g; };
struct t { struct s h; int i; };
struct t x = { 1, 2, 3 };

•

An aggregate has an initializer that does not initialize all members. For example, the following
code would cause such a warning, because x.h would be implicitly initialized to zero:
struct s { int f, g, h; };
struct s x = { 3, 4 };

5.7.6

Options for Debugging
The options tabulated below control the debugging output produced by the compiler and are
discussed in the sections that follow.
Table 5-13. Debugging Options
Option

Definition

-dA

Add extra debug information to generated assembly.

-fdiagnostics-show-caret

Controls information shown in diagnostics.

-f[no-]eliminate-unused-debugsymbols

Eliminate debug information associated with any C/C++ symbol that has not
been used in the program.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 80

XC32 Compiler for PIC32M
Command-line Driver

...........continued
Option

Definition

-fframe-base-loclist

Include a frame-base location list in debugging information.

-g

Produce debugging information.

-mno-info-linker

Suppresses some linker advisory messages.

-Q

Print function names and statistics from each pass.

-save-temps[=dir]

Don’t delete intermediate files.

5.7.6.1 Da Option

The -dA option adds extra diagnostic information to the generated assembly code. Since this
assembly code is output to a temporary file that is normally deleted after compilation, you can
use the -save-temps option to preserve it for later inspection.

5.7.6.2 Diagnostics-show-caret Options

The -fdiagnostics-show-caret option has each diagnostic include the original source line and a
caret character, ‘^’, indicating the column. This is the default action if no option is specified.
The -fno-diagnostics-show-caret form of this option suppresses the source line and caret
from all diagnotics.

5.7.6.3 Eliminate-unused-debug-symbols Option

The -feliminate-unused-debug-symbols option eliminates the debug information associated
with any C/C++ symbol that has not been used in the program. This is also the default action if no
option has been specified. Eliminating this information will reduce the size and load time of output
files.
Use the -fno-eliminate-unused-debug-symbols form of this option if you want debug
information generated for all symbols.

5.7.6.4 Frame-base-loclist Option

The -fframe-base-loclist option includes a frame-base location list in debugging information
produced by the compiler. The MPLAB X IDE supports frame-base location lists in the DWARF
content of ELF files, and this option can be used when debugging with this IDE.
The -fno-frame-base-loclist form of this option prevents these lists from being generated,
making the compiler debug information compatible with older IDEs that do not support this feature.
This is the default action if no option is specified.

5.7.6.5 G: Produce Debugging Information Option

The -g option instructs the compiler to produce additional information, which can be used by
hardware tools to debug your program.

The option can be used with -O, making it possible to debug optimized code. The shortcuts taken by
optimized code may occasionally produce surprising results:
•

Some declared variables may not exist at all

•

Flow of control may briefly move unexpectedly

•

Some statements may not be executed because they compute constant results or their values
were already at hand

•

Some statements may execute in different places because they were moved out of loops

Nevertheless it proves possible to debug optimized output. This makes it reasonable to use the
optimizer for programs that might have bugs.

5.7.6.6 No-info-linker Option

The -mno-info-linker option suppresses some advisory messages issued by the linker. Such
messages might indicate the location of the linker script being used, for example.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 81

XC32 Compiler for PIC32M
Command-line Driver

5.7.6.7 Q: Print Function Information Option

The -Q option instructs the compiler to print out each function name as it is compiled, and print
statistics about each pass when it finishes.

5.7.6.8 Save-temps Option

The -save-temps option instructs the compiler to keep temporary files after compilation
has finished. You might find the generated .i and .s temporary files particularly useful for
troubleshooting and they are often used by the Microchip Support team when you enter a support
ticket.

The intermediate files will be placed in the current directory and have a name based on the
corresponding source file. Thus, compiling foo.c with -save-temps would produce foo.i, foo.s
and the foo.o object file.
The -save-temps=cwd option is equivalent to -save-temps.
The -save-temps=obj form of this option is similar to -save-temps, but if the -o option is
specified, the temporary files are placed in the same directory as the output object file. If the -o
option is not specified, the -save-temps=obj switch behaves like –save-temps.
The following example will create dir/xbar.i, dir/xbar.s, since the -o option was used.
xc32-gcc -save-temps=obj -c bar.c -o dir/xbar.o

5.7.7

Options for Controlling Optimization
The options tabulated below control compiler optimizations and are described in the sections that
follow.
Use of an option is permitted and has an effect with an unlicensed compiler (Free edition), if that
option is enabled by default, when using optimization level 2 or lower. Any form of option that
disables an optimization is available unconditionally.
Table 5-14. Optimization Options
Option

Edition

Controls

-O0

All

Do not optimize.

-O
-O1

All

Optimization level 1.

-O2

All

Optimization level 2.

-O3

PRO only Speed-orientated optimizations.

-Os

PRO only Size-orientated optimizations.

-falign-functions[=n]
-f[no-]align-functions

All

Alignment of the start of functions.

-falign-labels[=n]
-f[no-]align-labels

All

Alignment of all branch targets.

-falign-loops[=n]
-f[no-]align-loops

All

Alignment of loops.

-f[no-]caller-saves

All

Allocation into registers clobbered by function calls.

-f[no-]cse-follow-jumps

All

Customization of common subexpression elimination optimizations.

-f[no-]cse-skip-blocks

All

Customization of common subexpression elimination optimizations.

-f[no-]data-sections

All

Placement of objects into a section in the output file.

-f[no-]defer-pop

All

When arguments to function calls are popped.

-f[no-]expensive-optimizations All
-ffat-lto-objects

All

Minor optimizations that are relatively expensive.
Requests that the compiler generate fat object files.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 82

XC32 Compiler for PIC32M
Command-line Driver

...........continued
Option

Edition

Controls

-f[no-]function-cse

All

Placement of function addresses.

-f[no-]function-sections

All

Placement of functions into a section in the output file.

-f[no-]gcse

All

The global common subexpression elimination pass.

-f[no-]gcse-lm

All

Customization of common subexpression elimination dealing with loads.

-f[no-]gcse-sm

All

Customization of common subexpression elimination dealing with stores.

-f[no-]inline-functions

All

Integration of all simple functions into their callers.

-f[no-]inline-limit=n

All

The size limit for inlining functions.

-finline-small-functions

All

Integration of all simple functions into their callers.

-f[no-]keep-inline-functions

All

Output of a separate run-time-callable version of inlined functions.

-f[no-]keep-static-consts

All

Output of static const objects.

-f[no-]lto

PRO only The standard link-time optimizer.

-flto-partition=algorithm

PRO only The link-time optimizer algorithm used to partition object files.

-f[no-]omit-frame-pointer

All

Reservation of the Frame Pointer in a register for functions that don't
need one.

-f[no-]optimize-register-move
-f[no-]regmove

All

Reassign of register numbers in move and other instructions.

-f[no-]optimize-sibling-calls

All

Optimization of sibling and tail recursive calls.

-fpeel-loops

All

Reconfigure loops in the source code.

-f[no-]peephole
-f[no-]peephole2

All

Machine-specific peephole optimizations.

-f[no-]rename-registers

All

Use of free registers to avoid false dependencies in scheduled code.

-f[no-]rerun-cse-after-loop

All

When common subexpression elimination optimizations should be
performed.

-f[no-]rerun-loop-opt

All

How often to run the loop optimizer.

-f[no-]schedule-insns
-f[no-]schedule-insns2

All

Reordering instructions to eliminate instruction stalls.

-f[no-]strength-reduce

All

Loop strength reduction and elimination of iteration variables.

-f[no-]strict-aliasing

All

Assumption of the strictest aliasing rules applicable to the language being
compiled.

-f[no-]thread-jumps

All

Jump-to-branch optimizations.

-f[no-]toplevel-reorder

All

Reordering of top-level functions, variables, and asm statements.

-ftracer

All

Perform tail duplication.

-f[no-]unroll-loops
-f[no-]unroll-all-loops

All

Loop unrolling.

-fuse-linker-plugin

All

Enable use of a linker plugin during link-time optimization plugin.

-f[no-]whole-program

PRO only More aggressive interprocedural optimizations.

5.7.7.1 O0: Level 0 Optimizations

The -O0 option performs only rudimentary optimization. This is the default optimization level if no
-O option is specified.
With this optimization level selected, the compiler’s goal is to reduce the cost of compilation and to
make debugging produce the expected results.
Statements are independent when compiling with this optimization level. If you stop the program
with a breakpoint between statements, you can then assign a new value to any variable or change
the program counter to any other statement in the function and get exactly the results you would
expect from the source code.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 83

XC32 Compiler for PIC32M
Command-line Driver

The compiler only allocates variables declared register in registers.

5.7.7.2 O1: Level 1 Optimizations
The -O1 or -O options request level 1 optimizations.
The optimizations performed when using -O1 aims to reduce code size and execution time, but still
allows a reasonable level of debugability.
This level is available for unlicensed as well as licensed compilers.

5.7.7.3 O2: Level 2 Optimizations Option
The -O2 option requests level 2 optimizations.
At this level, the compiler performs nearly all supported optimizations that do not involve a spacespeed trade-off.
This level is available for unlicensed as well as licensed compilers.

5.7.7.4 O3: Level 3 Optimizations Option
The -O3 option requests level 3 optimizations.
This option requests all supported optimizations that reduces execution time but which might
increase program size.
This level is available only for licensed compilers.

5.7.7.5 Os: Level s Optimizations Option
The -Os option requests space-orientated optimizations.
This option requests all supported optimizations that do not typically increase code size.
This level is available only for licensed compilers.

5.7.7.6 Align-functions Option
The -falign-functions=n option aligns the start of functions to the next power-of-two greater
than n, skipping up to n bytes.
For instance, -falign-functions=32 aligns functions to the next 32-byte boundary; -falignfunctions=24 aligns functions to the next 32-byte boundary but only if this can be done by
skipping no more than 23 bytes.
This option is automatically enabled at optimization levels -O2 and -O3.
The -fno-align-functions form of this option is equivalent to -falign-functions=1 and
implies that functions are not aligned.
The -falign-functions form of this option (with no argument) performs no additional alignment
other than the usual alignment by 4 for code using the MIPS instruction set or by 2 for code using
the MIPS16 instruction set.

5.7.7.7 Align-labels Option
The -falign-labels=n option aligns all branch targets to the next power-of-two greater than
n, skipping up to n bytes. For instance, -falign-labels=8 aligns functions to the next 8-byte
boundary; -falign-functions=9 aligns functions to the next 16-byte boundary but only if this can
be done by skipping no more than 9 bytes.
This option can easily make code slower, because it must insert dummy operations for when the
branch target is reached in the usual flow of the code.
If the options -falign-loops or -falign-jumps have been used and either of their arguments
are greater than n, then their argument values are used to determine the label alignment instead.
This option is automatically enabled at optimization levels -O2 and -O3.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 84

XC32 Compiler for PIC32M
Command-line Driver

The -fno-align-labels form of this option is equivalent to -falign-labels=1 and implies
that functions are not aligned. The -falign-labels form of this option (with no argument) also
performs no alignment.

5.7.7.8 Align-loops Option
The -falign-loops=n option aligns loops to the next power-of-two greater than n, skipping up
to n bytes. For instance, -falign-loops=32 aligns loops to the next 32-byte boundary; -falignloops=24 aligns loops to the next 32-byte boundary but only if this can be done by skipping no
more than 23 bytes.
The -fno-align-loops form of this option is equivalent to -falign-loops=1 and implies that
functions are not aligned. The -falign-loops form of this option (with no argument) also
performs no alignment.
The hope is that the loop is executed many times, which makes up for any execution of the dummy
operations.

5.7.7.9 Caller-saves Option
The -fcaller-saves option allows the compiler to allocate values to registers that are clobbered
by function calls. If allocation to these registers takes place, extra code to save and restore the
clobbered registers is generated around function calls. Allocation is performed only when better
performing code is expected than would otherwise be produced.
This option is automatically enabled at optimization levels -O2, -O3, and -Os.
The -fno-caller-saves form of this option never allocates values to registers that are clobbered
by functions.

5.7.7.10 Cse-follow-jumps Option
The -fcse-follow-jumps option instructs the common subexpression elimination (CSE)
optimizations to scan through jump instructions when the target of the jump is not reached by
any other path. For example, when CSE encounters an if() statement with an else clause, CSE
follows the jump when the condition tested is false.
This option is automatically enabled at optimization levels -O2, -O3, and -Os.
The -fno-cse-follow-jumps form of this option does not perform this scan.

5.7.7.11 Cse-skip-blocks Option
The -fcse-skip-blocks option performs a similar task to the -fcse-follow-jumps option
but instructs the common subexpression elimination (CSE) optimizations to follow jumps that
conditionally skip over blocks. When CSE encounters a simple if() statement with no else clause,
it will follow the jump around the body of the if().
This option is automatically enabled at optimization levels -O2, -O3, and -Os.
The -fno-cse-skip-blocks form of this option does not perform this scan.

5.7.7.12 Data-sections Option
The -fdata-sections option places each object in its own section to assist with garbage collection
and potential code size reductions.
When enabled, this option has each object placed in its own section named after the object. When
used in conjunction with garbage collection performed by the linker (enabled using the-Wl,--gcsections driver option) the final output might be smaller. It can, however, negatively impact other
code generation optimizations, so confirm whether this option is of benefit with each project.
The -fno-data-sections form of this option does not force each object to a unique section. This
is the default action if no option is specified.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 85

XC32 Compiler for PIC32M
Command-line Driver

5.7.7.13 Defer-pop Option
The -fdefer-pop option specifies that the compiler should let function arguments accumulate on
the stack for several function calls before they are popped off the stack in one step.
This option is automatically enabled at optimization levels -O1, -O2, -O3, and -Os.
The -fno-defer-pop form of this option has the compiler pop the arguments to each function call
as soon as that function returns.

5.7.7.14 Expensive-optimizations Option
The -fexpensive-optimizations options has the compiler perform a number of optimizations
that have minimal effect but that are relatively expensive to perform.
This option is automatically enabled at optimization levels -O2, -O3, and -Os.
The -fno-expensive-optimizations form of this option does not perform these optimizations.

5.7.7.15 Fat-lto-objects Option
The -ffat-lto-objects option requests that the compiler generate fat object files, which contain
both object code and GIMPLE (one of GCC’s internal representations), written to unique ELF sections.
Such objects files are useful for library code that could be linked with projects that do and do not
use the standard link-time optimizer, controlled by the -flto option.
The -fno-fat-lto-objects form of this option, which is the default if no option is specified,
suppresses the inclusion of the object code into object files, resulting in faster builds. However, such
object files must always be linked using the standard link-time optimizer.

5.7.7.16 Function-cse Option
The -ffunction-cse form of this option allows the address of called functions to be held in
registers. This is the default action if no option is specified.
The -fno-function-cse form of this option will not place function addresses in registers. Each
instruction that calls a constant function contain the function's address explicitly. This option results
in less efficient code, but some strange hacks that alter the assembler output may be confused by
the optimizations performed when this option is not used.

5.7.7.17 Function-sections Option
The -ffunction-sections option places each function in its own section to assist with garbage
collection and potential code size reductions.
When enabled, this option has each function placed in its own section named after the function.
When used in conjunction with garbage collection performed by the linker (enabled using the
-Wl,--gc-sections driver option) the final output might be smaller. The -ffunction-sections
option can, however, hamper other code generation optimizations, so confirm whether this option
is of benefit with each project.
Note also that if functions are removed, their debugging information will remain in the ELF file,
potentially imperiling the debuggability of code. When displaying source code information, the
debugger looks for associations between addresses and the functions whose code resides at those
locations, and it might wrongly consider that an address belongs to a removed function. As removed
functions are not allocated memory, their "assigned" address will not change from being 0, thus
the debugger is more likely to show references to a removed function when interpreting addresses
closer to 0.
The -fno-function-sections form of this option does not force each function into a unique
section. This is the default action if no option is specified.

5.7.7.18 Gcse Option
The -fgcse option perform a global common subexpression elimination pass. This pass also
performs global constant and copy propagation.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 86

XC32 Compiler for PIC32M
Command-line Driver

This option is automatically enabled at optimization levels -O2, -O3, and -Os.
The -fno-gcse form of this option does not perform this pass.

5.7.7.19 Gcse-lm Option
The -fgcse-lm option attempts to have the global common subexpression elimination
optimizations move load sequences that are only killed by stores into themselves. This allows a
loop containing a load/store sequence to change to a load outside the loop, and a copy/store within
the loop.
The option is enabled when -fgcse is enabled.
The -fno-gcse-lm form of this option does not move these sequences.

5.7.7.20 Gcse-sm Option
The -fgcse-sm option runs a store motion pass after the global common subexpression
elimination optimizations. This pass attempts to move stores out of loops. When used in
conjunction with -fgcse-lm, loops containing a load/store sequence can change to a load before
the loop and a store after the loop.
The option is not automatically enabled at any optimization level.
The -fno-gcse-sm form of this option does not move these sequences.

5.7.7.21 Inline-functions Option
The -finline-functions option considers all functions for inlining, even if they are not declared
inline.
If all calls to a given function are inlined, and the function is declared static, then the function is
normally not output as a stand-alone assembler routine.
This option is automatically enabled at optimization levels -O3 and -Os.
The -fno-inline-functions form of this option will never inline function that have not been
marked as inline.

5.7.7.22 Inline-limit Option
The -finline-limit=n option controls the inlining size limit for functions marked inline. The
argument, n, is a number of pseudo instructions (not counting parameter handling) being an
abstract measurement of a function's size. In no way does this value represent a count of assembly
instructions and as such, its exact meaning might change from one release of the compiler to an
another. The default value of n is 10000.
Increasing the inlining limit can result in more inlined code at the cost of compilation time and
memory consumption.

5.7.7.23 Inline-small-functions Options
The -finline-small-functions option integrates the body of functions into its callers when a
function's code size is expected to be smaller than the size of the call/return sequence that would
otherwise be required to call that function. The compiler heuristically decides which functions are
simple enough to integrate in this way so as to reduce the size of the program. This inlining applies
to all functions, even those not declared inline. Automatically enabled at optimization levels -O2,
-O3, and -Os.
The -fno-inline-small-functions form of this option suppresses this optimization.

5.7.7.24 Keep-inline-functions Option
The -fkeep-inline-functions option ensures that separate run-time-callable assembly code for
functions is output, even if all calls to a given function are inlined and the function is declared
static. This switch does not affect the output of extern inline functions.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 87

XC32 Compiler for PIC32M
Command-line Driver

The -fno-keep-inline-functions form of this option will not emit output for static functions
where all calls to it have been inlined. This is the default action if no option has been specified.

5.7.7.25 Keep-static-consts Option

The -fkeep-static-consts option emits static const objects when the optimizers are
disabled, even if the objects are not referenced. This is the default action if no option is specified.
The -fno-keep-static-consts form of this option forces the compiler to emit the object only
when referenced, regardless of whether the optimizers are enabled.

5.7.7.26 Lto Option

This -flto option runs the standard link-time optimizer.

When invoked with source code, the compiler adds an internal bytecode representation of the code
to special sections in the object file. When the object files are linked together, all the function bodies
are read from these sections and instantiated as if they had been part of the same translation unit.
Link time optimizations do not require the presence of the whole program to operate.
To use the link-timer optimizer, specify -flto both at compile time and during the final link. For
example:
xc32-gcc -c -O3 -flto -mprocessor=32MZ2048ECH100 foo.c
xc32-gcc -c -O3 -flto -mprocessor=32MZ2048ECH100 bar.c
xc32-gcc -o myprog.elf -flto -O3 -mprocessor=32MZ2048ECH100 foo.o bar.o

Another (simpler) way to enable link-time optimization is:
xc32-gcc -o myprog.elf -flto -O3 -mprocessor=32MZ2048ECH100 foo.c bar.c

The bytecode files are versioned and there is a strict version check, so bytecode files generated in
one version of the XC32 compiler might not work with a different version.
The -fno-lto form of this option does not run the standard link-time optimizer. This is the default
action if this option is not specified.

5.7.7.27 Lto-partition Option

The -flto-partition=algorithm option controls the algorithm used to partition object files
when running the link-time optimizer. Multiple partitions can be optimized in parallel, which might
reduce the memory and processing time required by the compiler.
The argument none disables partitioning entirely and executes the link-time optimization step
directly from the whole program analysis (WPA) phase. This mode of operation will produce the
most optimal results at the expense of larger compiler memory requirements and longer build
times, although this is unlikely to be an issue with small programs.

The one algorithm argument specifies that link-time optimizations should be performed on the
whole program as a single unit, rather than splitting it into smaller partitions. This can result in
better optimization opportunities, especially for interprocedural analysis and transformations, but it
also requires the most memory and computational time during the link phase.
Selecting the option argument to 1to1 splits the program so that each original compilation unit
becomes a separate partition. This can reduce the computational memory and time requirements
significantly but might also reduce the runtime performance benefits of the optimization.
The default argument is balanced, which specifies partitioning into a given number of parts of
roughly the same size, based on the call graph. This algorithm tries to balance the trade-off between
computational memory and time, as well as runtime performance.

5.7.7.28 Omit-frame-pointer Option

The -fomit-frame-pointer option instructs the compiler to directly use the stack pointer to
access objects on the stack and, if possible, omit code that saves, initializes, and restores the frame
register. It is enabled automatically at all non-zero optimization levels.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 88

XC32 Compiler for PIC32M
Command-line Driver

Negating the option, using -fno-omit-frame-pointer, might assist debugging optimized code;
however, this option does not guarantee that the frame pointer will always be used.

5.7.7.29 Optimize-register-move/regmove Option
The -foptimize-register-move option and its alias, -fregmove, have no effect, but are
accepted for backward compatibility.

5.7.7.30 Optimize-sibling-calls Option
The -foptimize-sibling-calls option optimizes sibling calls (where the last action of a function
is a call to another function whose stack footprint is compatible with the callee) and tail recursive
calls (where the last action of a function is a call to itself).
This option is automatically enabled at optimization levels -O2, -O3, and -Os.
The -foptimize-sibling-calls form of this option will not enable these optimizations.

5.7.7.31 Peel-loops Option
The -fpeel-loops option peels loops in the source code, which involves reconfiguring the loop
where possible so that a number of the early iterations are excluded from the loop and are
executed explicitly before the loop starts. Doing so might mean that the remaining loop body can be
executed more efficiently. This option also turns on complete loop peeling (i.e. complete removal of
loops that will execute a small, constant number of iterations). This option is automatically enabled
when selecting level -O3 optimizations.
The -fno-peel-loops form of this option does not perform loop peeling. This is the default action
if this option is not specified and level -O3 optimizations have not been selected.

5.7.7.32 Peephole/peephole2 Options
The -fpeephole option enables machine-specific peephole optimizations. Peephole optimizations
occur at various points during the compilation. This is the default action if no option is specified.
The -fpeephole2 form of this option enables high-level peephole optimizations. This option is
enabled at optimization levels -O2, -O3, and -Os.
The -fno-peephole and -fno-peephole2 form of these options disables standard and high-level
peephole optimizations, respectively. Both options should be used to entirely disable peephole
optimizations.

5.7.7.33 Rename-registers Option
The -frename-registers option attempts to avoid false dependencies in scheduled code by
making use of registers leftover after register allocation. This optimization most benefits processors
with many registers, but it can reduce the debugability of code, since variables might no longer be
allocated to a “home register.”
This option is automatically enabled when using -funroll-loops.
The -fno-rename-registers form of this option does not use leftover registers. This is the default
action if no option has been specified and the -funroll-loops option has not been used.

5.7.7.34 Rerun-cse-after-loop Option
The -frerun-cse-after-loop option reruns common subexpression elimination (CSE)
optimizations after loop optimizations has been performed.
This option is automatically enabled at optimization levels -O2, -O3, and -Os.
The -fno-rerun-cse-after-loop form of this option does not rerun the CSE optimizations.

5.7.7.35 Rerun-loop-opt Option
The -frerun-loop-opt option no longer has any effect and is ignored for compatibility with legacy
projects.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 89

XC32 Compiler for PIC32M
Command-line Driver

5.7.7.36 Schedule-insns/schedule-insns2 Options

The -fschedule-insns option attempts to reorder instructions to eliminate instruction stalls due
to required data being unavailable.
This option is automatically enabled at optimization levels -O2 and -O3.

The -fschedule-insns2 form of this option is similar to -fschedule-insns, but it requests an
additional pass of instruction scheduling after register allocation has been performed.
This option is automatically enabled at optimization levels -O2, -O3, and -Os.
The -fno-schedule-insns and -fno-schedule-insns2 forms of these options do not reorder
instructions.

5.7.7.37 Strength-reduce Option

The -fstrength-reduce option no longer has any effect and is ignored for compatibility with
legacy projects.

5.7.7.38 Strict-aliasing Option

The -fstrict-aliasing option allows the compiler to assume the strictest aliasing rules
applicable to the language being compiled. For C, this activates optimizations based on the type
of expressions. In particular, an object of one type is assumed never to reside at the same address
as an object of a different type, unless the types are almost the same.
For example, an unsigned int can alias an int, but not a void * or a double. A character type
may alias any other type.
Pay special attention to code like this:
union a_union {
int i;
double d;
};
int f() {
union a_union t;
t.d = 3.0;
return t.i;
}

The practice of reading from a different union member than the one most recently written to (called
“type-punning”) is common. Even with -fstrict-aliasing, type-punning is allowed, provided the
memory is accessed through the union type. The code above works as expected. However, this
code might not:
int f() {
a_union t;
int * ip;
t.d = 3.0;
ip = &t.i;
return *ip;
}

This option is automatically enabled at optimization levels -O2, -O3, and -Os.
-fno-strict-aliasing form of this option relaxes the aliasing rules, preventing some
optimizations from being performed.

5.7.7.39 Thread-jumps Option

The -fthread-jumps option enables checks to determine if the branch destinations of
comparisons are further comparisons that have been subsumed by the first. If so, the first branch
is redirected to either the destination of the second branch or a point immediately following it,
depending on whether the second branch condition is known to be true or false.
This option is automatically enabled at optimization levels -O2, -O3, and -Os.
The -fno-thread-jumps form of this option does not perform these checks.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 90

XC32 Compiler for PIC32M
Command-line Driver

5.7.7.40 Toplevel-reorder Option
The -ftoplevel-reorder option allows the compiler to reorder top-level functions, variables, and
asm statements, in which case, they might not be output in the same order that they appear in the
input file. This option also allows the compiler to remove unreferenced static variables.
Enabled at level -O0. When disabled explicitly using the -fno-toplevel-reorder option, it also
implies -fno-section-anchors, which is otherwise enabled at -O0 on some targets.

5.7.7.41 Tracer Option
The -ftracer option performs tail duplication, a transformation that can increase basic block
(trace) sizes by duplicating code after a control flow merge point. Such transformations can facilitate
many other optimizations, particularly speed-orientated optimizations aimed at reducing cache
misses and the overhead of branches and indirect jumps.
The -fno-tracer form of this option disables this transformation, and is the default action if no
option is specified.

5.7.7.42 Unroll-loops/unroll-all-loops Options
The -funroll-loops and -funroll-all-loops options control speed-orientated optimizations
that attempt to remove branching delays in loops. Unrolled loops typically increase the execution
speed of the generated code, at the expense of larger code size.
The -funroll-loops option unrolls loops where the number of iterations can be determined
at compile time or when code enters the loop. This option is enabled with -fprofile-use. The
-funroll-all-loops option is more aggressive, unrolling all loops, even when the number of
iterations is unknown. It is typically less effective at improving execution speed than the -funrollloops option.
Both options imply -frerun-cse-after-loop, -fweb and -frename-registers.
The -fno-unroll-loops and -fno-unroll-all-loops forms of these options do not unroll any
loops and are the default actions if no options are specified.

5.7.7.43 Use-linker-plugin Option
The -fuse-linker-plugin option enables the use of a linker plugin during link-time optimization,
improving the quality of optimization by exposing more code to the link-time optimizer. This is the
default action if no option is specified. The -fwhole-program option should not be used with the
-fuse-linker-plugin option.
The -fno-use-linker-plugin option disables the use of a linker plugin during link-time
optimization.

5.7.7.44 Whole-program Optimizations Option
The -fwhole-program option runs more aggressive interprocedural optimizations.
The option assumes that the current compilation unit represents the whole program being
compiled. All public functions and variables, with the exception of main() and those merged
by attribute externally_visible, become static functions and in effect are optimized more
aggressively by interprocedural optimizers. While this option is equivalent to proper use of the
static keyword for programs consisting of a single file, in combination with option -flto, this flag
can be used to compile many smaller scale programs since the functions and variables become local
for the whole combined compilation unit, not for the single source file itself.
The -fno-whole-program form of this option disables these optimizations and this is the default
action if no option is specified.

5.7.8

Options for Controlling the Preprocessor
The options tabulated below control the preprocessor and are discussed in the sections that follow.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 91

XC32 Compiler for PIC32M
Command-line Driver

Table 5-15. Preprocessor Options
Option

Definition

-C

Preserve comments.

-dletters

Make debugging dumps of preprocessor macros.

-Dmacro[=defn]

Define a macro.

-H

Print the name of each header file used.

-imacros file

Include file macro definitions only.

-include file

Process file as input before processing the regular input file.

-M

Generate make rule.

-MD

Write dependency information to file.

-MF file

Specify dependency file.

-MG

Ignore missing header files.

-MM

Generate make rule for quoted headers.

-MMD

Generate make rule for user headers.

-MP

Add phony target for dependency.

-MQ

Change rule target with quotes.

-MT target

Change rule target.

-nostdinc

Omit system directories from header search.

-P

Don’t generate #line directives.

-f[no-]show-column

Omit column numbers in diagnostics.

-trigraphs

Support ANSI C trigraphs.

-Umacro

Undefine a macro.

-undef

Do not predefine any nonstandard macros.

5.7.8.1 C: Preserve Comments Option
The -C option tells the preprocessor not to discard comments from the output. Use this option with
the -E option to see commented yet preprocessed source code.

5.7.8.2 d: Preprocessor Debugging Dumps Option
The -dletters option has the preprocessor produce debugging dumps during compilation as
specified by letters. This option should be used in conjunction with the -E option.
The -dM option generates a list of #define directives for all the macros defined during the
execution of the preprocessor, including predefined macros. These will indicate the replacement
string if one was defined. For example, the output might include:
#define _CP0_BCS_TAGLO(c,s) _bcsc0(_CP0_TAGLO, _CP0_TAGLO_SELECT, c, s)
#define PORTE PORTE
#define _LATE_LATE1_LENGTH 0x00000001
#define _IPC22_w_POSITION 0x00000000

You can use this option to show those macros which are predefined by the compiler or header files.
The acceptable letter arguments to -d are tabulated below.
Table 5-16. Preprocessor Debugging Information
Letter

Produces

D

Similar output to -dM but lacking predefined macros. The
normal preprocessor output is also included in this output.

M

Full macro output, as described in the main text before this
table.

N

Similar output to -dD but only the macro names are output
with each definition.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 92

XC32 Compiler for PIC32M
Command-line Driver

5.7.8.3 D: Define a Macro

The -Dmacro option allows you to define a preprocessor macro and the -Dmacro=text form of this
option additionally allows a user-define replacement string to be specified with the macro. A space
may be present between the option and macro name.

When no replacement text follows the macro name, the -Dmacro option defines a preprocessor
macro called macro and specifies its replacement text as 1. Its use is the equivalent of placing
#define macro 1 at the top of each module being compiled.
The -Dmacro=text form of this option defines a preprocessor macro called macro with the
replacement text specified. Its use is the equivalent of placing #define macro text at the top
of each module being compiled.
Either form of this option creates an identifier (the macro name) whose definition can be checked by
#ifdef or #ifndef directives. For example, when using the option, -DMY_MACRO (or -D MY_MACRO)
and building the following code:
#ifdef MY_MACRO
int input = MY_MACRO;
#endif

the definition of the int variable input will be compiled, and the variable assigned the value 1.
If the above example code was instead compiled with the option -DMY_MACRO=0x100, then the
variable definition that would ultimately be compiled would be: int input = 0x100;
See 22.2.1. Preprocessor Arithmetic for clarification of how the replacement text might be used.
Defining macros as C string literals requires escaping the quote characters (" ") used by the string.
If a quote is intended to be included and passed to the compiler, it should be escaped with a
backslash character (\). If a string includes a space character, the string should have additional
quotes around it.
For example, to pass the C string, "hello world", (including the quote characters and the space
in the replacement text), use -DMY_STRING="\"hello world\"". You could also place quotes
around the entire option: "-DMY_STRING=\"hello world\"". These formats can be used on any
platform. Escaping the space character, as in -DMY_STRING=\"hello\ world\" is only permitted
with macOS and Linux systems and will not work under Windows, and hence it is recommended that
the entire option be quoted to ensure portability.
All instances of -D on the command line are processed before any -U options.

5.7.8.4 H: Print Header Files Option

The -H option prints to the console the name of each header file used, in addition to other normal
activities.

5.7.8.5 Imacros Option

The -imacros file option processes the specified file in the same way the -include option
would, except that any output produced by scanning the file is thrown away. The macros that
the file defines remain defined during processing. Because the output generated from the file is
discarded, the only effect of this option is to make the macros defined in file available for use in the
main input.
Any -D and -U options on the command line are always processed before an -imacros option,
regardless of the order in which they are placed. All the -include and -imacros options are
processed in the order in which they are written.

5.7.8.6 Include Option

The -include file option processes file as if #include "file" appeared as the first line of
the primary source file. In effect, the contents of file are compiled first. Any -D and -U options
on the command line are always processed before the -include option, regardless of the order in

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 93

XC32 Compiler for PIC32M
Command-line Driver

which they are written. All the -include and -imacros options are processed in the order in which
they are written.

5.7.8.7 M: Generate Make Rule
The -M option tells the preprocessor to output a rule suitable for make that describes the
dependencies of each object file.
For each source file, the preprocessor outputs one make-rule whose target is the object file name
for that source file and whose dependencies are all the header files it includes. This rule may be a
single line or may be continued with a backslash-newline sequence if it is lengthy.
The list of rules is printed on standard output instead of the preprocessed C program.
The -M option implies -E.

5.7.8.8 MD: Write Dependency Information To File Option
The -MD option writes dependency information to a file.
This option is similar to -M but the dependency information is written to a file and compilation
continues. The file containing the dependency information is given the same name as the source file
with a .d extension.

5.7.8.9 MF: Specify Dependency File Option
The -MF file option specifies a file in which to write the dependencies for the -M or -MM options.
If no -MF option is given, the preprocessor sends the rules to the same place it would have sent
preprocessed output.
When used with the driver options, -MD or -MMD, -MF, overrides the default dependency output file.

5.7.8.10 MG: Ignore Missing Header Files Option
The -MG option treats missing header files as generated files and adds them to the dependency list
without raising an error.
The option assumes the missing files live in the same directory as the source file. If -MG is specified,
then either -M or -MM must also be specified. This option is not supported with -MD or -MMD.

5.7.8.11 MM: Generate Make Rule For Quoted Headers Option
The -MM option performs the same tasks as -M, but system headers are not included in the output.

5.7.8.12 MMD: Generate Make Rule For User Headers Option
The -MMD option performs the same tasks as -MD, but only user header files are included in the
output.

5.7.8.13 MP: Add Phony Target For Dependency Option
The -MP option instructs the preprocessor to add a phony target for each dependency other than
the main file, causing each to depend on nothing. These MP rules work around make errors if you
remove header files without updating the make-file to match.
This is typical output:
test.o: test.c test.h
test.h:

5.7.8.14 MQ: Change Rule Target With Quotes Option
The -MQ option is similar to -MT, but it quotes any characters which are considered special by make.
-MQ '$(objpfx)foo.o' gives $$(objpfx)foo.o: foo.c

The default target is automatically quoted, as if it were given with -MQ.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 94

XC32 Compiler for PIC32M
Command-line Driver

5.7.8.15 MT: Change Rule Target Option

The -MT target option changes the target of the rule emitted by dependency generation.

By default, the preprocessor takes the name of the main input file, including any path, deletes any
file suffix such as .c, and appends the platform’s usual object suffix. The result is the target. An
-MT option sets the target to be exactly the string you specify. If you want multiple targets, you can
specify them as a single argument to -MT, or use multiple -MT options.
For example:
-MT '$(objpfx)foo.o' might give $(objpfx)foo.o: foo.c

5.7.8.16 Nostdinc Option

The -nostdinc option prevents the standard system directories for header files being searched by
the preprocessor. Only the directories you have specified with -I options (and the current directory,
if appropriate) are searched.
By using both -nostdinc and -iquote, the include-file search path can be limited to only those
directories explicitly specified.

5.7.8.17 P: Don’t Generate #line Directives Option

The -P option tells the preprocessor not to generate #line directives in the preprocessed output.
Used with the -E option.

5.7.8.18 Trigraphs Option

The -trigraphs option turns on support for ANSI C trigraphs. The -ansi option also has this
effect.

5.7.8.19 Show-column Option

The -show-column option will print column numbers in diagnostics. This is the default action if no
option is specified.

The -no-show-column form of this option will not print column numbers in diagnostics. This may
be necessary if diagnostics are being scanned by a program that does not understand the column
numbers, such as DejaGnu.

5.7.8.20 U: Undefine Macros

The -Umacro option undefines the macro macro.

Any builtin macro or macro defined using -D will be undefined by the option. All -U options are
evaluated after all -D options, but before any -include and -imacros options.

5.7.8.21 Undef Option

The -undef option prevents any system-specific or GCC-specific macros being predefined (including
architecture flags).

5.7.9

Options for Assembling
The option tabulated below control assembler operations and is discussed in the section that
follows.
Table 5-17. Assembly Options
Option

Definition

-Wa,option

Pass options to the assembler.

5.7.9.1 Wa: Pass Option To The Assembler, Option

The -Wa,option option passes its option argument directly to the assembler. If option contains
commas, it is split into multiple options at the commas. For example -Wa,-a will pass the -a option
to the assembler, requesting that an assembly list file be produced.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 95

XC32 Compiler for PIC32M
Command-line Driver

5.7.10 Options for Linking
The options tabulated below control linker operations and are discussed in the sections that follow.
If any of the options -c, -S or -E are used, the linker will not be executed.
Table 5-18. Linking Options
Option

Definition

-Wl,--dinit-compression=level Linker option that applies optimizations of the specified level to the data initialization
template, which initializes objects and ramfunc functions in RAM.
--fill=options

A memory-fill option to be passed on to the linker.

-llibrary

Search the library named library when linking.

-nodefaultlibs

Do not use the standard system libraries when linking.

-mno-info-linker

Suppresses some linker advisory messages.

-nostdlib

Do not use the standard system start-up files or libraries when linking.

-relaxed-math

Link in a relaxed-compliance math library.

-s

Remove all symbol table and relocation information from the output.

-T script

Specify linker script.

-u symbol

Add an undefined symbol that will be present at link stage.

-Wl,option

Pass options to the linker.

-Xlinker option

Pass system-specific options to the linker.

5.7.10.1 Dinit-compression Option
The -Wl,--dinit-compression=level option enables optimization to the specified level of the
data initialization template, which initializes objects and ramfunc-attributed functions in RAM. See
18.2.9. Initialize Objects and RAM Functions for more information on the operation of the data
initialization template and record formats.
When the argument level is set to 0, the compiler uses the unoptimized legacy .dinit format
used by v4.10 and prior compilers.
Level 1 merges those initialized objects in contiguous memory under the same .dinit record.
Level 2 performs level 1 optimizations but additionally groups the same (non-zero) initial value in a
record of format #2 or #3 (as described in 18.2.9. Initialize Objects and RAM Functions), specifying
respectively a single 16- or 32-bit initial value that will be copied multiple times. A format #2 record
is chosen when there is a 16-bit repeated value in the initial value sequence (e.g. 0x13571357...); a
format #3 record is chosen when there is a 32-bit repeated value in the initial value sequence (e.g.
0x6701238067012380...). This option adds size to runtime startup code.
Level 3 can perform any of the optimizations available in the lower levels and can additionally
perform a PackBits-based run-length encoding compression to objects and ramfunc functions,
storing this in record format #4. The pack-bits decompression algorithm will only be used if it saves
an amount of space equal to or larger than the size of the decompression algorithm that needs to
be additionally linked in; however, any repeated values initialized (as described above) might add to
the size of the runtime startup routine. This is the default level if no option is specified.

5.7.10.2 Fill Option
The -fill option is used for filling unused (unspecified) memory locations in the output with a
known value. The usage of this option is:
--fill=[wwidth:]fill_expr@address:end_address

where the arguments have the following meaning:
wwidth

signifies the decimal width of each constant in the fill_expr and can range from 1
thru 9. If this width is not specified, the default value is two bytes. For example, --

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 96

XC32 Compiler for PIC32M
Command-line Driver
fill=w1:0x55@0:0xF with fill every unused byte between address 0 and 0xF with the byte
value 0x55, whereas --fill=w2:0x55@0:0xF with fill every unused byte between the same
addresses with the value 0x0055.
fill_expr

defines the values to fill and consists of const, which is a base value to place in the
first memory location and optionally with increment, which indicates how this base value
should change after each use. If the base value specifies more than one byte, these are
stored in little-endian byte order. These following show the possible fill expressions:
•

const fill memory with a repeating constant; i.e., --fill=0xBEEF@0-0x1FF fills unused
locations starting at address 0 with the values 0xBEEF, 0xBEEF, 0xBEEF, 0xBEEF, etc.

•

const+=increment fill memory with an incrementing constant; i.e., -fill=0xBEEF+=1@0:0x1FF attempts to fills with the values 0xBEEF, 0xBEF0, 0xBEF1,
0xBEF2, etc. Note that const increments with each location scanned, regardless of
whether that location is populated or unused.

•

const-=increment fill memory with a decrementing constant; i.e.,--fill=0xBEEF=0x10@0:0x1FF attempts to fills with the values 0xBEEF, 0xBEDF, 0xBECF, 0xBEBF, etc.
Note that const decrements with each location scanned, regardless of whether that
location is populated or unused.

•

const,const,...,const fill memory with a list of repeating constants; i.e., -fill=0xDEAD,0xBEEF@0:0x1FF fills with 0xDEAD, 0xBEEF, 0xDEAD, 0xBEEF, etc.

@address:end_ fills a specific address range with fill_expr; for example, -address
fill=0xBEEF@0x1000:0x1001 puts the byte value 0xEF at addresses 0x1000; and -fill=0xBEEF@0xF0:0xFF puts 0xBEEF in unused addresses between 0 and 0xFF, inclusive.

5.7.10.3 L: Specify Library File Option

The -llibrary option scans the named library file for unresolved symbols when linking.
When this option is used, the linker will search a standard list of directories for the library with the
name library.a. The directories searched include the standard system directories, plus any that
you specify with the -L option.

The linker processes libraries and object files in the order they are specified, so it makes a difference
where you place this option in the command. The options (and in this order), foo.o -llibz bar.o
search library libz.a after file foo.o but before bar.o. If bar.o refers to functions in libz.a,
those functions may not be loaded.
Normally the files found this way are library files (archive files whose members are object files). The
linker handles an archive file by scanning through it for members which define symbols that have
been referenced but not defined yet. But if the file found is an ordinary object file, it is linked in the
usual fashion.
The only difference between using an -l option (e.g., -lmylib) and specifying a file name (e.g.,
mylib.a) is that the compiler will search for a library specified using -l in several directories, as
specified by the -L option.
By default the linker is directed to search <install-path>/lib for libraries specified with the -l
option. This behavior can be overridden using environment variables.
See also the INPUT and OPTIONAL linker script directives.

5.7.10.4 Nodefaultlibs Option

The -nodefaultlibs option will prevent the standard system libraries being linked into the
project. Only the libraries you specify are passed to the linker.
The compiler may generate calls to memcmp, memset and memcpy, even when this option is specified.
As these symbols are usually resolved by entries in the standard compiler libraries, they should be
supplied through some other mechanism when this option is specified.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 97

XC32 Compiler for PIC32M
Command-line Driver

5.7.10.5 No-info-linker Option
The -mno-info-linker option suppresses some advisory messages issued by the linker. Such
messages might indicate the location of the linker script being used, for example.

5.7.10.6 Nostdlib Option
The -nostdlib option will prevent the standard system startup files and libraries being linked into
the project. No startup files and only the libraries you specify are passed to the linker.
The compiler may generate calls to memcmp(), memset() and memcpy(). These entries are usually
resolved by entries in standard compiler libraries. These entry points should be supplied through
some other mechanism when this option is specified.

5.7.10.7 Relaxed-math Option
The -relaxed-math option links in a relaxed-compliance math library.
This library provides alternative floating-point support routines that are faster and smaller than the
default math routines, but make some sacrifices in compliance. For instance, it does not do all of
the infinity, overflow and NaN checking, etc., of a fully-compliant library. It does not return all of
the detailed feedback from that checking. However, this reduced compliance is usually sufficient for
most applications.

5.7.10.8 S: Remove Symbol Information Option
The -s option removes all symbol table and relocation information from the output.

5.7.10.9 T: Use Linker Script Option
The -T script option specifies a linker script to use when linking.
Ordinarily, the linker will use a default device-specific linker script obtained from the compiler
installation or when building with the -mdfp option, a linker script packaged in the specified device
family pack (DFP). The -T option allows you to specify an application-specific linker script to use. The
MPLAB X IDE uses this option when you add a linker script to your project.

5.7.10.10 U: Add Undefined Symbol Option
The -u symbol option adds an undefined symbol that will be present at the link stage. To resolve
the symbol, the linker will search library modules for its definition, thus this option is useful if you
want to force a library module to be linked in. It is legitimate to use this option multiple times with
different symbols to force loading of additional library modules.

5.7.10.11 Wl: Pass Option To The Linker, Option
The -Wl,option option passes option to the linker application where it will be interpreted as a
linker option. If option contains commas, it is split into multiple options at the commas. Any linker
option specified will be added to the default linker options passed by the driver and these will be
executed before the default options by the linker.

5.7.10.12 Xlinker Option
The -Xlinker option option pass option to the linker where it will be interpreted as a linker
option. You can use this to supply system-specific linker options that the compiler does not know
how to recognize.

5.7.11 Options for Directory Search
The options tabulated below control directories searched operations and are discussed in the
sections that follow.
Table 5-19. Directory Search Options
Option

Definition

-Bprefix

This option specifies where to find executables, libraries, include files and compiler data files.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 98

XC32 Compiler for PIC32M
Command-line Driver

...........continued
Option

Definition

-I dir

Add directory to search for header files.

-Idirafter dir

Add directory to search for header files after all other paths are exhausted.

-Iquote dir

Add directory to search for “quoted” header files before processing -I option directories.

-Ldir

Specify additional library search directories.

5.7.11.1 B: Specify Compiler Component Search Path Option
The -Bprefix option specifies a path where executables, libraries, include files and compiler data
files can be found.
The compiler driver runs one or more of the internal applications xc32-cpp, xc32-as and xc32ld. It tries prefix as a prefix for each application it tries to run.
For each application to be run, the compiler driver first tries adding prefix. If the application
cannot be found, the driver searches the search paths specified by the PATH environment variable
for the application.
If prefix specifies a directory name, this path also applies to libraries used by the linker, because
the driver translates this into -L options for the linker. This also applies to include file search paths,
because the compiler translates these options into -isystem options for the preprocessor. In this
case, the compiler appends include to the prefix.

5.7.11.2 I: Specify Include File Search Path Option
The -Idir option adds the directory dir to the head of the list of directories to be searched for
header files. A space may be present between the option and directory name.
The option can specify either an absolute or relative path and it can be used more than once if
multiple additional directories are to be searched, in which case they are scanned from left to
right. The standard system directories are searched after scanning the directories specified with this
option.
Under the Windows OS, the use of the directory backslash character may unintentionally form an
escape sequence. To specify an include file path that ends with a directory separator character and
which is quoted, use -I "E:\\", for example, instead of -I "E:\", to avoid the escape sequence
\“. Note that MPLAB X IDE will quote any include file path you specify in the project properties and
that search paths are relative to the output directory, not the project directory.
Note: Do not use this option to specify any MPLAB XC32 system include paths. The compiler drivers
automatically select the default language libraries and their respective include-file directory for you.
Manually adding a system include path may disrupt this mechanism and cause the incorrect files to
be compiled into your project, causing a conflict between the include files and the library. Note that
adding a system include path to your project properties has never been a recommended practice.

5.7.11.3 Idirafter Option
The -idirafter dir option adds the directory dir list of directories to be searched for header
files during preprocessing. The directory is searched only after all other search paths (including
the standard search directories as well as those specified by the -I and -Iquote options) have
been searched. If this option is used more than once, the directories they specify are searched in a
left-to-right order as they appear on the command line.

5.7.11.4 Iquote Option
The -iquote dir option adds the directory dir to the list of directories to be searched for header
files during preprocessing. Directories specified with this option apply only to the quoted form of
the directive, for example #include "file", and the directory is searched only after the current
working directory has been searched. If this option is used more than once, the directories they
specify are searched in a left-to-right order as they appear on the command line.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 99

XC32 Compiler for PIC32M
Command-line Driver

5.7.11.5 L: Specify Library Search Path Option
The -Ldir option allows you to specify an additional directory to be searched for library files that
have been specified by using the -l option. The compiler will automatically search standard library
locations, so you only need to use this option if you are linking in your own libraries.

5.7.12 Options for Code Generation Conventions
The options tabulated below control machine-independent conventions used when generating code
and are discussed in the sections that follow.
Table 5-20. Code Generation Convention Options
Option

Definition

-fargument-alias
-fargument-noalias

Specify the possible relationships among parameters and between parameters and global
data.

-fargument-noalias-global
-fcall-saved-reg

Treat reg as an allocatable register saved by functions.

-fcall-used-reg

Treat reg as an allocatable register that is clobbered by function calls.

-f[no-]common

Controls the placement of global variables defined without an initializer.

-f[no-]exceptions

Generate extra code to propagate exceptions.

-ffixed-reg

Treatreg as a fixed register that will not be used in code.

-f[no-]ident

Ignore the #ident directive.

-fpack-struct

Pack all structure members together without memory holes.

-f[no-]pcc-struct- return Return short struct and union values in memory, rather than in registers.
-f[no-]short-enums

Specify the size of enum types.

-f[no-]verbose-asm

Put extra commentary information in the generated assembly code to make it more
readable.

5.7.12.1 Argument-alias Options
This set of options specify the possible relationships among parameters, and between parameters
and global data.
The -fargument-alias option specifies that parameters might alias each other and might alias
global storage.
The -fargument-noalias option specifies that parameters do not alias each other, but they might
alias global storage.
The -fargument-noalias-global option specifies that parameters do not alias each other and
do not alias global storage.
Each language automatically uses the appropriate option is required by the language standard, so
you should not need to use these options yourself.

5.7.12.2 Call-saved-reg Option
The -fcall-saved-reg option will have the compiler treat the register named reg as an
allocatable register that is saved by functions. Functions compiled with this option in effect save
and restore the specified register if they use it.
The register specified in this option might be allocated for objects or temporary objects whose
duration extends over a function call.
It is an error to specify the Frame Pointer or Stack Pointer registers with this option. Use of this
option to specify other registers that have fixed pervasive roles in the machine’s execution model
might result in code failure. The same is also true if this option specifies a register in which function
values are returned.
This option should be used consistently with all project modules.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 100

XC32 Compiler for PIC32M
Command-line Driver

5.7.12.3 Call-used-reg Option

The -fcall-used-reg option will have the compiler treat the register named reg as an allocatable
register that is clobbered by functions. Functions compiled with this option in effect will not save
and restore the specified register if they use it, meaning that the register's content might be lost.
The register specified in this option might be allocated for objects or temporary objects whose
duration extends over a function call.
It is an error to specify the Frame Pointer or Stack Pointer registers with this option. Use of this
option to specify other registers that have fixed pervasive roles in the machine’s execution model
might result in code failure. The same is also true if this option specifies a register in which function
values are returned.
This option should be used consistently with all project modules.

5.7.12.4 Common Option

The -fcommon option tells the compiler to allow merging of tentative definitions by the linker. This is
the default action if no option is specified.
The definition for a file-scope object without a storage class specifier or initializer is known as a
tentative definition in the C standard. Such definitions are treated as external references when the
-fcommon option is specified and will be placed in a common block. As such, if another compilation
unit has a full definition for an object with the same name, the definitions are merged and storage
allocated. If no full definition can be found, the linker will allocate unique memory for the object
tentatively defined. Tentative definitions are thus distinct from declarations of a variable with the
extern keyword, which never allocate storage.
In the following code example:
extra.c
int a = 42;

/* full definition */

main.c
int a;
/* tentative definition */
int main(void) {
...
}

The object a is defined in extra.c and tentatively defined in main.c. Such code will build when
using the -fcommon option, since the linker will resolve the tentative definition for a with the full
definition in extra.c.
The -fno-common form of this option inhibits the merging of tentative definitions by the linker,
treating tentative definitions as a full definition if the end of the translation unit is reached and no
definition has appeared with an initializer. Building the above code, for example, would result in a
multiple definition of 'a' error, since the tentative definition and initialized definition would
both attempt to allocate storage for the same object. If you are using this form of the option, the
definition of a in main.c should be written extern int a; to allow the program to build.

5.7.12.5 Exceptions option

The -fexceptions option generates extra code needed to propagate exceptions. This option might
need to be specified when compiling C code that needs to inter-operate properly with exception
handlers written in C++.
The -fno-exceptions form of this option disables exception handling. This is the default action if
no option is specified.
Ensure that the same form of this option is specified at compile time for all modules and at link
time. When used additionally at link time, the option allows the linker to select a variant of the
libraries that are built with C++ exceptions disabled, reducing code size.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 101

XC32 Compiler for PIC32M
Command-line Driver

5.7.12.6 Fixed-reg Option

The -ffixed-reg option has the compiler treat the register named reg as a fixed register. Code
generated by the compiler will never make use of this register (except in cases where the register
has some fixed role, like as a Stack Pointer or Frame Pointer).
The register name can be a register number, for example -ffixed-3 to refer to r3.

5.7.12.7 Ident option

The -fident option forces the compiler to process any occurrence of the #ident directive, which
places the string constant argument to the directive into a special segment of the object file. This is
the default action if no option is specified.
The -fno-ident form of this option forces the compiler to ignore any occurrence of this directive.

5.7.12.8 Pack-struct Option

The -fpack-struct option packs all structure members together without padding bytes between
them. Typically, this option is not used, since the structure members might become unaligned and
the code required to access them becomes sub-optimal. Additionally, the offsets of members within
such structures won’t agree with those for unpacked (aligned) structures in system libraries.
The -fno-pack-struct option chooses a structure arrangement that will produce optimal code,
potentially placing padding bytes between members to ensure they are properly aligned for the
device. This is the default action if no option is specified.

5.7.12.9 Pcc-struct-return Option

The -fpcc-struct-return option forces the compiler to return small struct and union objects
(whose size and alignment match that of an integer type) in memory, rather than in registers. This
convention is less efficient but allows compatibility with files compiled using other compilers.
The -fno-pcc-struct-return form of this option returns small struct and union objects in
registers. This is the default action no option is specified.

5.7.12.10 Short-enums Option

The -fshort-enums option allocates the smallest possible integer type (with a size of 1, 2, or 4
bytes) to an enum such that the range of possible values can be held.

The -fno-short-enums form of this option forces each enum type to be 4-bytes wide (the size of
the int type). This is the default action if no option is specified. When using this option, generated
code is not binary compatible with code generated without the option.

5.7.12.11 Verbose-asm Option

The -fno-verbose-asm option places extra commentary information in the generated assembly
code to make it more readable.

The -fno-verbose-asm form of this option omits this extra information and is useful when
comparing two assembler files. This is the default action if no option is specified.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 102

XC32 Compiler for PIC32M
ANSI C Standard Issues

6.

ANSI C Standard Issues
This compiler is a freestanding implementation that conforms to the ISO/IEC 9899:1990 Standard
(referred to as the C90 standard) as well the ISO/IEC 9899:1999 Standard (C99) for programming
languages, unless otherwise stated.

6.1

Divergence Fom the ANSI C Standard
There are no divergences from the ANSI C standard.

6.2

Extensions to the ANSI C Standard
C/C++ code for the MPLAB XC32 C/C++ Compiler differs from the ANSI C standard in these areas:
keywords, statements and expressions.

6.2.1

Keyword Differences
The new keywords are part of the base GCC implementation and the discussions in the referenced
sections are based on the standard GCC documentation, tailored for the specific syntax and
semantics of the 32-bit compiler port of GCC.

6.2.2

•

Specifying Attributes of Variables – 9.11. Variable Attributes

•

Specifying Attributes of Functions – 16.2. Function Attributes and Specifiers

•

Inline Functions – 16.9. Inline Functions

•

Variables in Specified Registers – 9.11. Variable Attributes

•

Complex Numbers – 9.7. Complex Data Types

•

Double-Word Integers – 9.3. Integer Data Types

•

Referring to a Type with typeof – 9.9. Standard Type Qualifiers

Statement Differences
The statement differences are part of the base GCC implementation, and the discussions in the
referenced sections are based on the standard GCC documentation, tailored for the specific syntax
and semantics of the 32-bit compiler port of GCC.

6.2.3

•

Labels as Values – 13.3. Labels as Values

•

Conditionals with Omitted Operands – 13.4. Conditional Operator Operands

•

Case Ranges – 13.5. Case Ranges

Expression Differences
Expression differences are:
Binary constants – 9.8. Constant Types and Formats.

6.3

Implementation-Defined Behavior
Certain features of the ANSI C standard have implementation-defined behavior. This means that
the exact behavior of some C code can vary from compiler to compiler. The exact behavior of the
MPLAB XC32 C/C++ Compiler is detailed throughout this documentation, and is fully summarized in
26. C Implementation-Defined Behavior.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 103

XC32 Compiler for PIC32M
Device-Related Features

7.

Device-Related Features
The MPLAB XC32 C/C++ Compiler supports a number of special features and extensions to the C/C+
+ language which are designed to ease the task of producing ROM-based applications. This chapter
documents the special language features which are specific to these devices.

7.1

Device Support
MPLAB XC32 C/C++ Compiler aims to support all PIC32 devices. However, new devices in these
families are frequently released.

7.2

Device Header Files
There is one header file that is recommended be included into each source file you write. The file is
<xc.h> and is a generic file that will include other device-specific header files when you build your
project.
Inclusion of this file will allow access to SFRs via special variables, as well as #defineS which allow
the use of conventional register names from within assembly language files.

7.2.1

CP0 Register Definitions Header File
The CP0 register definitions header file (cp0defs.h) is a file that contains definitions for the CP0
registers and their fields. In addition, it contains macros for accessing the CP0 registers. These
macros are defined in cp0defs.h so the application code should #include <cp0defs.h>.
The CP0 register definitions header file is located in the pic32mx/include directory of your
compiler installation directory.
Some compiler-specific header files are located in the ./lib/gcc/pic32mx/4.8.3/includefixed/limits.h directory rather than in /pic32mx/include.
The CP0 register definitions header file is automatically included when you include the generic
device header file, xc.h.
The CP0 register definitions header file was designed to work with either Assembly or C/C++ files.
The CP0 register definitions header file is dependent on macros defined within the processor
generic header file.

7.3

Configuration Bit Access
The #pragma config directive specifies the Configuration Words to be programmed into the
device running the application. This pragma can be used with either C or C++ programs.
All 32-bit target devices have several Configuration Words. The bits within these words control
fundamental device operation, such as the oscillator mode, watchdog timer, programming mode
and code protection. Failure to correctly set these bits may result in code failure, or a non-running
device.
The config pragma has the following general form:
#pragma config setting = value

where setting is a configuration word bit-field name (e.g., WDT_ENABLE) and value can be either a
textual description of the desired state (e.g., CLEAR) or a numerical value, as required by the setting.
Multiple pragmas may be used to incrementally specify the complete device state; however, more
than one comma-separated setting-value pair may be specified with each pragma.
Refer to the PIC32ConfigSet.html file, located in Program Files/ Microchip/ <installdir>/<version>/docs/PIC32ConfigSet.html for the setting/value pairs relevant for your target
device.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 104

XC32 Compiler for PIC32M
Device-Related Features

Configuration settings may be specified with multiple #pragma config directives. The compiler
verifies that the configuration settings specified are valid for the processor for which it is compiling.
If a given setting in the Configuration word has not been specified in any #pragma config
directive, the bits associated with that setting default to the unprogrammed value. Configuration
settings should be specified in only a single translation unit (a C/C++ file with all of its include files
after preprocessing).
For each Configuration word for which a setting is specified with the #pragma config directive,
the compiler generates a read-only data section named .config_address, where address is
the hexadecimal representation of the address of the Configuration word. For example, if a
configuration setting was specified for the Configuration word located at address 0xBFC02FFC, a
read-only data section named .config_BFC02FFC would be created.

7.3.1

Syntax
The following shows the meta syntax notation for the different forms the pragma may take.
pragma-config-directive:
# pragma config setting-list
setting-list:
setting
| setting-list, setting
setting:
setting-name = value-name

The setting-name and value-name are device specific and can be determined by using the
PIC32ConfigSet.html document located in the installation directory, docs folder.
All #pragma config directives should be placed outside of a function definition as they do not
define executable code.
PIC32MZ config pragmas include config_alt, config_bf1, config_abf1, config_bf2, and
config_abf2 pragmas to support placing configuration bit values in the alternate, boot flash
1, alternate boot flash 1, boot flash 2, and alternate boot flash 2 PIC32MZ memory regions,
respectively. (Example: #pragma config_bf2 FWDTEN=off)
Integer values for config pragmas can be set using the config and config_region pragmas.
(Examples: #pragma config_bf2 TSEQ = 1 and #pragma config USERID = 0x1234u)

7.3.2

Example
The following example shows how the #pragma config directive might be utilized. The example
does the following:
•

Enables the Watchdog Timer

•

Sets the Watchdog Postscaler to 1:128

•

Selects the HS Oscillator for the Primary Oscillator
#pragma config FWDTEN = ON, WDTPS = PS128
#pragma config POSCMOD = HS
...
int main (void)
{
...
}

7.4

ID Locations
User-defined ID locations are implemented in one Configuration Word. These locations should be
programmed using the #pragma config directive. See 7.3. Configuration Bit Access.
Example: #pragma config USERID=0x1234.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 105

XC32 Compiler for PIC32M
Device-Related Features

7.5

Using SFRs From C Code
The Special Function Registers (SFRs) are registers which control aspects of the MCU operation or
that of peripheral modules on the device. These registers are memory mapped, which means that
they appear at specific addresses in the device memory map. With some registers, the bits within
the register control independent features.
Memory-mapped SFRs are accessed by special C variables that are placed at the addresses of the
registers and use special attributes. These variables can be accessed like any ordinary C variable so
that no special syntax is required to access SFRs.
The SFR variables are predefined in header files and will be accessible once the <xc.h> header file
(see 7.2. Device Header Files) has been included into your source code. Structures are also defined
by these header files to allow access to bits within the SFR.
The names given to the C variables, which map over the registers and bit variables, or bit fields,
within the registers are based on the names specified in the device data sheet. The names of the
structures that hold the bit fields will typically be those of the corresponding register followed by
bits. For example, the following shows code that includes the generic header file, clears PORTB as a
whole and sets bit 2 of PORTB using the structure/bit field definitions
Note: The symbols PORTB and PORTBbits refer to the same register and resolve to the same
address. Writing to one register will change the values held by both.
#include <xc.h>
int main(void)
{
PORTBCLR = 0xFFFFu;
PORTBbits.RB2 = 1;
PORTBSET= _PORTB_RB2_MASK;
}

For use with assembly, the PORTB register is declared as: .extern PORTB.
To confirm the names that are relevant for the device you are using, check the device specific
header file that <xc.h> will include for the definitions of each variable. These files will be located
in the pic32mx/include/proc directory of the compiler and will have a name that represents the
device. There is a one-to-one correlation between device and header file names that will be included
by <xc.h>, for example, when compiling for a PIC32MX360F512L device, the <xc.h> header file will
include <proc/p32mx360f512l.h>. Remember that you do not need to include this chip-specific
file into your source code; it is automatically included by <xc.h>.
Some of the PIC32 SFRs have associated registers that allow the bits within the SFR to be set, cleared
or toggled atomically. For example, the PORTB SFR has the write-only registers PORTBSET, PORTBCLR
and PORTBINV associated with it. Writing a '1' to a bit location in these registers sets, clears or
toggles, respectively, the corresponding bit in the PORTB SFR. So to set bit 1 in PORTB, you can use
the following code:
PORTBSET = 0x2;
or alternatively, using macros provided in the device header files:
PORTBSET = _PORTB_RB1_MASK;

7.5.1

CP0 Register Definitions
When the CP0 register definitions header file is included from an Assembly file, the CP0 registers are
defined as:
#define _CP0_register_name $register_number, select_number

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 106

XC32 Compiler for PIC32M
Device-Related Features

For example, the IntCtl register is defined as:
#define _CP0_INTCTL $12, 1

When the CP0 register definitions header file is included from a C file, the CP0 registers and selects
are defined as:
#define _CP0_register_name register_number
#define _CP0_register_name_SELECT select_number

For example, the IntCtl register is defined as:
#define _CP0_INTCTL 12
#define _CP0_INTCTL_SELECT 1

7.5.2

CP0 Register Field Definitions
When the CP0 register definitions header file is included from either an Assembly or a C/C++ file,
three #defines exist for each of the CP0 register fields.
_CP0_register_name_field_name_POSITION – the starting bit location
_CP0_register_name_field_name_MASK – the bits that are part of this field are set
_CP0_register_name_field_name_LENGTH – the number of bits that this field occupies
For example, the vector spacing field of the IntCtl register has the following defines:
#define _CP0_INTCTL_VS_POSITION 0x00000005
#define _CP0_INTCTL_VS_MASK
0x000003E0
#define _CP0_INTCTL_VS_LENGTH
0x00000005

7.5.3

CP0 Access Macros
When the CP0 register definitions header file is included from a C file, CP0 access macros are
defined. Each CP0 register may have up to six different access macros defined:

7.5.4

_CP0_GET_register_name ()

Returns the value for register, register_name.

_CP0_SET_register_name (val)

Sets the register, register_name, to val, and returns void.
Only defined for registers that contain a writable field.

_CP0_XCH_register_name (val)

Sets the register, register_name, to val, and returns
the previous register value. Only defined for registers that
contain a writable field.

_CP0_BIS_register_name (set)

Sets the register, register_name, to (reg |= set), and
returns the previous register value. Only defined for registers
that contain writable bit fields.

_CP0_BIC_register_name (clr)

Sets the register, register_name, to (reg &= ~clr), and
returns the previous register value. Only defined for registers
that contain writable bit fields.

_CP0_BCS_register_name (clr, set)

Sets the register, register_name, to (reg = (reg &
~clr) | set), and returns the previous register value. Only
defined for registers that contain writable bit fields.

Address Translation Macros
System code may need to translate between virtual and physical addresses, as well as between
kernel segment addresses. The macros are defined in sys/kmem.h so the application code
should #include <sys/kmem.h>. Macros are provided to make these translations easier and to
determine the segment an address is in.
KVA_TO_PA(v)

Translate a kernel virtual address to a physical address.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 107

XC32 Compiler for PIC32M
Device-Related Features
PA_TO_KVA0(pa)

Translate a physical address to a KSEG0 virtual address.

PA_TO_KVA1(pa)

Translate a physical address to a KSEG1 virtual address.

KVA0_TO_KVA1(v)

Translate a KSEG0 virtual address to a KSEG1 virtual address.

KVA1_TO_KVA0(v)

Translate a KSEG1 virtual address to a KSEG0 virtual address.

IS_KVA(v)

Evaluates to 1 if the address is a kernel segment virtual address, zero
otherwise.

IS_KVA0(v)

Evaluate to 1 if the address is a KSEG0 virtual address, zero otherwise.

IS_KVA1(v)

Evaluate to 1 if the address is a KSEG1 virtual address, zero otherwise.

IS_KVA01(v)

Evaluate to 1 if the address is either a KSEG0 or a KSEG1 virtual address, zero
otherwise.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 108

XC32 Compiler for PIC32M
Code Coverage

8.

Code Coverage
After purchase of the Analysis Tool Suite License (SW006027-2), the compiler's code coverage
feature can be used to facilitate analysis of the extent to which a project’s source code has been
executed.
When enabled, this feature instruments the project’s program image with small assembly
sequences. When the program image is executed, these sequences record the execution of the
code that they represent in reserved areas of device RAM. The records stored in the device can be
later analyzed to determine which parts of a project’s source code have been executed. Compilersupplied library code is not instrumented.
When code coverage is enabled, the compiler will execute an external tool called xc-ccov to
determine the most efficient way to instrument the project. The tool considers the program’s basic
blocks, which can be considered as sequences of one or more instructions with only one entry point,
located at the start of the sequence and only one exit located at the end. Not all of these blocks
need to be instrumented, with the tool determining the minimum set of blocks that will allow the
program to be fully analyzed.
Use the -mcodecov option to enable code coverage in the compiler. The preprocessor macro
__CODECOV will be defined once the feature is enabled.
All compiler options you use to build the project, when using code coverage, are significant, as these
will affect the program image that is ultimately instrumented. To ensure that the analysis accurately
reflects the shipped product, the build options should be the same as those that will be used for the
final release build.
If code coverage is enabled, there will be 1 bit of RAM allocated per instrumented basic block, which
will increase the data memory requirement of the project.
There is a small sequence of assembly instructions inserted into each instrumented basic block to
set the corresponding coverage bit.
The instrumented project code must be executed for code coverage data to be generated and this
execution will be fractionally slower due to the added assembly sequences. Provide the running
program with input and stimulus that should exercise all parts of the program code, so that
execution of all parts of the program source can be recorded.
Code coverage data can be analyzed in the MPLAB X IDE. Information in the ELF file produced by the
compiler will allow the plugin to locate and read the device memory containing the code coverage
results and display this in a usable format. See Microchip's Analysis Tool Suite License webpage for
further information on the code coverage feature and other analysis tools.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 109

XC32 Compiler for PIC32M
Supported Data Types and Variables

9.

Supported Data Types and Variables
The MPLAB XC32 C/C++ Compiler supports a variety of data types and attributes. These data types
and variables are discussed here. For information on where variables are stored in memory, see
10. Memory Allocation and Access.

9.1

Identifiers
A C/C++ variable identifier (the following is also true for function identifiers) is a sequence of letters
and digits, where the underscore character “_” counts as a letter. Identifiers cannot start with a digit.
Although they may start with an underscore, such identifiers are reserved for the compiler’s use
and should not be defined by your programs. Such is not the case for assembly domain identifiers,
which often begin with an underscore
Identifiers are case sensitive, so main is different than Main.
All characters are significant in an identifier, although identifiers longer than 31 characters in length
are less portable.

9.2

Data Representation
The compiler stores multibyte values in little-endian format. That is, the Least Significant Byte is
stored at the lowest address.
For example, the 32-bit value 0x12345678 would be stored at address 0x100 as:

9.3

Address

0x100

0x101

0x102

0x103

Data

0x78

0x56

0x34

0x12

Integer Data Types
Integer values in the compiler are represented in 2’s complement and vary in size from 8 to 64 bits.
These values are available in compiled code via 9.3.2. limits.h.

9.3.1

Type

Bits

Min

Max

char, signed char

8

-128

127

unsigned char

8

0

255

short, signed short

16

-32768

32767

unsigned short

16

0

65535

int, signed int, long, signed long

32

-231

231-1

unsigned int, unsigned long

32

0

232-1

long long, signed long long

64

-263

263-1

unsigned long long

64

0

264-1

Signed and Unsigned Character Types
By default, values of type plain char are signed values. This behavior is implementation-defined
by the C standard, and some environments (notably, PowerPC) define a plain C/C++ char value to
be unsigned. The command line option -funsigned-char can be used to set the default type to
unsigned for a given translation unit.

9.3.2

limits.h
The limits.h header file defines the ranges of values which can be represented by the integer
types.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 110

XC32 Compiler for PIC32M
Supported Data Types and Variables

9.4

Macro Name

Value

Description

CHAR_BIT

8

The size, in bits, of the smallest non-bit
field object.

SCHAR_MIN

-128

The minimum value possible for an
object of type signed char.

SCHAR_MAX

127

The maximum value possible for an
object of type signed char.

UCHAR_MAX

255

The maximum value possible for an
object of type unsigned char.

CHAR_MIN

-128 (or 0, see 9.3.1. Signed and
Unsigned Character Types)

The minimum value possible for an
object of type char.

CHAR_MAX

127 (or 255, see 9.3.1. Signed and
Unsigned Character Types)

The maximum value possible for an
object of type char.

MB_LEN_MAX

16

The maximum length of multibyte
character in any locale.

SHRT__MIN

-32768

The minimum value possible for an
object of type short int.

SHRT_MAX

32767

The maximum value possible for an
object of type short int.

USHRT_MAX

65535

The maximum value possible for an
object of type unsigned short int.

INT_MIN

-231

The minimum value possible for an
object of type int.

INT_MAX

231-1

The maximum value possible for an
object of type int.

UINT_MAX

232-1

The maximum value possible for an
object of type unsigned int.

LONG_MIN

-231

The minimum value possible for an
object of type long.

LONG_MAX

231-1

The maximum value possible for an
object of type long.

ULONG_MAX

232-1

The maximum value possible for an
object of type unsigned long.

LLONG_MIN

-263

The minimum value possible for an
object of type long long.

LLONG_MAX

263-1

The maximum value possible for an
object of type long long.

ULLONG_MAX

264-1

The maximum value possible for an
object of type unsigned long long.

Floating-Point Data Types
The compiler uses 32- and 64-bit forms of the IEEE-754 floating-point format to store floating-point
values. The implementation limits applicable to a translation unit are contained in the float.h
header.
Important: Some target PIC32M devices implement a Floating-point Unit (FPU).
The compiler implements certain features, described in this guide, to support this
hardware.
The table below shows the data types and their corresponding size and arithmetic type.
Type

Bits

float

32

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 111

XC32 Compiler for PIC32M
Supported Data Types and Variables

...........continued
Type

Bits

double

64

long double

64

Variables may be declared using the float, double and long double keywords, respectively, to
hold values of these types. Floating-point types are always signed and the unsigned keyword is
illegal when specifying a floating-point type. All floating-point values are represented in little endian
format with the Least Significant Byte (LSB) at the lower address.
This format is described in the table below, where:
•

Sign is the sign bit which indicates if the number is positive or negative.

•

For 32-bit floating-point values, the exponent is 8 bits which is stored as excess 127 (i.e., an
exponent of 0 is stored as 127).

•

For 64-bit floating-point values, the exponent is 11 bits which is stored as excess 1023 (i.e., an
exponent of 0 is stored as 1023).

•

Mantissa is the mantissa, which is to the right of the radix point. There is an implied bit to the left
of the radix point which is always 1 except for a zero value, where the implied bit is zero. A zero
value is indicated by a zero exponent.

The value of this number for 32-bit floating-point values is:
(-1)sign x 2(exponent-127) x 1. mantissa
and for 64-bit values
(-1)sign x 2(exponent-1023) x 1. mantissa.
In the following table, examples of the 32- and 64-bit IEEE 754 formats are shown. Note that the
Most Significant bit of the mantissa column (that is, the bit to the left of the radix point) is the
implied bit, which is assumed to be 1 unless the exponent is zero (in which case the float number is
zero).
Table 9-1. Floating-Point Format Example IEEE 754
Format

Number

Biased
Exponent

1.mantissa

Decimal

32-bit

0x7DA6B69C

11111011b
(251)

1.01001101011011010011100b
(1.3024477959)

2.770000117e+3
7
—

64-bit

0x47B4D6D3713 10001111011b
1A DE
(1147)

1.0100110101101101001101110001001100011010011011 2.77e+37
011110b
—
(1.3024477407110946)

The example in the table can be calculated manually as follows.
The sign bit is zero; the biased exponent is 251, so the exponent is 251-127=124. Take the binary
number to the right of the decimal point in the mantissa. Convert this to decimal and divide it by
223 where 23 is the number of bits taken up by the mantissa, to give 0.302447676659. Add 1 to this
fraction. The floating-point number is then given by:
-10×2124×1.302447676659
which becomes:
1×2.126764793256e+37×1.302447676659
which is approximately equal to:
2.77000e+37

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 112

XC32 Compiler for PIC32M
Supported Data Types and Variables

Binary floating-point values are sometimes misunderstood. It is important to remember that not
every floating-point value can be represented by a finite-sized floating-point number. The size of
the exponent in the number dictates the range of values that the number can hold, and the size of
the mantissa relates to the spacing of each value that can be represented exactly. Thus the 64-bit
floating-point format allows for values with a larger range of values and that can be more accurately
represented.
So, for example, if you are using a 32-bit wide floating-point type, it can exactly store the value
95000.0. However, the next highest number it can represent is (approximately) 95000.00781 and
it is impossible to represent any value in between these two in such a type as it will be rounded.
This implies that C/C++ code which compares floating-point type may not behave as expected. For
example:
volatile float myFloat;
myFloat = 95000.006;
if(myFloat == 95000.007) // value will be rounded
LATA++;
// this line will be executed!

in which the result of the if() expression will be true, even though it appears the two values being
compared are different.
The characteristics of the floating-point formats are summarized in Table 8-3. The symbols in this
table are preprocessor macros which are available after including <float.h> in your source code.
Two sets of macros are available for float and double types, where XXX represents FLT and DBL,
respectively. So, for example, FLT_MAX represents the maximum floating-point value of the float
type. DBL_MAX represents the same values for the double type. As the size and format of floatingpoint data types are not fully specified by the ANSI Standard, these macros allow for more portable
code which can check the limits of the range of values held by the type on this implementation.
Table 9-2. Ranges of Floating-Point Type Values

9.5

Symbol

Meaning

32-bit Value

64-bit Value

XXX_RADIX

Radix of exponent representation

2

2

XXX_ROUNDS

Rounding mode for addition

1

XXX_MIN_EXP

Min. n such that FLT_RADIXn-1 is a normalized -125
float value

-1021

XXX_MIN_10_EXP

Min. n such that 10n is a
normalized float value

-37

-307

XXX_MAX_EXP

Max. n such that FLT_RADIXn-1 is a normalized 128
float value

1024

XXX_MAX_10_EXP

Max. n such that 10n is a
normalized float value

38

308

XXX_MANT_DIG

Number of FLT_RADIX mantissa digits

24

53

XXX_EPSILON

The smallest number which added to 1.0 does 1.1920929e-07
not yield 1.0

2.2204460492503131e16

Structures and Unions
MPLAB XC32 C/C++ Compiler supports struct and union types. Structures and unions only differ
in the memory offset applied to each member.
These types will be at least 1 byte wide. Bit fields are fully supported.
Structures and unions may be passed freely as function arguments and function return values.
Pointers to structures and unions are fully supported.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 113

XC32 Compiler for PIC32M
Supported Data Types and Variables

9.5.1

Structure and Union Qualifiers
The MPLAB XC32 C/C++ Compiler supports the use of type qualifiers on structures. When a qualifier
is applied to a structure, all of its members will inherit this qualification. In the following example the
structure is qualified const.
const struct {
int number;
int *ptr;
} record = { 0x55, &i };

In this case, the entire structure will be placed into the program memory and each member will be
read-only. Remember that all members are usually initialized if a structure is const as they cannot
be initialized at runtime.
If the members of the structure were individually qualified const, but the structure was not, then
the structure would be positioned into RAM, but each member would be read-only. Compare the
following structure with the above.
struct {

const int number;
int * const ptr;
} record = { 0x55, &i};

9.5.2

Bit Fields in Structures
MPLAB XC32 C/C++ Compiler fully supports bit fields in structures.
Bit fields are always allocated within 8-bit storage units, even though it is usual to use the type
unsigned int in the definition. Storage units are aligned on a 32-bit boundary, although this can
be changed using the packed attribute.
The first bit defined will be the Least Significant bit of the word in which it will be stored. When a
bit field is declared, it is allocated within the current 8-bit unit if it will fit; otherwise, a new byte is
allocated within the structure. Bit fields can never cross the boundary between 8-bit allocation units.
For example, the declaration:
struct {

} foo;

unsigned
unsigned
unsigned

lo : 1;
dummy : 6;
hi : 1;

will produce a structure occupying 1 byte.
Unnamed bit fields may be declared to pad out unused space between active bits in control
registers. For example, if dummy is never referenced, the structure above could have been declared
as:
struct {

} foo;

unsigned
unsigned
unsigned

lo : 1;
: 6;
hi : 1;

A structure with bit fields may be initialized by supplying a comma-separated list of initial values for
each field. For example:
struct {

unsigned
unsigned
unsigned
} foo = {1, 8, 0};

lo : 1;
mid : 6;
hi : 1;

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 114

XC32 Compiler for PIC32M
Supported Data Types and Variables

Structures with unnamed bit fields may be initialized. No initial value should be supplied for the
unnamed members, for example:
struct {
unsigned
unsigned
unsigned
} foo = {1, 0};

lo
hi

: 1;
: 6;
: 1;

will initialize the members lo and hi correctly.
The MPLAB XC compiler supports anonymous unions. These are unions with no identifier and
whose members can be accessed without referencing the enclosing union. These unions can be
used when placing inside structures. For example:
struct {

};
} aaa;

union {
int x;
double y;

int main(void)
{
aaa.x = 99;
// ...}

Here, the union is not named and its members accessed as if they are part of the structure.
Anonymous unions are not part of any C Standard and so their use limits the portability of any code.

9.6

Pointer Types
There are two basic pointer types supported by the MPLAB XC32 C/C++ Compiler: data pointers and
function pointers. Data pointers hold the addresses of variables which can be indirectly read, and
possible indirectly written, by the program. Function pointers hold the address of an executable
function which can be called indirectly via the pointer.

9.6.1

Combining Type Qualifiers and Pointers
It is helpful to first review the ANSI C/C++ standard conventions for definitions of pointer types.
Pointers can be qualified like any other C/C++ object, but care must be taken when doing so as there
are two quantities associated with pointers. The first is the actual pointer itself, which is treated like
any ordinary C/C++ variable and has memory reserved for it. The second is the target, or targets,
that the pointer references, or to which the pointer points. The general form of a pointer definition
looks like the following:
target_type_&_qualifiers * pointer’s_qualifiers pointer’s_name;
Any qualifiers to the right of the * (that is, next to the pointer’s name) relate to the pointer variable
itself. The type and any qualifiers to the left of the * relate to the pointer’s targets. This makes sense
since it is also the * operator that dereferences a pointer, which allows you to get from the pointer
variable to its current target.
Here are three examples of pointer definitions using the volatile qualifier. The fields in the
definitions have been highlighted with spacing:
volatile int *
int
* volatile
volatile int * volatile

vip ;
ivp ;
vivp ;

The first example is a pointer called vip. It contains the address of int objects that are qualified
volatile. The pointer itself — the variable that holds the address — is not volatile; however, the
objects that are accessed when the pointer is dereferenced are treated as being volatile. In other
words, the target objects accessible via the pointer may be externally modified.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 115

XC32 Compiler for PIC32M
Supported Data Types and Variables

The second example is a pointer called ivp which also contains the address of int objects. In
this example, the pointer itself is volatile, that is, the address the pointer contains may be
externally modified; however, the objects that can be accessed when dereferencing the pointer are
not volatile.
The last example is of a pointer called vivp which is itself qualified volatile, and which also holds
the address of volatile objects.
Bear in mind that one pointer can be assigned the addresses of many objects; for example, a
pointer that is a parameter to a function is assigned a new object address every time the function is
called. The definition of the pointer must be valid for every target address assigned.
Note: Care must be taken when describing pointers. Is a “const pointer” a pointer that points to
const objects, or a pointer that is const itself? You can talk about “pointers to const” and “const
pointers” to help clarify the definition, but such terms may not be universally understood.

9.6.2

Data Pointers
Pointers in the compiler are all 32 bits in size. These can hold an address which can reach all
memory locations.

9.6.3

Function Pointers
The MPLAB XC compiler fully supports pointers to functions, which allows functions to be called
indirectly. These are often used to call one of several function addresses stored in a user-defined
C/C++ array, which acts like a lookup table.
Function pointers are always 32 bits in size and hold the address of the function to be called.
Any attempt to call a function with a function pointer containing NULL will result in an ifetch Bus
Error.

9.6.4

Special Pointer Targets
Pointers and integers are not interchangeable. Assigning an integer constant to a pointer will
generate a warning to this effect. For example:
const char * cp = 0x123; // the compiler will flag this as bad code
There is no information in the integer constant, 0x123, relating to the type or size of the destination.
This code is also not portable and there is a very good chance of code failure if pointers are assigned
®
integer addresses and dereferenced, particularly for PIC devices that have more than one memory
space.
Always take the address of a C/C++ object when assigning an address to a pointer. If there is no
C/C++ object defined at the destination address, then define or declare an object at this address
which can be used for this purpose. Make sure the size of the object matches the range of the
memory locations that can be accessed.
For example, a checksum for 1000 memory locations starting at address 0xA0001000 is to be
generated. A pointer is used to read this data. You may be tempted to write code such as:
int * cp;
cp = 0xA0001000;

// what resides at 0xA0001000???

and increment the pointer over the data. A much better solution is this:
int * cp;
int __attribute__((address(0xA0001000))) inputData [1000];
cp = &inputData;
// cp is incremented over inputData and used to read values there

In this case, the compiler can determine the size of the target and the memory space. The array size
and type indicates the size of the pointer target.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 116

XC32 Compiler for PIC32M
Supported Data Types and Variables

Take care when comparing (subtracting) pointers. For example:
if(cp1 == cp2)
; take appropriate action

The ANSI C standard only allows pointer comparisons when the two pointer targets are the same
object. The address may extend to one element past the end of an array.
Comparisons of pointers to integer constants are even more risky, for example:
if(cp1 == 0xA0000100)
; take appropriate action

A NULL pointer is the one instance where a constant value can be assigned to a pointer and this
is handled correctly by the compiler. A NULL pointer is numerically equal to 0 (zero), but this is a
special case imposed by the ANSI C standard. Comparisons with the macro NULL are also allowed.

9.7

Complex Data Types
Complex data types are currently not implemented in MPLAB XC32 C/C++ Compiler.

9.8

Constant Types and Formats
A constant is used to represent a numerical value in the source code, for example 123 is a constant.
Like any value, a constant must have a C/C++ type. In addition to a constant’s type, the actual value
can be specified in one of several formats. The format of integral constants specifies their radix.
MPLAB XC32 C/C++ supports the ANSI standard radix specifiers as well as ones which enables binary
constants to be specified in C code.
The formats used to specify the radices are given in the table below. The letters used to
specify binary or hexadecimal radices are case insensitive, as are the letters used to specify the
hexadecimal digits.
Table 9-3. Radix Formats
Radix

Format

Example

binary

0b number or 0B number

0b10011010

octal

0 number

0763

decimal

number

129

hexadecimal

0x number or 0X number

0x2F

Any integral constant will have a type of int, long int or long long int, so that the type can
hold the value without overflow. Constants specified in octal or hexadecimal may also be assigned
a type of unsigned int, unsigned long int or unsigned long long int if the signed
counterparts are too small to hold the value.
The default types of constants may be changed by the addition of a suffix after the digits, for
example, 23U, where U is the suffix. The table below shows the possible combination of suffixes and
the types that are considered when assigning a type. For example, if the suffix l is specified and the
value is a decimal constant, the compiler will assign the type long int, if that type will hold the
constant; otherwise, it will assigned long long int. If the constant was specified as an octal or
hexadecimal constant, then unsigned types are also considered.
Table 9-4. Suffixed and Assigned Types
Suffix

Decimal

Octal or Hexadecimal

u or U

unsigned int

unsigned int

unsigned long int

unsigned long int

unsigned long long int

unsigned long long int

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 117

XC32 Compiler for PIC32M
Supported Data Types and Variables

...........continued
Suffix

Decimal

Octal or Hexadecimal

l or L

long int

long int

long long int

unsigned long int
long long int
unsigned long long int

u or U, and l or L
ll or LL

unsigned long int

unsigned long int

unsigned long long int

unsigned long long int

long long int

long long int
unsigned long long int

u or U, and ll or LL

unsigned long long int

unsigned long long int

Here is an example of code that may fail because the default type assigned to a constant is not
appropriate:
unsigned long int result;
unsigned char shifter;
int main(void)
{
shifter = 40;
result = 1 << shifter;
// code that uses result
}

The constant 1 will be assigned an int type hence the result of the shift operation will be an
int and the upper bits of the long variable, result, can never be set, regardless of how much
the constant is shifted. In this case, the value 1 shifted left 40 bits will yield the result 0, not
0x10000000000.
The following uses a suffix to change the type of the constant, hence ensure the shift result has an
unsigned long type.
result = 1UL << shifter;
Floating-point constants have double type unless suffixed by f or F, in which case it is a float
constant. The suffixes l or L specify a long double type.
Character constants are enclosed by single quote characters, ’, for example ’a’. A character
constant has int type, although this may be optimized to a char type later in the compilation.
Multi-byte character constants are accepted by the compiler but are not supported by the standard
libraries.
String constants, or string literals, are enclosed by double quote characters " ", for example
"hello world". The type of string constants is const char * and the character that make up the
string are stored in the program memory, as are all objects qualified const.
To comply with the ANSI C standard, the compiler does not support the extended character set in
characters or character arrays. Instead, they need to be escaped using the backslash character, as in
the following example:
const char name[] = "Bj\370rk";
printf("%s's Resum\351", name); \\ prints "Bjørk's Resumé"

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 118

XC32 Compiler for PIC32M
Supported Data Types and Variables

Assigning a string literal to a pointer to a non-const char will generate a warning from the
compiler. This code is legal, but the behavior if the pointer attempts to write to the string will fail. For
example:
char * cp= "one";
const char * ccp= "two";

// "one" in ROM, produces warning
// "two" in ROM, correct

Defining and initializing a non-const array (i.e., not a pointer definition) with a string,
char ca[]= "two"; // "two" different to the above

is a special case and produces an array in data space which is initialized at start-up with the string
"two" (copied from program space), whereas a string constant used in other contexts represents an
unnamed const -qualified array, accessed directly in program space.
The MPLAB XC32 C/C++ Compiler will use the same storage location and label for strings that have
identical character sequences. For example, in the code snippet
if(strncmp(scp, "hello world", 6) == 0)
fred = 0;
if(strcmp(scp, "hello world") == 0)
fred++;

the two identical character string greetings will share the same memory locations. The link-time
optimization must be enabled to allow this optimization when the strings may be located in different
modules.
Two adjacent string constants (that is, two strings separated only by white space) are concatenated
by the compiler. Thus:
const char * cp = "hello"

"world";

will assign the pointer with the address of the string "hello world".

9.9

Standard Type Qualifiers
Type qualifiers provide additional information regarding how an object may be used. The MPLAB
XC32 C Compiler supports both standard C qualifiers and additional, special qualifiers that are
useful for embedded applications and that take advantage of the PIC32M architecture.

9.9.1

Const Type Qualifier
The const type qualifier is used to tell the compiler that an object is read only and must not be
modified. The compiler will issue a warning or error if you attempt to modify an object declared
const in source code.
A const object is usually defined with initial values, as the program cannot write to these objects at
runtime. However this is not a requirement. An uninitialized const object is allocated space in one
of the bss sections, along with other uninitialized RAM variables, but is still treated as read-only by
the compiler.
const char IOtype = ’A’;
const char buffer[10];

// initialized const object
// I just reserve memory in RAM

Objects qualified only with const are not guaranteed to be located in program memory. The
use of some options can affect where const-qualified object are located. Objects qualified const
might be placed in data memory when the -fzero-initialized-in-bss, -fdata-sections, or
-mno-embedded-data options are used. To explicitly request that the object be placed in program
memory regardless of the usage of the options listed, use the space(prog) attribute along with the
const qualifier (see 10.4. Variables in Program Memory).

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 119

XC32 Compiler for PIC32M
Supported Data Types and Variables

9.9.2

Volatile Type Qualifier
The volatile type qualifier is used to tell the compiler that an object cannot be guaranteed
to retain its value between successive accesses. This prevents the optimizer from eliminating
apparently redundant references to objects declared volatile because it may alter the behavior of
the program to do so.
Any SFR which can be modified by hardware or which drives hardware is qualified as volatile
and any variables which may be modified by interrupt routines should use this qualifier as well. For
example:
extern volatile unsigned int WDTCON __attribute__((section("sfrs")));

The volatile qualifier does not guarantee that any access will be atomic, but the compiler will try
to implement this.
The code produced by the compiler to access volatile objects may be different than that to access
ordinary variables and typically the code will be longer and slower for volatile objects, so only use
this qualifier if it is necessary. However, failure to use this qualifier when it is required may lead to
code failure.
Another use of the volatile keyword is to prevent variables from being removed if they are not
used in the C/C++ source. If a non-volatile variable is never used, or used in a way that has no
effect on the program’s function, then it may be removed before code is generated by the compiler.
A C/C++ statement that consists only of a volatile variable’s name will produce code that reads
the variable’s memory location and discards the result. For example the entire statement:
PORTB;
will produce assembly code that reads PORTB, but does nothing with this value. This is useful for
some peripheral registers that require reading to reset the state of interrupt flags. Normally such a
statement is not encoded as it has no effect.

9.10

Compiler-Specific Qualifiers

9.11

Variable Attributes

There are currently no non-standard qualifiers implemented in MPLAB XC32 C/C++ Compiler.
Attributes are used to control variables and functions.

The compiler keyword __attribute__ allows you to specify special attributes of variables or
structure fields. This keyword is followed by an attribute specification inside double parentheses.
To specify multiple attributes, separate them by commas within the double parentheses, for
example:
__attribute__ ((aligned (16), packed)).
Note: It is important to use variable attributes consistently throughout a project. For example, if
a variable is defined in file A with the aligned attribute, and declared extern in file B without
aligned, then a link error may result.
address (addr)
Specify an absolute virtual address for the variable. This attribute can be used in conjunction with a
section attribute.
Note: For a data variable on a target device without an L1 cache, the address is typically in the
range [0xA0000000,0xA00FFFFC], as defined in the linker script as the kseg1_data_mem region.
For data variables on a target feature an L1 data cache, the address is typically in the range
[0x80000000,0x800FFFFC] as defined in the linker script as the kseg0_data_mem region. Take
special care to use the correct kseg region for your device or more than one variable might be
allocated to the same physical address.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 120

XC32 Compiler for PIC32M
Supported Data Types and Variables

This attribute can be used to start a group of variables at a specific address:
int foo __attribute__((section("mysection"),address(0xA0001000)));
int bar __attribute__((section("mysection")));
int baz __attribute__((section("mysection")));

Keep in mind that the compiler performs no error checking on the specified address. The section
will be located at the specified address regardless of the memory-region ranges listed in the linker
script or the actual ranges on the target device. This application code is responsible for ensuring
that the address is valid for the target device and application.
Also, be aware that variables attributed with an absolute address are not accessed via GP-relative
addressing. This means that they may be more expensive to access than non-address attributed
variables.
In addition, to make effective use of absolute sections and the best-fit allocator, standard programmemory and data-memory sections should not be mapped in the linker script. The built-in linker
script does not map most standard sections such as the .text, .data, .bss, or .ramfunc section.
By not mapping these sections in the linker script, we allow these sections to be allocated using the
best-fit allocator rather than the sequential allocator. Sections that are unmapped in the linker script
can flow around absolute sections whereas sections that are linker-script mapped are grouped
together and allocated sequentially, potentially causing conflicts with absolute sections.
Finally, note that “small” data and bss (.sdata, .sbss, etc.) sections are still mapped in the built-in
default linker script. This is because “small” data variables must be grouped together so that they
are within range of the more efficient GP-relative addressing mode. To avoid conflict with these

linker-script mapped sections, choose high addresses for your absolute-address variables.

Note: In almost all cases, you will want to combine the address attribute with the space attribute to
indicate code or data with space(prog) or space(data), respectively. Also, see the description for
the attribute space.
aligned (n)
The attributed variable will be aligned on the next n byte boundary.
The aligned attribute can also be used on a structure member. Such a member will be aligned to
the indicated boundary within the structure.
If the alignment value n is omitted, the alignment of the variable is set 8 (the largest alignment value
for a basic data type).
Note that the aligned attribute is used to increase the alignment of a variable, not reduce it. To
decrease the alignment value of a variable, use the packed attribute.
cleanup (function)
Indicate a function to call when the attributed automatic function scope variable goes out of scope.
The indicated function should take a single parameter, a pointer to a type compatible with the
attributed variable, and have void return type.
coherent
The coherent variable attribute causes the compiler/linker to place the variable into a unique section
that is allocated to the kseg1 region, rather than the kseg0 region (which is the default on L1 cached
devices). This means that the variable is accessed through the uncached address.
For devices featuring an L1 data cache, data variables are allocated to the KSEG0 data-memory
region (kseg0_data_mem), making it accessible through the L1 cache. Likewise, the linker-allocated
heap and stack are allocated to the KSEG0 region.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 121

XC32 Compiler for PIC32M
Supported Data Types and Variables

The is a coherent variable attribute that allows you to create a DMA buffer allocated to the
kseg1_data_mem region:
unsigned int __attribute__((coherent)) buffer [1024];
When combining the coherent attribute with the address attribute, be sure to use the default
data-memory region address for the device. On devices featuring an L1 data cache, the default
data-memory region is kseg0_data_mem:
unsigned int __attribute__((coherent,address(0x80001000))) buffer[1024]
The __pic32_alloc_coherent(size_t) and __pic32_free_coherent(void*) functions
allocate and free memory from the uncached kseg1_data_mem region. The default stack is allocated
to the cached kseg0_data_mem region, but you may want to create an uncached DMA buffer, so
you can use these functions to allocate an uncached buffer. These functions call the standard
malloc()/free() functions, but the pointers that they use are translated from kseg0 to kseg1.
#include<xc.h>
void jak(void){
char* buffer = __pic32_alloc_coherent(1024);
if (buffer){
/* do somehing */
}
else{
/* handle error */
}
if (buffer){
__pic32_free_coherent(buffer);
}
}

deprecated
deprecated (msg)
When a variable specified as deprecated is used, a warning is generated. The optional msg
argument, which must be a string, will be printed in the warning, if present.
externally_visible
This attribute when used with a global object, nullifies the effect of the -fwhole-program
command-line option, so the object remains visible outside the current compilation unit. This might
prevent certain optimizations from being performed on the object.
noload
The noload attribute causes the variable or function to be placed in a section that has the noload
attribute set. This attribute tells consumers of the ELF file not to load the contents of the section.
This attribute can be useful when you just want to reserve memory for something, but you don't
want to clear or initialize memory.
persistent
The persistent attribute specifies that the variable should not be initialized or cleared at startup.
Use a variable with the persistent attribute to store state information that will remain valid after a
device Reset. The persistent attribute causes the compiler to place the variable in special .bss-like
section that does not get cleared by the default startup code. Because the section is always in data
space, this attribute is not compatible with the space attribute.
int last_mode __attribute__((persistent));
The persistent attribute implies the coherent attribute. That is, persistent attributed variables
are accessed via the uncached address.
packed

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 122

XC32 Compiler for PIC32M
Supported Data Types and Variables

The attributed variable or structure member will have the smallest possible alignment. That is,
no alignment padding storage will be allocated for the declaration. Used in combination with the
aligned attribute, packed can be used to set an arbitrary alignment restriction greater or lesser
than the default alignment for the type of the variable or structure member.
section ("section-name")
Place the variable into the named section.
For example,
unsigned int dan __attribute__ ((section (".quixote")))
Variable dan will be placed in section .quixote.
The -fdata-sections command line option has no effect on variables defined with a section
attribute unless unique_section is also specified.
space(memory-space)
The space attribute can be used to direct the compiler to allocate a variable in a specific
memory space. Valid memory spaces are prog for program memory, data for data memory, and
serial_mem for serial memory such as SPI Flash. The data space is the default space for non-const
variables.
The prog, data, and serial_mem spaces normally correspond to the kseg0_prog_mem,
ksegN_data_mem, and serial_mem memory regions, respectively, as specified in the default
device-specific linker scripts.
This attribute also controls how initialized data is handled. The linker generates an entry in
the data-initialization template for the default space(data). But, it does not generate an entry
for space(prog) or space(serial_mem), since the variable is located in non-volatile memory.
Typically, this means that space(data) applies to variables that will be initialized at runtime
startup; while space(prog) and space(serial_mem) apply to variables that will be programmed
by an in-circuit programmer or a bootloader.
For example:
const unsigned int __attribute__((space(prog))) jack = 10;
const unsigned int __attribute__((space(serial_mem))) zori = 1;
signed int __attribute__((space(data))) oz = 5;

unique_section
Place the variable in a uniquely named section, just as if -fdata-sections had been specified. If
the variable also has a section attribute, use that section name as the prefix for generating the
unique section name.
For example,
int tin __attribute__ ((section (".ofcatfood"), unique_section)
Variable tin will be placed in section .ofcatfood.
unused
Indicate to the compiler that the variable may not be used. The compiler will not issue a warning for
this variable if it is not used.
used
Indicate to the compiler that the object is always used and storage must be allocated for the
object, even if the compiler cannot see a reference to it. For example, if inline assembly is the only
reference to an object.
weak

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 123

XC32 Compiler for PIC32M
Supported Data Types and Variables

The weak attribute causes the declaration to be emitted as a weak symbol. A weak symbol indicates
that if a global version of the same symbol is available, that version should be used instead.
When weak is applied to a reference to an external symbol, the symbol is not required for linking.
For example:
extern int __attribute__((weak)) s;
int foo() {
if (&s) return s;
return 0; /* possibly some other value */
}

In the above program, if s is not defined by some other module, the program will still link but s will
not be given an address. The conditional verifies that s has been defined (and returns its value if
it has). Otherwise '0' is returned. There are many uses for this feature, mostly to provide generic
code that can link with an optional library.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 124

XC32 Compiler for PIC32M
Memory Allocation and Access

10.

Memory Allocation and Access
There are two broad groups of RAM-based variables: auto/parameter variables, which are allocated
to some form of stack, and global/static variables, which are positioned freely throughout the data
memory space. The memory allocation of these two groups is discussed separately in the following
sections.

10.1

Address Spaces
Unlike the 8- and 16-bit PIC devices, the PIC32 has a unified programming model. PIC32 devices
provide a single 32-bit wide address space for all code, data, peripherals and Configuration bits.
Memory regions within this single address space are designated for different purposes; for example,
as memory for instruction code or memory for data. Internally the device uses separate buses*
to access the instructions and data in these regions, thus allowing for parallel access. The terms
program memory and data memory, which are used on the 8- and 16-bit PIC devices, are still
relevant on PIC32 devices, but the smaller parts implement these in different address spaces.
All addresses used by the CPU within the device are virtual addresses. These are mapped to physical
addresses by the system control processor (CP0).
* The device can be considered a Harvard architecture in terms of its internal bus arrangement.

10.2

Variables in Data Memory
Most variables are ultimately positioned into the data memory. The exceptions are non-auto
variables which are qualified as const, which are placed in the program memory space, see
9.9.1. Const Type Qualifier.
Due to the fundamentally different way in which auto variables and non-auto variables are
allocated memory, they are discussed separately. To use the C/C++ language terminology, these two
groups of variables are those with automatic storage duration and those with permanent storage
duration, respectively.
Note: The terms “local” and “global” are commonly used to describe variables, but are not ones
defined by the language standard. The term “local variable” is often taken to mean a variable
which has scope inside a function, and “global variable” is one which has scope throughout the
entire program. However, the C/C++ language has three common scopes: block, file (that is, internal
linkage) and program (that is, external linkage), so using only two terms to describe these can be
confusing. For example, a static variable defined outside a function has scope only in that file, so
it is not globally accessible, but it can be accessed by more than one function inside that file, so it
is not local to any one function either. In terms of memory allocation, variables are allocated space
based on whether it is an auto or not, hence the grouping in the following sections.

10.2.1 Non-Auto Variable Allocation
Non-auto variables (those with permanent storage duration) are located by the compiler into any
of the available data banks. This is done in a two-stage process: placing each variable into an
appropriate section and later linking that section into data memory.
The compiler considers three categories of non-auto variable which all relate to the value the
variable should contain by the time the program begins. The following sections are used for the
categories described.
•

.pbss - These sections are used to store variables which use the persistent attribute, whose
values should not be altered by the runtime start-up code. They are not cleared or otherwise
modified at start-up.

•

.bss - These sections (also .sbss) contain any uninitialized variables, which are not assigned a
value when they are defined, or variables which should be cleared by the runtime start-up code.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 125

XC32 Compiler for PIC32M
Memory Allocation and Access

•

.data - These sections (also .sdata) contain the RAM image of any initialized variables, which
are assigned a non-zero initial value when they are defined and which must have a value copied
to them by the runtime start-up code.

Note that the data section used to hold initialized variables is the section that holds the RAM
variables themselves. There is a corresponding section (called .dinit) that is placed into program
memory (so it is non-volatile) and which is used to hold the initial values that are copied to the RAM
variables by the runtime start-up code.

10.2.2 Static Variables
All static variables have permanent storage duration, even those defined inside a function which
are “local static” variables. Local static variables only have scope in the function or block in which
they are defined, but unlike auto variables, their memory is reserved for the entire duration of the
program. Thus, they are allocated memory like other non-auto variables. Static variables may be
accessed by other functions via pointers, since they have permanent duration.
Variables which are static are guaranteed to retain their value between calls to a function, unless
explicitly modified via a pointer.
Variables which are static and initialized have their initial value assigned only once during the
program's execution. Thus, they may be preferable over initialized auto objects which are assigned
a value every time the block they are defined in begins execution. Any initialized static variables
are initialized in the same way as other non-auto initialized objects by the runtime start-up code,
see 5.4.3. Peripheral Library Functions. Static variables are located in the same sections as their
non-static counterparts.

10.2.3 Non-Auto Variable Size Limits
Arrays of any type (including arrays of aggregate types) are fully supported by the compiler. So
too are the structure and union aggregate types, see 9.5. Structures and Unions. There are no
theoretical limits as to how large these objects can be made.

10.2.4 Changing the Default Non-Auto Variable Allocation
There are several ways in which non-auto variables can be located in locations other than the
default.
Variables can be placed in other device memory spaces by the use of qualifiers. For example if you
wish to place variables in the program memory space, then the const specifier should be used (see
9.9.1. Const Type Qualifier).
If you wish to prevent all variables from using one or more data memory locations so that these
locations can be used for some other purpose, it is best to define a variable (or array) using the
address attribute so that it consumes the memory space, see 9.11. Variable Attributes .
If only a few non-auto variables are to be located at specific addresses in data space memory,
then the variables can be located using the address attribute. This attribute is described in
9.11. Variable Attributes.

10.2.5 Data Memory Allocation Macros
The sys/attribs.h header file provides many macros for commonly used attributes in order to
enhance code readability.
__section__(s)

Apply the section attribute with section name s.

__unique_section__

Apply the unique_section attribute.

__ramfunc__

Locate the attributed function in the RAM function code section.

__longramfunc__

Locate the attributed function in the RAM function code section and apply
the longcall attribute.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 126

XC32 Compiler for PIC32M
Memory Allocation and Access

10.3

__longcall__

Apply the longcall attribute.

__ISR(v,ipl)

Apply the interrupt attribute with priority level ipl and the vector
attribute with vector number v.

__ISR_AT_VECTOR(v,ipl)

Apply the interrupt attribute with priority level ipl and the at_vector
attribute with vector number v. This macro is especially useful on PIC32
devices that feature variable vector offsets.

__ISR_SINGLE__

Specifies a function as an Interrupt Service Routine in single-vector mode.
This places a jump at the single-vector location to the interrupt handler.

__ISR_SINGLE_AT_VECTOR__

Places the entire single-vector interrupt handler at the vector 0 location.
When used, ensure that the vector spacing is set to accommodate the size of
the handler.

Auto Variable Allocation and Access
This section discusses allocation of auto variables (those with automatic storage duration). This
also includes function parameter variables, which behave like auto variables, as well as temporary
variables defined by the compiler.
The auto (short for automatic) variables are the default type of local variable. Unless explicitly
declared to be static, a local variable will be made auto. The auto keyword may be used if
desired.
The auto variables, as their name suggests, automatically come into existence when a function is
executed, then disappear once the function returns. Since they are not in existence for the entire
duration of the program, there is the possibility to reclaim memory they use when the variables are
not in existence and allocate it to other variables in the program.
The software stack of the PIC32 is used to store all auto variables. Functions are reentrant and
each instance of the function has its own area of memory on the stack for its auto and parameter
variables, as described below. See 15.1. Software Stack and18.2.3. Initialize Stack Pointer and Heap
for more information on the stack.
The compiler dedicates General Purpose Register 29 as the software Stack Pointer. All processor
stack operations, including function call, interrupts and exceptions use the software stack. The stack
grows downward from high addresses to low addresses.
By default, the size of the stack is 1024 bytes. The size of the stack may be changed by specifying
the size on the linker command line using the --defsym_min_stack_size linker command line
option. An example of allocating a stack of 2048 bytes using the command line is:
xc32-gcc foo.c -Wl,--defsym,_min_stack_size=2048
The run-time stack grows downward from higher addresses to lower addresses (see the figure
below). The compiler uses two working registers to manage the stack:
•

Register 29 (sp) – This is the Stack Pointer. It points to the next free location on the stack.

•

Register 30 (fp) – This is the Frame Pointer. It points to the current function’s frame. Each
function, if required, creates a new frame from which automatic and temporary variables are
allocated. Compiler optimization may eliminate Stack Pointer references via the Frame Pointer
to equivalent references via the Stack Pointer. This optimization allows the Frame Pointer to be
used as a General Purpose Register.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 127

XC32 Compiler for PIC32M
Memory Allocation and Access

Figure 10-1. Stack Frame

The the standard qualifiers const and volatile may both be used with auto variables and these do
not affect how they are positioned in memory. This implies that a local const-qualified object is still
an auto object and, as such, will be allocated memory on the stack in the data memory, not in the
program memory like with non-auto const objects.p
Local Variable Size Limits
There is no theoretical maximum size for auto variables.

10.4

Variables in Program Memory
To have objects placed into program memory, which is Flash memory on most target devices, they
should be qualified const and additionally use the space(prog) attribute, for example:
const int __attribute__((space(prog))) const_symbol;

This combination places the object const_symbol into a .text section rather than a .rodata
section. You still need to use the space(prog) attribute even if you are also using a section()
attribute. Failure to use the const specifier with the space(prog) attribute will result in a
compilation error: space("prog") object 'symbol' should be const qualified.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 128

XC32 Compiler for PIC32M
Memory Allocation and Access

Without the space(prog) attribute, some options can affect where objects only qualified with
const are located, so both the attribute and qualifier should be used to ensure the objects are
located in program memory. (See also 9.9.1. Const Type Qualifier.)

10.4.1 Size Limitations of const Variables
There is no theoretical maximum size for const variables.

10.4.2 Changing the Default Allocation
If you only intend to prevent all variables from using one or more program memory locations so
that you can use those locations for some other purpose, you are best reserving the memory using
the memory adjust options.
If only a few non-auto const variables are to be located at specific addresses in program space
memory, then the variables should use the address attribute to locate them at the desired location.
This attribute is described in 9.11. Variable Attributes .

10.5

Variable in Registers
Allocating variables to registers, rather than to a memory location, can make code more efficient.
With MPLAB XC32 C/C++ Compiler, variables may be allocated to registers as part of code
optimizations. For optimization levels 1 and higher, the values assigned to variables may cached
in a register. During this time, the memory location associated with the variable may not hold a valid
value.
The register keyword may be used to indicate your preference for the variable to be allocated a
register, but this is just a recommendation and may not be honored. The specific register may be
indicated as well, but this is not recommended as your register choice may conflict with the needs of
the compiler. Using a specific register in your code may cause the compiler to generate less efficient
code.
As indicated in 16.6. Function Parameters, parameters may be passed to a function via a register.
Example 10-1. Variables in Registers
volatile unsigned int special;
unsigned int example (void)
{
register unsigned int my_reg __asm__("$4");
my_reg += special;
return my_reg;
}

10.6

Application-Defined Memory Regions
On occasion, an application may require a new memory region that was not defined in the default
device-specific linker scripts. One such case may be when using external memory connected to the
External Bus Interface (EBI) on a PIC32MZ target device.
One way to handle adding a new memory region would be to create a custom linker script, add the
new memory region, and explicitly map your sections to the new region. Another way to add a new
memory region would be to add an application-defined memory region to your C/C++ source code.
Some applications may even choose to combine a custom linker script and an application-defined
memory region.

10.6.1 Advantages of an Application-Defined Memory Region
Using an application-defined memory region in source code can provide a few advantages over
adding a memory region to a custom linker script.
•

Portability: An application-defined memory region can help reduce the need for a custom linker
script. This can be beneficial because you can use the device's default linker script and thereby

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 129

XC32 Compiler for PIC32M
Memory Allocation and Access

avoid potential migration issues between XC32 versions, as well as between different PIC32
variants.
•

Best-Fit Allocation: Region-attributed variables and functions are handled by the linker's bestfit allocator, as described in the MPLAB XC32 Assembler, Linker, and Utilities User's Guide
(DS50002186). Sections mapped to a new region in a custom linker script must be explicitly
mapped using the SECTIONS command and are allocated sequentially.

10.6.2 Advantages of a Linker Script-Defined Memory Region
Using a custom linker script with a new memory region can also provide advantages over an
application-defined memory region.
•

Update memory mapping at link time: A custom linker script allows you to easily switch between
different memory mappings without rebuilding your C/C++ code.

•

Standard GNU Binutils: A user migrating from another toolchain based on GNU Binutils may
already be familiar and comfortable with creating new memory regions in a custom linker script.
XC32 supports this standard mechanism.

10.6.3 Using an Application-Defined Memory Region
To use this feature, work through the following sections.
Define a New Memory Space
The XC32 tool suite requires information about each memory region. In order for the XC32 linker
to be able to properly assign memory, you must specify information about the size of the memory
region available and the origin of the memory region.
Define an application-defined memory region, with the origin and the size, using the 'region'
pragma as shown below.
#pragma region name=name origin=address size=bytes
where name is a quoted string containing the name of the region, address is the starting address of
the region, and bytes is the size in bytes of the region.
Example 10-2. Defining a New Memory Space
#pragma region name="ext_mem" origin=0xC0000000 size=0x1000
In this example, we define an application-defined memory region to be used for external memory.
We name the region "ext_mem" and specify that the starting address is 0xC0000000 and that
it has a size of 0x1000 bytes. Consult your PIC32 device data sheet for information about the
external-memory interface options and the memory mappings available on your device.
Define Variables within a Region
When you have defined a new memory region, you can then assign a variable to that region. Use
the region attribute on a variable to specify that it should be allocated to the specified region.
This requires the memory region definition to be present. Given the definition in the previous
subsection, you can make the following variable definition:
int ext_array[256] __attribute__((region("ext_mem")));

ext_array will be allocated in the previously declared region "ext_mem".
Once the variable has been defined with the region attribute, it may be accessed using normal C
syntax.
When called with the --report-mem linker command-line option, the linker prints a summary
of memory usage to stdout. If the -Map linker command-line option was specified, the memory
summary will also be printed in the map file. When the application-defined memory region is used,

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 130

XC32 Compiler for PIC32M
Memory Allocation and Access

the length of each section allocated to a region and the total memory used for each region is
displayed.
Define Functions within a Region
You can also use the region attribute to assign individual functions to the region. This requires the
memory region definition to be present. Given the definition in the previous subsection, you can
make the following function definition:
int
{
}

__attribute__((far, region("ext_mem"))) foo()
ext_array[2] = ext_array[0] + ext_array[1] ;
return 0;

Use the region attribute with the far attribute to allocate the function in our example "ext_mem"
region. In this case, we need the far attribute because the address of our "ext_mem"
region is located outside of the 256 MB segment of our default program-memory region,
kseg0_program_mem, as defined in our default linker script. Using the far attribute tells the
compiler to generate a long call.
Initializing Memory Interfaces
When your application-defined memory region corresponds to an external-memory interface such
as the Serial Quad Interface (SQI) or External Bus Interface (EBI), you will likely need to configure the
interface module. For instance, the EBI module must be configured to understand such things as the
type, size, and bus width of each attached device. See the device data sheet and the family reference
manual for your target device.
The default XC32 runtime start-up code uses a linker-generated data-initialization template placed
in a section named .dinit (see 18.2.9. Initialize Objects and RAM Functions). For variables or
functions placed in an application-defined memory region, the application must execute any
memory-interface configuration code before the runtime start-up code attempts to initialize these
variables or functions.
The default runtime start-up code provides an _on_reset() weak hook. This routine is called
after initializing a minimum ‘C’ context, but before data initialization. You can provide your memoryinterface configuration code in this hook. See 18.2.5. The “On Reset” Routine for more information
on this important hook.
Example 10-3. Hardware Init Before Data Init
/* The _on_reset() function will be called by the default
runtime start-up code prior to data initialization. */
void _on_reset (void)
{
/* Call a function that configures the EBI control
registers for the target board. */
configure_ebi_sram();
}

On some target devices, your application may also need to enable the Memory Management Unit
(MMU) and initialize the Translation Lookaside Buffer (TLB). On many devices, the XC32 toolchain
provides a default mapping suitable for the SQI and EBI interfaces. See your target device data sheet
for information on default memory mapping that is specific to your target device. For devices where
a default SQI and EBI mapping is provided, you can override the default mapping by providing your
own __pic32_tlb_init_ebi_sqi() function.
The source code for this is found in the pic32m-libs.zip file located at:
<install-directory>/pic32-libs/
Once the file is unzipped, the source code can be found at:

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 131

XC32 Compiler for PIC32M
Memory Allocation and Access

pic32m-libs/libpic32/stubs/pic32_init_tlb_ebi.S.
The following sections provide example cases using the application-defined memory region feature.
Example 10-4. Case 1
Variables can be placed in external memory by using the region attribute.
#pragma region name="ext_mem" origin=0x0xC0000000 size=0x1000
signed int
ea1
unsigned int ea2
signed int
signed long

__attribute__((region("ext_mem")));
__attribute__((region("ext_mem")));

eb1[10]
eb2[10]

__attribute__((region("ext_mem"))) = {10,20};
__attribute__((region("ext_mem"))) =
{0x987654321, 0x12345678};

Example 10-5. Case 2
Functions can be placed in external memory by using the region attribute. Since
functions default to space(prog), the function is assumed to be programmed into
the region and will not be initialized by the runtime start-up code.
#pragma region name="ext_flash" origin=0xC0000000 size=0x1000
int ea1 __attribute__((region("ext_flash"))) ;
int eb1 __attribute__((region("ext_flash"))) = 0x1000 ;
int ec1 __attribute__((region("ext_flash"))) = 0x2000 ;
void __attribute__((region("ext_flash"))) foo()
{
ea1 = eb1 + ec1 ;
}
void main()
{
foo();
}

Apply the far attribute to foo(), since it is out of range of the default
kseg0_program_mem region. Alternatively, use -mlong-calls option to compile
the above example.
Example 10-6. Case 3
Combine the region attribute with the space (data) attribute to indicate that the
function code should be initialized by the runtime start-up code's data initialization
template. In this case, the code for the function is contained in the data-initialization
template and copied to the memory region at startup.
#pragma region name="myebi_sram" origin=0xC0004000 size=0x100
void __attribute__((far,space(data),region("myebi_sram"))) fn_in_sram()
{ /* Code here */ }

Example 10-7. Case 4
Combine the region attribute with the address() attribute to place a variable at an
absolute address within the region.
#pragma region name="myebi_2"

origin=0xC0001000

size=0x10

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 132

XC32 Compiler for PIC32M
Memory Allocation and Access
unsigned long __attribute__((region("myebi_2"),address(0xC0001000))) paws =
0xAAAABBBB;

10.7

Dynamic Memory Allocation
Dynamic memory allocation is the runtime allocation of uninitialized memory for arbitrary-sized
data objects by various standard C library dynamic memory management functions that are
explicitly called by the programmer (such as calloc, malloc and realloc) along with the C++
new operator. The memory for the objects is allocated from a region of reserved memory, usually
called the heap. Memory allocated in this way can be freed for reuse by calling additional library
routines (such as free) or the C++ delete operator, although indiscriminate use of this feature can
lead to memory fragmentation.
There are two libc implementations of dynamic memory allocation available, allowing the
programmer to select between a reduced code footprint or better memory management. These
implementations can be selected using the -mmalloc-variant=scheme option.
Lite allocation uses a simple algorithm for allocating and freeing chunks of memory from the heap,
resulting in a smaller code footprint and almost no runtime overhead. However, memory can easily
fragment when allocating and subsequently freeing memory chunks in this way. This dynamic
memory allocation implementation is selected when using the -mmalloc-variant=lite option or
when this option has not been specified.
Binned allocation maintains free (unallocated) chunks of memory in bins, grouped by size.
Algorithms are used to search for suitable memory chunks within the bins when requested.
This algorithm adds some runtime overhead but overcomes many of the memory fragmentation
problems associated with other schemes. The binned form of dynamic memory allocation will be
utilized when using the -mmalloc-variant=binned option has been specified.
By default, no heap is used. If your program uses dynamic memory allocation, you must set aside
memory to use as the heap. Most C++ applications will require a heap. In MPLAB X, you can specify
a heap size in the xc32-ld (32-Bit Linker) category in the Project Properties dialog. MPLAB X will
automatically pass the option to the linker when building your project. Alternatively, a heap can be
created by specifying its size using the --defsym=_min_heap_size linker command line option. An
example of allocating a heap of 512 bytes using the command line is:
xc32-gcc -mprocessor=32MZ2048ECH100foo.c -Wl,--defsym=_min_heap_size=512

An example of allocating a heap of 0xF000 bytes using the xc32-g++ driver is:
xc32-g++ -mprocessor=32MZ2048ECH100vector.cpp -Wl,--defsym=_min_heap_size=0xF000

The linker allocates the heap immediately before the stack.

10.8

Memory Models
MPLAB XC32 C/C++ Compiler does not use fixed memory models to alter allocation of variables to
memory.
The -G option (see 5.7.1. Options Specific to PIC32M Devices), which controls the gp-relative
addressing threshold, is similar to the small-data/large-data/scalar-data memory models offered
by the Microchip compilers for the 8- and 16-bit architectures. The value specified with this option
indicates the maximum size of objects that will be allocated to the small data sections, for example,
sbss, sdata, etc. Variables allocated to the small-data sections require fewer instructions to access
than variables allocated to the other data sections. For example:
xc32-gcc -G128 -mprocessor=32MX795F512L main.c
In this example, data objects up to 128 bytes in size will be located in the efficient small-data or
small-bss section.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 133

XC32 Compiler for PIC32M
Memory Allocation and Access

In general larger -G values result in more efficient code. However, gp-relative addressing is limited
to 64-KB of small data.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 134

XC32 Compiler for PIC32M
Floating-point Support

11.

Floating-point Support
Some PIC32M devices implement a 1985 IEEE-754 compliant Floating-point Unit (FPU) that supports
single and double precision data types.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 135

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support

12.

Fixed-Point Arithmetic Support
The MPLAB XC32 C/C++ Compiler supports fixed-point arithmetic. This, according to ISO/IEC TR
18037:2008//the N1169 draft of ISO/IEC TR 18037, the ISO C99 technical report on Embedded
C. It is available at [via]: http://www.open-std.org/JTC1/SC22/WG14/www/projects#18037. or
standards.iso.org/ittf/PubliclyAvailableStandards/c051126_ISO_IEC_TR_18037_2008.zip
This chapter describes the implementation-specific details of the types and operations supported by
the compiler under this draft standard.
Because of the sensitivity of DSP applications to performance, application developers have
historically tended to write functions in assembly. However, the XC32 compiler reduces, and may
even eliminate, the need to write assembly code. This chapter describes coding styles and usage tips
that can help you to obtain the best optimizations for your DSP application.
Several Microchip PIC32 MCUs feature a DSP-enhanced core with four 64-bit accumulators. The
DSP-enhanced core also provides a set of new instructions and a new architectural state, with
computational support for fractional data types, SIMD (Single Instruction, Multiple Data), saturation,
and other operations commonly used in DSP applications.
Note: Consult the data sheet for your specific target device to determine whether your target
device supports the DSP-enhanced core.

12.1

Enabling Fixed-Point Arithmetic Support
Fixed-point arithmetic support is enabled by default by the MPLAB XC32 C/C++ compiler, allowing
use of built-in fixed-point types, literals and operators. The <stdfix.h> header may be included to
provide convenient definitions as described in 12.2. Data Types.
The compiler automatically enables support for the DSP-enhanced core when you are compiling for
an appropriate PIC32 target device as selected by the -mprocessor option.

12.2

Data Types
All 12 of the primary fixed-point types and their aliases, described in Section 4.1 “Overview and
principles of the fixed-point data types” of ISO/IEC TR 18037:2008, are supported. Fixed-point data
values contain fractional and optional integral parts. The format of fixed-point data in XC32 are as
specified in the table below.
In the formats shown, s is the sign bit for a signed type (there is no sign bit for an unsigned type).
The period character (.) is the specifier that separates the integral part and the fractional part. The
numeric digits represent the number of bits in the integral part or in the fractional part.
Table 12-1. Fixed Point Formats
Type

Format

Description

short _Fract

s0.7

1 sign bit, no integer bits, 7 fractional
bits

unsigned short _Fract

0.8

8 fractional bits only

_Fract

s0.15

1 sign bit, 15 fractional bits

unsigned _Fract

0.16

16 fractional bits only

long _Fract

s0.31

1 sign bit, no integer bits, 31 fractional
bits

unsigned long _Fract

0.32

32 fractional bits only

long long _Fract

s0.63

1 sign bit, no integer bits, 63 fractional
bits

unsigned long long _Fract

0.64

64 fractional bits only

short _Accum

s8.7

1 sign bit, 8 integer bits, 7 fractional bits

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 136

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support

...........continued
Type

Format

Description

unsigned short _Accum

8.8

8 integer bits, 8 fractional bits

_Accum

s16.15

1 sign bit, 16 integer bits, 15 fractional
bits

unsigned _Accum

16.16

16 integer bits, 16 fractional bits

long _Accum

s32.31

1 sign bit, 32 integer bits, 31 fractional
bits

unsigned long _Accum

32.32

32 integer bits, 32 fractional bits

long long _Accum

s32.31

1 sign bit, 32 integer bits, 31 fractional
bits

unsigned long long _Accum

32.32

32 integer bits, 32 fractional bits

The _Sat type modifier may be used with any type in the above table to indicate that values
are saturated, as described in ISO/IEC TR 18037:2008. For example, _Sat short _Fract is the
saturating form of short _Fract. Signed types saturate at the most negative and positive numbers
representable in the corresponding format. Unsigned types saturate at zero and the most positive
number representable in the format.
The MPLAB XC32 C compiler provides an include file, stdfix.h, which provides various preprocessor macros related to fixed-point support. These include those show in the following table.
<stdfix.h> alias

Type

fract

_Fract

accum

_Accum

sat

_Sat

Usage example:
#include <stdfix.h>
void main () {
int i;
fract a[5] = {0.5,0.4,0.2,0.0,-0.1};
fract b[5] = {0.1,0.8,0.6,0.5,-0.1};
accum dp = 0;
/* Calculate dot product of a[] and b[] */
for (i=0; i<5; i++) {
dp += a[i] * b[i];
}
}

The default behavior of overflow on signed or unsigned types is saturation. The pragmas described
in Section 4.1.3 "Rounding and Overflow" of ISO/IEC TR 18037:2008 to control the rounding and
overflow behavior are not supported.
The following table describes the fixed-point literal suffixes supported to form fixed-point literals of
each type.
Table 12-2. Fixed-Point Literal Suffixes
Type

Suffixes

short _Fract

hr, HR

unsigned short _Fract

uhr, UHR

_Fract

r, R

unsigned _Fract

ur, UR

long _Fract

lr, LR

unsigned long _Fract

ulr, ULR

long long _Fract

llr, LLR

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 137

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support

...........continued

12.3

Type

Suffixes

unsigned long long _Fract

ullr, ULLR

short _Accum

hk, HK

unsigned short _Accum

uhk, UHK

_Accum

k, K

unsigned _Accum

uk, UK

long _Accum

lk, LK

unsigned long _Accum

ulk, ULK

long long _Accum

llk, LLK

unsigned long long _Accum

ullk, ULLK

Fixed-point Library Functions
The fixed-point functions described in Section 4.1.7 in ISO/IEC TR 18037:2008 (rounding, conversion
functions, etc.) are not provided in the current MPLAB XC32 standard C libraries.

12.4

Integer Representations
The Q15 data type can be represented by the 16-bit integer data type (short) and the Q31 data type
can be represented by the 32-bit integer data type (int). These types are necessary when using the
compiler's DSP built-in functions (see 29. Built-In Functions). Typedefs are useful for Q15 and Q31
as follows:
typedef short q15;
typedef int q31;

The four 64-bit accumulators in the DSP-enhanced core can be represented by the long long int
data type.
typedef long long int a64;

To initialize Q15 variables, multiply the fractional value (for example, 0.1234) by 0x1.0p15. To
initialize Q31 variables, programmers can multiply the fractional value by 0x1.0p31.
Ex: /* Q15 Example */
typedef short q15;
q15 a = 0.1234 * 0x1.0p15;
/* ------------------------------------------------------ */
Ex: /* Q31 Example */
typedef int q31;
q31 b = 0.2468 * 0x1.0p31;

12.5

SIMD Variables
The 8-bit unsigned integer data and Q15 fractional data are packed in a single 32-bit register,
and the new instructions operate simultaneously on the multiple data in the register in Single
Instruction, Multiple Data (SIMD) fashion. This feature provides computation parallelism for
increased application performance.
You can directly take advantage of SIMD parallelism by declaring SIMD data types as described
here. In addition, the compiler may automatically take advantage of SIMD parallelism using autovectorization as described in the Auto-vectorization section below.
To declare SIMD data types, typedefs with special vector_size attributes are required. For
example,
typedef signed char v4i8 __attribute__ ((vector_size(4)));
typedef signed char v4q7 __attribute__ ((vector_size(4)));

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 138

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support
typedef short v2i16 __attribute__ ((vector_size(4)));
typedef short v2q15 __attribute__ ((vector_size(4)));

v4i8, v4q7, v2i16, and v2q15 are SIMD data types that consist of 4, 4, 2, and 2 elements of 8 bits, 8
bits, 16 bits, and 16 bits respectively in a single variable/register.
SIMD data types are powerful and can be applied to fixed-point data types as well. For example:
typedef _Sat unsigned short _Fract
sat_v4uqq __attribute__ ((vector_size(4)));
typedef _Sat unsigned _Fract
sat_v2uhq __attribute__ ((vector_size(4)));
typedef _Sat unsigned short _Accum
sat_v2uha __attribute__ ((vector_size(4)));
typedef _Sat _Fract
sat_v2hq __attribute__ ((vector_size(4)));
typedef _Sat short _Accum
sat_v2ha __attribute__ ((vector_size(4)));

To initialize SIMD variables is similar to initializing aggregate data. The following examples show how
to initialize SIMD variables.
Example:
/* v4i8 Example */
v4i8 a = {1, 2, 3, 4};
v4i8 b;
b = (v4i8) {5, 6, 7, 8};
/* ------------------------------------------------------ */
Ex: /* v2q15 Example */
v2q15 a = {0x0fcb, 0x3a75};
v2q15 b;
b = (v2q15) {0.1234 * 32768.0, 0.4567 * 32768.0};

Data is stored from the right-to-left location of a register. For the example of v4i8 a = {1, 2, 3, 4}, the
register stores 1, 2, 3, and 4 from the right-to-left location as shown below.
a[3]=4

a[2]=3

a[1]=2

Bit 31

a[0]=1
Bit 0

Most arithmetic operations will simply work on the SIMD operands in the register irrespective of
their right-to-left location within the register. However, you must be aware of such instructions that
directly refer to the left or right portions of a register. For example, MAQ_SA.W.PHL.

12.6

Accessing Elements in SIMD Variables
The use of SIMD variables enables operations on multiple data in parallel. However, in certain
situations, programmers need to access elements inside a SIMD variable. This can be done by using
a union type that unites a SIMD type and an array of a basic type as follows.
typedef union
{
v4i8 a;
unsigned char b[4];
} v4i8_union;
typedef short q15;
typedef union
{
v2q15 a;
q15 b[2];
} v2q15_union;

As shown in the figure above for a v4i8 variable, b[0] is used to access the first element in the
variable. The element b[0] is right-most position. The following examples show how to extract or
assign elements.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 139

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support

Example:
/* v4i8 Example */
v4i8 i;
unsigned char j, k, l, m;
v4i8_union temp;
/* Assume we want to extract from i. */
temp.a = i;
j = temp.b[0];
k = temp.b[1];
l = temp.b[2];
m = temp.b[3];
/* Assume we want to assign j, k, l, m to i. */
temp.b[0] = j;
temp.b[1] = k;
temp.b[2] = l;
temp.b[3] = m;
i = temp.a;
/* -------------------------------------------------------- */

Example:
/* v2q15 Example */
v2q15 i;
q15 j, k;
v2q15_union temp;
/* Assume we want to extract from i. */
temp.a = i;
j = temp.b[0];
k = temp.b[1];
/* Assume we want to assign j, k to i. */
temp.b[0] = j;
temp.b[1] = k;
i = temp.a;

Using SIMD data types is a very powerful technique. Programmers can enjoy the performance
improvement from SIMD data types by calling the DSP built-in functions (see 29. Built-In Functions)
and/or using generic C operators. For SIMD data types, the compiler can map C operators (e.g.,
+, -, *, /) to hardware instructions directly, so long as the selected target PIC32 MCU features the
DSP-enhanced core.
Note: In many cases, optimization level -O1 or greater may be required to optimize the code to use
the SIMD instruction.
Here are some examples:
typedef signed char v4i8 __attribute__ ((vector_size(4)));
v4i8 a, b, c;
c = a + b; // compiler generates addu.qb
c = a - b; // compiler generates subu.qb
/* -------------------------------------------------------- */
typedef short v2q15 __attribute__ ((vector_size(4)));
v2q15 d, e, f;
f = d + e; // compiler generates addq.ph
f = d - e; // compiler generates subq.ph
/* -------------------------------------------------------- */
typedef short v2i16 __attribute__ ((vector_size(4)));
v2i16 x, y, z;
z = x * y; // compiler generates mul.ph
/* -------------------------------------------------------- */
typedef _Sat _Fract sat_v2hq __attribute__ ((vector_size(4)));
sat_v2hq a, b, c;
c = a + b; // compiler generates addq_s.ph
c = a - b; // compiler generates subq_s.ph
c = a * b; // compiler generates mulq_rs.ph

Note: When char or short data elements are packed into SIMD data types, the first data must be
aligned to 32 bits; otherwise, the unaligned memory accesses may generate general exceptions or
decrease performance.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 140

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support

12.7

Array Alignment and Data Layout
The compiler provides a mechanism to specify the alignment of variables by using __attribute__
((aligned (bytes))). The alignment is important to loading or storing SIMD variables: "v4i8"
and "v2q15". If an array is aligned to a 4-byte boundary, that is, word-aligned, the compiler can load
or store four 8-bit data for v4i8 variables (or two 16-bit data for v2q15 variables) at a time using the
load word class of instructions. The following example shows that when a char array A is aligned to
a 4-byte boundary, we can cast this array to a v4i8 array and load four items to a v4i8 variable at
a time by using the lwx instruction. However, if this char array A is not aligned to a 4-byte boundary,
executing the following code will result in an address exception due to a mis-aligned load.
Example:
/* v4i8 Example */
char A[128] __attribute__ ((aligned (4)));
v4i8 test (int i)
{
v4i8 a;
v4i8 *myA = (v4i8 *)A;
a = myA[i];
return a;
}
# Illustrative generated assembly with optimizations
test:
lui
$2,%hi(A)
sll
$4,$4,2
addiu
$2,$2,%lo(A)
lwx
$2,$2($4)
j
$31

After SIMD data is loaded from memory into a register, ensure that the SIMD variables in the
register are ready for use without requiring any rearrangement of the data. To avoid such data
rearrangement which can reduce the benefit of parallelism, design your array with an efficient data
layout that is favorable for SIMD calculations.

12.8

Operations on Fixed-Point Variables
Support for fixed-point types includes:
•

Prefix and postfix increment and decrement operators (++, --)

•

Unary arithmetic operators (+, -, !)

•

Binary arithmetic operators (+, -, *, /)

•

Binary shift operators (<<, >>)

•

Relational operators (<, <=, >=, >)

•

Assignment operators (+=, -=, *=, /=, <<=, >>=)

•

Conversions to and from integer, floating-point, or fixed-point types

The following example shows how fixed-point multiplication might be implemented for a PIC32M
device.
#include <stdfix.h>
sat fract test (sat fract a, sat fract b)
{
return (a * b);
}
# Illustrative generated assembly with optimizations
test:
mulq_rs.ph
$2,$4,$5
j
$31

12.9

Operations on SIMD Variables
Some specific C operators can be applied to SIMD variables. They are +, -, *, /, unary minus, ^,
|, &, ~. The DSP-enhanced core provides SIMD addition and subtraction instructions for v4i8 and

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 141

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support

v2q15, allowing the XC32 to generate appropriate instructions for addition and subtraction of v4i8
and v2q15 variables. For other operators, the compiler synthesizes a sequence of instructions.
The examples here show compiler-generated SIMD instructions when the appropriate operator is
applied to SIMD variables.
Example:
/* v4i8 Addition */
v4i8 test (v4i8 a, v4i8 b)
{
return a + b;
}
# Illustrative generated assembly with optimizations
test:
addu.qb $2, $4, $5
j
$31
# ----------------------------------------------------------

Example:
/* v4i8 Subtraction */
v4i8 test (v4i8 a, v4i8 b)
{
return a - b;
}
# Illustrative generated assembly with optimizations
test:
subu.qb $2, $4, $5
j $31
# ----------------------------------------------------------

Example:
/* v2q15 Addition */
v2q15 test (v2q15 a, v2q15 b)
{
return a + b;
}
# Illustrative generated assembly with optimizations
test:
addq.ph $2, $4, $5
j $31
# ----------------------------------------------------------

Example:
/* v2q15 Subtraction */
v2q15 test (v2q15 a, v2q15 b)
{
return a - b;
}
# Illustrative generated assembly with optimizations
test:
subq.ph $2, $4, $5
j
$31

In situations where your application requires special integer and fractional calculations and the
compiler cannot generate them automatically, you can use the DSP built-in functions (see 29. BuiltIn Functions).

12.10 DSP Built-In Functions
Built-in functions are very similar to standard function calls in syntax. Your application passes
parameters to a built-in function, and the built-in function returns the result to variables. The
difference between a built-in function and a standard function is that the compiler directly can
map the built-in function to a specific instruction sequence for better performance. The DSP built-in
functions are listed in (see 29. Built-In Functions).

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 142

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support

12.11 DSP Control Register
The DSP-enhanced core includes a DSP control register that has six fields: CCOND (condition code
bits), OUFLAG (overflow/underflow bits), EFI (extract fail indicator bit), C (carry bit), SCOUNT (size
count bits) and POS (position bits). The compiler treats the SCOUNT and POS fields as global
variables, such that instructions that modify SCOUNT or POS are never optimized away. These
instructions include WRDSP, EXTPDP, EXTPDPV, and MTHLIP. A function call that jumps to a function
containing WRDSP, EXTPDP, EXTPDPV, or MTHLIP is also never deleted by the compiler.
For correctness, you must assume that a function call clobbers all fields of the DSP control register.
That is, do not depend on the values in CCOND, OUFLAG, EFI or C across a function-call boundary.
Re-initialize the values of CCOND, OUFLAG, EFI or C before using them. Note that because SCOUNT
and POS fields are treated as global variables, the values of SCOUNT and POS are always valid
across function-call boundaries and can be used without re-initialization.
The following example shows possibly incorrect code. The first built-in function
"__builtin_mips_addsc" sets the carry bit (C) in the DSP control register, and the second built-in
function "__builtin_mips_addwc" reads the carry bit (C) from the DSP control register. However,
a function call "func" inserted between "__builtin_mips_addsc" and "__builtin_mips_addwc"
may change the carry bit to affect the correct result of "__builtin_mips_addwc".
Incorrect Ex:
int test (int a, int b, int c, int d)
{
__builtin_mips_addsc (a, b);
func();
// may clobber the carry bit
return __builtin_mips_addwc (c, d);
}

The previous example may be corrected by moving "func" before the first built-in function or after
the second built-in function as follows. p
Corrected Ex:
int test (int a, int b, int c, int d)
{
func();
// may affect the carry bit
__builtin_mips_addsc (a, b);
return __builtin_mips_addwc (c, d);
}
/* -------------------------------------------------------- */
int test (int a, int b, int c, int d)
{
int i;
__builtin_mips_addsc (a, b);
i = __builtin_mips_addwc (c, d);
func();
// may affect the carry bit
return i;
}

12.12 Using Accumulators
To access only HI or LO of an accumulator, use a union type as follows.
typedef union
{
long long a;
int b[2];
} a64_union;

// One 64-bit accumulator
// 32-bit HI and LO

To access HI, use b[1]. To access LO, use b[0].
Example:
int test (long long a, v2q15 b, v2q15 c)
{
a64_union temp;
temp.a = __builtin_mips_dpaq_s_w_ph (a, b, c);

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 143

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support
}

return temp.b[0];

// access LO.

12.13 Mixed-Mode Operations
12.13.1 Multiply "32-bit int * 32-bit int = 64-bit long long int"
Multiply "32-bit int * 32-bit int = 64-bit long long int"
To multiply 32 bits by 32 bits to obtain a 64-bit result, cast the 32-bit integer to a 64-bit integer (long
long) and then perform the multiplication operation as follows.
Example:
long long test (int a, int b)
{
return (long long) a * b;
// Same as (long long) a * (long long) b
// NOT the same as (long long) (a * b)
}

We can then access the highest 32-bit result from HI as follows.
Example:
typedef union
{
long long a;
// One 64-bit accumulator
int b[2];
// 32-bit HI and LO
} a64_union;
int test (int a, int b)
{
a64_union temp;
temp.a = (long long) a * b;
return temp.b[1]; // Access the HI 32 bits
}
# Illustrative generated assembly with optimizations
test:
mult
$4,$5
mfhi
$2
j
$31

12.13.2 Multiply and Add "32-bit int * 32-bit int + 64-bit long long = 64-bit long long int"
To perform multiplication and addition, cast the 32-bit integer to 64-bit (long long) and then perform
multiplication and addition as follows.
Example:
long long test (int a, int b, long long c)
{
return c + (long long) a * b;
}
# Illustrative generated assembly with optimizations
test:
mtlo $6
mthi $7
madd $4, $5
mflo $2
mfhi $3
j $31

12.14 Auto-Vectorization to SIMD
The compiler supports auto-vectorization for loops at optimization level -O3. The advantage of
auto-vectorization is that the compiler can recognize scalar variables (which can be integer, fixedpoint, or floating-point types) in order to utilize SIMD (Single Instruction, Multiple Data) instructions
automatically. In the ideal case, when auto-vectorization is used, there is no need to use SIMD
variables explicitly.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 144

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support

Example:
/* add8.c */
unsigned char a[32], b[32], c[32];
void add8() {
int i;
for (i = 0; i < 32; i++)
{
c[i] = a[i] + b[i];
}
}
# Illustrative generated assembly code
add8:
lui
v0,0x0
addiu
v0,v0,0
lui
a0,0x0
addiu
a0,a0,0
lui
v1,0x0
addiu
v1,v1,0
addiu
a3,v0,32
lw
a2,0(a0)
lw
a1,0(v0)
addiu
v0,v0,4
addiu
a0,a0,4
addu.qb a1,a2,a1
addiu
v1,v1,4
bne
v0,a3,1c <add8+0x1c>
sw
a1,-4(v1)
jr
ra

In add8.c, elements in two arrays of unsigned char are added together. The compiler
automatically generates the code for addu.qb to add four elements at a time.
For existing C code, try auto-vectorization at the -O3 optimization level without any modifications to
see if the compiler can auto vectorize the loops. In some cases, if the loop body is too complex, the
compiler will not be able to auto-vectorize the loop; in this case, you may choose to restructure and
simplify the loop.

12.15 FIR Filter Example Project
The DSP_Intrinsics example project shows the advantages of a FIR filter implementation based on
DSP Built-in Functions compared to traditional C code, without any DSP optimizations. First, the filter
is implemented for Q15 input data represented as arrays of short variables:
short coeff[BUFSIZE] __attribute__ ((aligned(4)));
short delay[BUFSIZE] __attribute__ ((aligned(4)));

The traditional C code version for Q15 inputs doesn't use SIMD variables or DSP Built-in Functions.
Instead, it implements the Q15 x Q15 multiplication by checking the saturation condition (both
operands are 0x8000 or -1) and then left shifting the integer multiplication result by 1 bit before
adding it to the accumulator.
long long FIR_Filter_Traditional_16(short *delay, short *coeff, int buflen)
{
int i;
short x, y;
// 64-bit accumulator for result
long long ac0 = 0;
for (i = 0; i < buflen; i++) {
x = coeff[i];
y = delay[i];
// check saturation condition
if ((unsigned short)x == 0x8000 && (unsigned short)y == 0x8000) {
ac0 += 0x7fffffff;
} else {
// multiply (Q15 x Q15) needs left shift
// result is added to accumulator variable
ac0 += ((x * y) << 1);

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 145

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support

}

}
}
return ac0;

For this C implementation the compiler generates inefficient assembly code. It does not have
enough information to auto-vectorize the loop.
# Illustrative generated assembly code
FIR_Filter_Traditional_16:
…
mul
$24,$13,$15
sll
$25,$24,1
addu
$12,$2,$25
sra
$9,$25,31
sltu
$11,$12,$2
addu
$3,$3,$9
move
$2,$12
addu
$3,$11,$3

In the DSP Intrinsics approach of the filter the input buffers are casted to the
v2q15 SIMD vector type defined above in section SIMD Variables. Inside the loop, the
"__builtin_mips_dpaq_s_w_ph" DSP built-in function is called. The result of the call is stored
in the accumulator variable, of type Q32.31 (64-bit), represented as integer type a64 (see definition
in section Integer representation of Q15 and Q31).
a64 FIR_Filter_Intrinsics_16(short *delay, short *coeff, int buflen)
{
int i;
v2q15 *my_delay = (v2q15 *)delay;
v2q15 *my_coeffs = (v2q15 *)coeff;
// 64-bit accumulator for result
a64 ac0 = 0;
for (i = 0; i < buflen/2; i++) {
ac0 = __builtin_mips_dpaq_s_w_ph (ac0,
my_delay[i],
my_coeffs[i]);
}
return ac0;
}

This function generates "dpaq_s.w.ph" assembly DSP instructions that apply the "Dot Product with
Accumulate" operation on two sets of Q15 values. The result is stored in one of the four 64-bit
accumulators in the DSP-enhanced core.
# Illustrative generated assembly code
FIR_Filter_Intrinsics_16:
…
mtlo
$0
mthi
$0
addiu
$8,$7,-1
li
$6,1
andi
$10,$8,0x7
dpaq_s.w.ph $ac0,$2,$3
addiu
$3,$4,4
beq
$6,$7,.L60
addiu
$2,$5,4

The project targets the PIC32MZ2048EFM144 device. The tools used are MPLAB X IDE v3.10,
MPLAB XC32 v1.40 compiler and PIC32 MZ EF Starter Kit/Simulator. Optimization level is set at
"-O3" with "-funroll-loops" option enabled. Using an internal timer to count the ticks during calls
to the 2 functions operating on the same Q15 data buffers reveals that the Intrinsics version is
approximately 4.52 times faster than the traditional C version.
Example timing output for input data buffers of size 2048:
16-bit without DSP Intrinsics: timer ticks 1180
16-bit with DSP Intrinsics: timer ticks: 261

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 146

XC32 Compiler for PIC32M
Fixed-Point Arithmetic Support

The project includes filter implementations for buffers of 32-bit integer data types using similar
approaches as for the previous 16-bit versions.
First implementation uses multiply and add operators. The 32-bit is casted to 64-bit before multiply
as it was described previously in 12.13.2. Multiply and Add "32-bit int * 32-bit int + 64-bit long long =
64-bit long long int":
for (i = 0; i < buflen; i++) {
acc += (long long)data[i] * coeff[i];
}
# Illustrative generated assembly code
FIR_Filter_32:
…
lwx
$24,$2($4)
lwx
$25,$2($5)
addiu
$2,$2,4
madd $ac0,$24,$25

The Intrinsics variant uses the "__builtin_mips_madd" to operate the multiply add.
for (i = 0; i < buflen; i++) {
acc = __builtin_mips_madd (acc, data[i], coeff[i]);
}
# Illustrative generated assembly code
FIR_Filter_Intrinsics_32:
…
lw
$17,0($3)
lw
$24,0($2)
addiu
$7,$7,1
addiu
$3,$3,4
addiu
$2,$2,4
madd $ac0,$17,$24

The tick counts for the 32-bit implementations are very similar. In both cases the compiler is now
generating the "MADD" DSP instructions.
Example timing output for input data buffers of size 2048:
32-bit without DSP Intrinsics: timer ticks 520
32-bit with DSP Intrinsics: timer ticks 484

12.16 Unsupported Features
The fixed-point conversion specifiers for formatted I/O, as described in Section 4.1.9 “Formatted I/O
functions for fixed-point arguments” of ISO/IEC TR 18037:2008, are not supported by the current
MPLAB XC32 standard C libraries. Fixed-point arguments must be used in formatted I/O routines by
conversion to or from an appropriate floating-point representation. For example:
#include <stdio.h>
#include <stdfix.h>
int main(void)
{
fract a = 0.5;
accum b;
double d;

}

scanf ("%lf", &d);
/* read into floating-point type */
b = (accum) d;
/* convert to fixed-point type */
printf ("%1.4f", (float) a); /* cast to floating-point type for output */
return 0;

The fixed-point functions described in Section 4.1.7 of ISO/IEC TR 18037:2008 are not provided by
the current MPLAB XC32 standard C libraries.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 147

XC32 Compiler for PIC32M
Operators and Statements

13.

13.1

Operators and Statements

The MPLAB XC32 C/C++ Compiler supports all ANSI operators. The exact results of some of
these are implementation-defined. Implementation-defined behavior is fully documented in 26. C
Implementation-Defined Behavior. The following sections illustrate code operations that are often
misunderstood, as well as additional operations that the compiler is capable of performing.

Integral Promotion

When there is more than one operand to an operator, they typically must be of exactly the same
type. The compiler will automatically convert the operands, if necessary, so they do have the same
type. The conversion is to a “larger” type so there is no loss of information; however, the change
in type can cause different code behavior to what is sometimes expected. These form the standard
type conversions.
Prior to these type conversions, some operands are unconditionally converted to a larger type, even
if both operands to an operator have the same type. This conversion is called integral promotion
and is part of Standard C behavior. The MPLAB XC32 C/C++ Compiler performs these integral
promotions where required, and there are no options that can control or disable this operation. If
you are not aware that the type has changed, the results of some expressions are not what would
normally be expected.
Integral promotion is the implicit conversion of enumerated types, signed or unsigned varieties
of char, short int or bit field types to either signed int or unsigned int. If the result of the
conversion can be represented by an signed int, then that is the destination type, otherwise the
conversion is to unsigned int.
Consider the following example:
unsigned char count, a=0, b=50;
if(a - b < 10)
count++;

The unsigned char result of a - b is 206 (which is not less than 10), but both a and b are
converted to signed int via integral promotion before the subtraction takes place. The result of
the subtraction with these data types is -50 (which is less than 10) and hence the body of the if()
statement is executed.
If the result of the subtraction is to be an unsigned quantity, then apply a cast. For example:
if((unsigned int)(a - b) < 10)
count++;

The comparison is then done using unsigned int, in this case, and the body of the if() would not
be executed.
Another problem that frequently occurs is with the bitwise compliment operator, ~. This operator
toggles each bit within a value. Consider the following code:
unsigned char count, c;
c = 0x55;
if( ~c == 0xAA)
count++;

If c contains the value 0x55, it often assumed that ~c will produce 0xAA, however the result is
0xFFFFFFAA and so the comparison in the above example would fail. The compiler may be able to
issue a mismatched comparison error to this effect in some circumstances. Again, a cast could be
used to change this behavior.
The consequence of integral promotion as illustrated above is that operations are not performed
with char -type operands, but with int -type operands. However there are circumstances when

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 148

XC32 Compiler for PIC32M
Operators and Statements

the result of an operation is identical regardless of whether the operands are of type char or int.
In these cases, the MPLAB XC32 C/C++ Compiler will not perform the integral promotion so as to
increase the code efficiency. Consider the following example:
unsigned char a, b, c;
a = b + c;

Strictly speaking, this statement requires that the values of b and c should be promoted to
unsigned int, the addition performed, the result of the addition cast to the type of a, and then
the assignment can take place. Even if the result of the unsigned int addition of the promoted
values of b and c was different to the result of the unsigned char addition of these values without
promotion, after the unsigned int result was converted back to unsigned char, the final result
would be the same. If an 8-bit addition is more efficient than a 32-bit addition, the compiler will
encode the former.
If, in the above example, the type of a was unsigned int, then integral promotion would have to
be performed to comply with the ANSI C standard.

13.2

Type References
Another way to refer to the type of an expression is with the typeof keyword. This is a nonstandard extension to the language. Using this feature reduces your code portability.
The syntax for using this keyword looks like sizeof, but the construct acts semantically like a type
name defined with typedef.
There are two ways of writing the argument to typeof: with an expression or with a type. Here is an
example with an expression:
typeof (x[0](1))
This assumes that x is an array of functions; the type described is that of the values of the functions.
Here is an example with a typename as the argument:
typeof (int *)
Here the type described is a pointer to int.
If you are writing a header file that must work when included in ANSI C programs, write _
_typeof_ _ instead of typeof.
A typeof construct can be used anywhere a typedef name could be used. For example, you can
use it in a declaration, in a cast, or inside of sizeof or typeof.
•

This declares y with the type of what x points to:
typeof (*x) y;

•

This declares y as an array of such values:
typeof (*x) y[4];

•

This declares y as an array of pointers to characters:
typeof (typeof (char *)[4]) y;
It is equivalent to the following traditional C declaration:
char *y[4];

To see the meaning of the declaration using typeof, and why it might be a useful way to write, let’s
rewrite it with these macros:
#define pointer(T) typeof(T *)
#define array(T, N) typeof(T [N])

Now the declaration can be rewritten this way:

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 149

XC32 Compiler for PIC32M
Operators and Statements

array (pointer (char), 4) y;
Thus, array (pointer (char), 4) is the type of arrays of four pointers to char.

13.3

Labels as Values
You can get the address of a label defined in the current function (or a containing function) with the
unary operator '&&'. This is a non-standard extension to the language. Using this feature reduces
your code portability.
The value returned has type void *. This value is a constant and can be used wherever a constant
of that type is valid. For example:
void *ptr;
...
ptr = &&foo;

To use these values, you need to be able to jump to one. This is done with the computed goto
statement, goto *exp;. For example:
goto *ptr;
Any expression of type void * is allowed.
One way of using these constants is in initializing a static array that will serve as a jump table:
static void *array[] = { &&foo, &&bar, &&hack };
Then you can select a label with indexing, like this:
goto *array[i];
Note: This does not check whether the subscript is in bounds. (Array indexing in C never does.)
Such an array of label values serves a purpose much like that of the switch statement. The switch
statement is cleaner and therefore preferable to an array.
Another use of label values is in an interpreter for threaded code. The labels within the interpreter
function can be stored in the threaded code for fast dispatching.
This mechanism can be misused to jump to code in a different function. The compiler cannot
prevent this from happening, so care must be taken to ensure that target addresses are valid for the
current function.

13.4

Conditional Operator Operands
The middle operand in a conditional expression may be omitted. Then if the first operand is
nonzero, its value is the value of the conditional expression. This is a non-standard extension to
the language. Using this feature reduces your code portability.
Therefore, the expression:
x ? : y
has the value of x if that is nonzero; otherwise, the value of y.
This example is perfectly equivalent to:
x ? x : y
In this simple case, the ability to omit the middle operand is not especially useful. When it becomes
useful is when the first operand does, or may (if it is a macro argument), contain a side effect.
Then repeating the operand in the middle would perform the side effect twice. Omitting the middle
operand uses the value already computed without the undesirable effects of recomputing it.

13.5

Case Ranges
You can specify a range of consecutive values in a single case label, like this:

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 150

XC32 Compiler for PIC32M
Operators and Statements

case low ... high:
This has the same effect as the proper number of individual case labels, one for each integer value
from low to high, inclusive. This is a non-standard extension to the language. Using this feature
reduces your code portability.
This feature is especially useful for ranges of ASCII character codes:
case 'A' ... 'Z':
Be careful: Write spaces around the..., otherwise it may be parsed incorrectly when you use it with
integer values. For example, write this:
case 1 ... 5:
rather than this:
case 1...5:

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 151

XC32 Compiler for PIC32M
Register Usage

14.

Register Usage
This chapter examines registers used by the compiler to generate assembly from C/C++ source
code.

14.1

Register Usage
When generating assembly from C/C++ source code, the compiler assumes that register contents
will not be modified by external functions according to the calling conventions, or by inline assembly
statements. The extended inline assembly syntax may be used to indicate the hardware registers
used and/or modified by inline assembly so that the compiler may generate correct code in the
presence of these statements.

14.2

Register Conventions
The 32 general purpose registers contained in the PIC32 are shown in the table below. Some of
these registers are assigned a dedicated task by the compiler. The name used in assembly code and
the usage is indicated.
Table 14-1. Register Conventions
Register Number

Software Name

$0

zero

Use
Always 0 when read.

$1

at

Assembler temporary variable. Do not
use the $at register from source
code unless you fully understand the
implications.

$2-$3

v0-v1

Return value from functions.

$4-$7

a0-a3

Used for passing arguments to
functions.

$8-$15

t0-t7

Temporary registers used by compiler
for expression evaluation. Values not
saved across function calls.

$16-$23

s0-s7

Temporary registers whose values are
saved across function calls.

$24-$25

t8-t9

Temporary registers used by compiler
for expression evaluation. Values not
saved across function calls.

$26-$27

k0-k1

Reserved for interrupt/trap handler.

$28

gp

Global Pointer.

$29

sp

Stack Pointer.

$30

fp or s8

Frame Pointer if needed. Additional
temporary saved register if not.

$31

ra

Return address for functions.

The PIC32MZ family uses the microMIPS compressed instruction-set architecture. You can use the
micromips function attribute to compile the function for the microMIPS compressed mode. This
compressed ISA generally results in a ~30% reduction in overall application code size at the expense
of ~2% in performance. The microcontroller can switch between the MIPS32 and microMIPS modes
on a function call. Consult your device data sheet to determine if your target device supports the
microMIPS ISA.
Example function:
#include <xc.h>
void
__attribute__((micromips))
peanut (void)
{

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 152

XC32 Compiler for PIC32M
Register Usage
}

// function code here

Important: Standard function calls can switch between MIPS32 and microMIPS
modes. However, when calling a MIPS32 library function from a microMIPS
function, the compiler may generate a compressed jals instruction to call
the library function. A jals instruction cannot change modes to MIPS32 and
upon linking, you may receive an error, “Unsupported jump between ISA modes;
consider recompiling with interlinking enabled.” In that case, add the -mno-jals
option to the Alternative Options field in your project properties for xc32-gcc, so it
is passed to the compiler.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 153

XC32 Compiler for PIC32M
Stack

15.

Stack
The software stack used with the PIC32M devices is discussed in this chapter.

15.1

Software Stack
The PIC32 devices use what is referred to in this user’s guide as a “software stack.” This is the
typical stack arrangement employed by most computers and is ordinary data memory accessed by
a push-and-pop type instruction and a stack pointer register. The term “hardware stack” is used
to describe the stack employed by Microchip 8-bit devices, which is only used for storing function
return addresses.
The PIC32 devices use a dedicated stack pointer register sp (register 29) for use as a software Stack
Pointer. All processor stack operations, including function calls, interrupts and exceptions, use the
software stack. It points to the next free location on the stack. The stack grows downward, towards
lower memory addresses.
By default, the size of the stack is 1024 bytes. The size of the stack can be changed by specifying
the size on the linker command line using the --defsym _min_stack_size linker command line
option. An example of allocating
a stack of 2048 bytes using the command line is:
xc32-gcc foo.c -Wl,--defsym,_min_stack_size=2048
The run-time stack grows downward from higher addresses to lower addresses. Two working
registers are used to manage the stack:
• Register 29 (sp) – This is the Stack Pointer. It points to the next free location on
the stack.
• Register 30 (fp) – This is the Frame Pointer. It points to the current function’s
frame.
No stack overflow detection is supplied.
The C/C++ run-time start-up module initializes the stack pointer during the start-up and initialization
sequence, see 18.2.3. Initialize Stack Pointer and Heap.

15.2

Call Frame
The stack is a memory region that grows dynamically at runtime. It starts at high address and grows
to lower address (stack grows downward).
The stack has call frames, each one containing data corresponding to an active function call.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 154

XC32 Compiler for PIC32M
Stack

Figure 15-1. Call Frame Diagram

A call frame contains:

15.3

•

return address

•

callee saved registers

•

parameters passed through stack

•

local variables

•

temporary variables (inserted by compiler)

•

interrupt context

Stack Guidance
Available with a PRO compiler license, the compiler's stack guidance feature can be used to estimate
the maximum depth of any stack used by a program.
Runtime stack overflows cause program failure and can be difficult to track down, especially when
the program is complex and interrupts are being used. The compiler's stack guidance feature
constructs and analyzes the call graph of a program, determines the stack usage of each function,
and produces a report, from which the depth of stacks used by the program can be inferred.
Monitoring a program's stack usage during its development will mitigate the possibility of stack
overflow situations.
This feature is enabled by the -mchp-stack-usage command-line option.
Once enabled, the operation of the stack guidance feature is fully automatic. For command-line
execution of the compiler, a report will be displayed directly to the console after a successful build.
When building in the MPLAB X IDE, this same report will be displayed in the build view in the Output
window.
A more detailed and permanent record of the stack usage information will be available in the map
file, should one be requested using the -Wl,-Map=mapfile command-line option or the equivalent
control in the MPLAB X IDE project properties.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 155

XC32 Compiler for PIC32M
Stack

15.3.1 What is a Stack Overflow?
A stack overflow can occur if the stack pointer exceeds the RAM address range reserved for the call
stack. When the application uses more space than is reserved for the stack, it can overwrite and
corrupt other data such as statically allocated variables and the heap. In addition, when those other
variables are accessed, they can corrupt values on the stack. This data corruption can be challenging
to debug and leads to unpredictable runtime behavior of the application.

15.3.2 Estimating Stack Usage
In a bare-metal embedded application, the application developer must determine an appropriate
minimum amount of data RAM to reserve for the stack and pass that value to the XC32 linker. The
linker then uses this value to ensure that sufficient RAM is reserved for the stack.
However, due to reasons described later, the exact stack requirements of an application can be
determined only at runtime. At link time, XC32 can use static analysis to estimate the maximum
stack size required by the application and provide guidance in a human-readable report. It does this
by computing the stack usage of each function and then using application's call graph to find the
largest stack usage.
Generally speaking, this report cannot provide you with an exact value, but it provides you with
information that you can use to determine an appropriate size for your stack reservation. Only you

understand the precise system-level, runtime behavior of your application.

15.3.3 Enabling the Stack Usage Report
The feature can be used only when a PRO XC32 license is present. The stack-usage report is enabled
through the -mchp-stack-usage command-line option, which is passed to XC32 when the Stack
Guidance checkbox is enabled in the MPLAB X Project Properties.
To enable Stack Usage Analysis from MPLAB X, set Stack Guidance in Project Properties>
XC32>Analysis.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 156

XC32 Compiler for PIC32M
Stack

Figure 15-2. Project Properties for Stack Guidance

or pass -mchp-stack-usage in command line.
xc32/<version>/bin/xc32-gcc -mprocessor=32MZ2048ECH100 -mchp-stack-usage -O0 test.c

15.3.4 Interpreting the Report
The stack-usage report is written:
•

Directly to standard error (either on terminal for command-line execution or in the MPLAB X
output window).

•

To the map file.

The same information is available in both places, but the map file can serve as a record for later
review.
The report contains:
•

The largest stack usage that could be determined by static analysis.

•

A list of reasons that the maximum stack usage couldn't be determined, such as recursion or
variable adjustment of the stack.

•

A list of disjoint and/or interrupt handler functions, which are not called directly by the main flow
of the program.

To determine the appropriate stack size for your application:

First, start with the initial value from the reset-handler call graph. In this example, the report shows
72 bytes required for the reset-handler call graph.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 157

XC32 Compiler for PIC32M
Stack

Stack Usage Report
============= STACK USAGE GUIDANCE =============
In the call graph beginning at Reset_Handler,
72 bytes of stack are required.

Second, add the listed stack allowances based on the system-level, runtime behavior of your
application.
Stack Usage Report
However, the following cautions exists:
1. The following functions cannot be connected to the main call graph.
This is usually caused by some indirection:
frame_dummy uses 8 bytes
Dummy_Handler uses 0 bytes
__libc_init_array uses 40 bytes
You must add stack allowances for those functions.
================================================

Third, add stack allowances for your Interrupt handlers (interrupt service routines) as described in
the following section.

15.3.4.1 MIPs Interrupts

The use of interrupts increases a program's stack usage, but an estimate of the additional memory
used is properly reported through the stack guidance feature.
The PIC32M devices allow nesting of interrupts based on a priority level; however, nesting can be
disabled as required by specifying the keep_interrupts_masked attribute with those interrupt
functions that should not be interruptable. The stack guidance feature is aware of the use of this
attribute and the function's interrupt priority level, and will report the maximum possible stack
usage of the configuration of interrupt functions. A worst case scenario is computed if required and
will be the stack usage of the interrupt functions that have the highest stack usage per priority level,
summed over each level.

15.3.5 Stack Usage Limitations
Static estimation of the maximum stack usage is inaccurate if the application contains functions
falling in at least one of the following categories:
•

Functions for which the stack usage information is not available (not compiled/assembled with
-mchp-stack-usage).

•

Functions containing indirect calls to other functions (the callees can not be identified).

•

Functions containing variable stack adjustments, inline assembly, or stack-usage information
generated by the assembler (which might be inaccurate).

•

Recursive functions (direct or indirect) - only if at least one of the functions in the cycle has
non-zero stack consumption.

For each of these cases, a list of the involved functions is provided.
Be aware that the stack-usage estimation for assembly files may be inaccurate if your assembly
code adjusts the stack. Be sure to take these adjustments into account when estimating your stack
usage.

15.3.6 Example Stack Report
For this simple example, assumed to be stored in a file named test.c,
int max(int a, int b){
if (a < b)
return b;
return a;
}

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 158

XC32 Compiler for PIC32M
Stack
int main() {
int a[10], i, j;

}

for (i =0; i < 10; i++)
a[i] = i;
for (i = 0; i < 10; i++)
a[i] = max(a[i], a[10-i/2]);
return a[0];

when built with:
xc32-gcc -mprocessor=32MZ2048ECH100 -mchp-stack-usage -O0 mips_stack_guidance.c

the compiler will print the following stack-usage report.
============= STACK USAGE GUIDANCE =============
In the call graph beginning at _reset,
104 bytes of stack are required.
However, the following cautions exists:
1. Indeterminate stack adjustment has been detected:
_main_entry uses 104 bytes
__pic32_software_reset uses 24 bytes
No stack usage predictions can be made.
2. The following functions cannot be connected to the main call graph.
This is usually caused by some indirection:
__DbgExecReturn uses 24 bytes
_bev_exception uses 48 bytes
_gen_exception uses 136 bytes
simple_tlb_refill_vector uses 136 bytes
_cache_err_vector uses 136 bytes
__pic32_size_cache uses 0 bytes
_DefaultInterrupt uses 24 bytes
You must add stack allowances for those functions.
================================================

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 159

XC32 Compiler for PIC32M
Functions

16.

Functions
The following sections describe how function definitions are written, and specifically how they can
be customized to suit your application. The conventions used for parameters and return values, as
well as the assembly call sequences are also discussed.

16.1

Writing Functions
Functions may be written in the usual way in accordance with the C/C++ language.
The only specifier that has any effect on function is static. Interrupt functions are defined with the
use of the interrupt attribute, see 16.2. Function Attributes and Specifiers.
A function defined using the static specifier only affects the scope of the function, that is, limits
the places in the source code where the function may be called. Functions that are static may only
be directly called from code in the file in which the function is defined. The equivalent symbol used
in assembly code to represent the function may change if the function is static, see 10.2.2. Static
Variables. This specifier does not change the way the function is encoded.

16.2

Function Attributes and Specifiers

16.2.1 Function Attributes
address(addr)
The address attribute specifies an absolute physical address at which the attributed routine will be
placed in memory. It can be used with C and C++ functions.
The address attribute specifies an absolute virtual address for the function. Be sure to specify the
address attribute using an appropriate virtual address for the target device. The address is typically
in the range [0x9D000000,0x9D0FFFFC], as defined in the linker script as the kseg0_program_mem
memory region. For example:
__attribute__((address(0x9D008000))) void bar (void);

The compiler performs no error checking on the address. The section containing the function will be
located at the specified address regardless of the memory-regions specified in the linker script or
the actual memory ranges on the target device. The application code must ensure that the address
is valid for the target device.
To make effective use of absolute sections and the new best-fit allocator, standard programmemory and data-memory sections should not be mapped in the linker script. The built-in linker
script does not map most standard sections such as the .text, .data, .bss, or .ramfunc sections.
By not mapping these sections in the linker script, we allow these sections to be allocated using the
best-fit allocator rather than the sequential allocator. Sections that are unmapped in the linker script
can flow around absolute sections, whereas sections that are linker-script mapped are grouped
together and allocated sequentially, potentially causing conflicts with absolute sections.
alias ("symbol")
Indicates that the function is an alias for another symbol. For example:
void foo (void) { /* stuff */ }
__attribute__ ((alias("foo"))) void bar (void);

Symbol bar is considered to be an alias for the symbol foo.
always_inline
If the function is declared inline, always inline the function, even if no optimization level was
specified.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 160

XC32 Compiler for PIC32M
Functions

at_vector
Place the body of the function at the indicated exception vector address.
See 17. Interrupts and 17.4. Exception Handlers.
const
If a pure function determines its return value exclusively from its parameters (that is, does not
examine any global variables), it may be declared const, allowing for even more aggressive
optimization. Note that a function which de-references a pointer argument is not const since the
pointer de-reference uses a value which is not a parameter, even though the pointer itself is a
parameter.
deprecated
deprecated (msg)
When a function specified as deprecated is used, a warning is generated. The optional msg
argument, which must be a string, will be printed in the warning if present. The deprecated
attribute may also be used for variables and types.
externally_visible
This attribute when used with a function, nullifies the effect of the -fwhole-program commandline option, so the function remains visible outside the current compilation unit. This might prevent
certain optimizations from being performed on the function.
far
Always invoke the function by first loading its address into a register and then using the contents of
that register. This allows calling a function located beyond the 28-bit addressing range of the direct
CALL instruction.
format (type, format_index, first_to_check)
The format attribute indicates that the function takes a printf, scanf, strftime, or strfmon
style format string and arguments and that the compiler should type check those arguments against
the format string, just as it does for the standard library functions.
The type parameter is one of printf, scanf, strftime or strfmon (optionally with surrounding
double underscores, for example, __printf__) and determines how the format string will be
interpreted.
The format_index parameter specifies which function parameter is the format string. Function
parameters are numbered from the left-most parameter, starting from 1.
The first_to_check parameter specifies which parameter is the first to check against the format
string. If first_to_check is zero, type checking is not performed and the compiler only checks the
format string for consistency (for example, vfprintf).
format_arg (index)
The format_arg attribute specifies that a function manipulates a printf style format string and
that the compiler should check the format string for consistency. The function attribute which is a
format string is identified by index.
function_replacement_prologue
This feature allows the application to redirect one function to another implementation at runtime
without replacing the existing function. This is achieved by changing the method of invoking
functions through a function replacement table instead of from a linker-resolved address. Initially
the function address in the table points to the location of the entry point of the original function's
prologue. The application can then replace the table entry with the new function address. Now,

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 161

XC32 Compiler for PIC32M
Functions

during the program execution, the control will pass to the new function address and returns to the
caller function. This feature adds a new function_replacement_prologue function attribute. To
redirect the function, modify the corresponding Function Replacement Table entry at runtime.
Example C code:
int a, b, c, d;
int __attribute__((function_replacement_prologue)) foo (void)
{
a = b + c;
return (a);
}
int main()
{
d = foo();
return 0;
}

Example generated assembly code:
# Function Replacement Table entries, located in data memory
.section .fixtable, data
fixtable.foo:
.word
cont.foo
# By default, populate the table with the address
# of the original implementation. Redirect to
# another implementation by overwriting this
# location with the address of the new implementation.
.section .text, code
.globl foo
.ent foo
.type foo, @function
foo:
# Begin Function Replacement Table Prologue
lui $25,%hi(fixtable.foo)
# Load address from .fixtable above
lw $25,%lo(fixtable.foo)($25)
j $25
# Jump to address loaded from table
nop
cont.foo:
# End Function Replacement Table Prologue
addiu $sp,$sp,-8
sw $fp,4($sp)
move $fp,$sp
lw $3,%gp_rel(b)($28)
...........
j $31
nop

interrupt (priority)
Generate prologue and epilogue code for the function as an interrupt handler function. See
17. Interrupts . The argument specified the interrupt priority level using the symbols IPLnSOFT,
IPLnSRS, or IPLnAUTO where n represents the 7 levels of priority and SOFT|SRS|AUTO specifies the
context saving mode.
keep
The __attribute__((keep)) may be applied to a function. The keep attribute will prevent the
linker from removing the function with --gc-sections, even if it is unused.
void __attribute__((keep)) foo(void);
longcall
Functionally equivalent to far.
malloc
Any non-Null Pointer return value from the indicated function will not alias any other pointer which
is live at the point when the function returns. This allows the compiler to improve optimization.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 162

XC32 Compiler for PIC32M
Functions

micromips
Generate code for the function in the compressed microMIPS instruction set.
mips16
Generate code for the function in the MIPS16 instruction set.
naked
Generate no prologue or epilogue code for the function. This attribute is intended for functions
that exclusively contain extended inline assembly code. Using C code within such an attributed
function might not work properly. Since the compiler will not generate prologue or epilogue code
for functions using this attribute, the application code within is responsible for managing the stack
and additionally handling formal parameters, return values, and the function return.
near
Always invoke the function with an absolute CALL instruction, even when the -mlong-calls
command line option is specified.
no_fpu
The no_fpu attribute must be used in conjunction with the interrupt (priority) attribute and
specifies that the interrupt service routine (ISR) should not preserve the Floating-Point Unit (FPU)
context. In addition it causes the compiler to insert code into the ISR that will disable the FPU,
by clearing the CU1 bit of the CP0 Status register. If your ISR attempts to perform floating-point
operations while the FPU is disabled, the device will trigger a general exception. This also means
that any higher-priority ISR interrupting an ISR using the no_fpu attribute must re-enable the FPU
if floating-point operations are required. The ISR restores the original value of the status register
before returning from the interrupt.
noinline
The function will never be considered for inlining.
noload
Causes the variable or function to be placed in a section that has the noload attribute set. It tells
consumers of the ELF files not to load the contents of the section. This attribute can be useful when
you just want to reserve memory for something, but you don’t want to clear or initialize memory.
void bar() _ attribute_ ((noload))
nomips16
®

Always generate code for the function in the MIPS32 instruction set, even when compiling the
translation unit with the -mips16 command line option.
nonnull (index, ...)
Indicate to the compiler that one or more pointer arguments to the function must be non-null. If
the compiler determines that a Null Pointer is passed as a value to a non-null argument, and the
-Wnonnull command line option was specified, a warning diagnostic is issued.
If no arguments are given to the nonnull attribute, all pointer arguments of the function are
marked as non-null.
noreturn
Indicate to the compiler that the function will never return. In some situations, this can allow
the compiler to generate more efficient code in the calling function since optimizations can be
performed without regard to behavior if the function ever did return. Functions declared as
noreturn should always have a return type of void.
optimize(optimization)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 163

XC32 Compiler for PIC32M
Functions

The optimize attribute allows a function to be built with optimizations that differ from what
has been specified on the command line and which will be applied to the rest of the program.
The optimization argument can either be a number or a string. String arguments represent
the command-line option used to control an optimization, for example, to enable peephole
optimizations (-fpeephole), use optimize("peephole"). The -f option prefix does not need
to be specified with the argument. If you want to specify more than one optimization, separate the
arguments with commas but with no space characters. Arguments that begin with O are assumed
to be an optimization level option, for example optimize("O1,unroll-loops") turns on level
1 optimizations and the unroll-loops optimizations (controlled by the -funroll-loops commandline option). A numerical argument is also assumed to be an optimization level, for example
optimize(3) turns on level 3 optimizations and is equivalent to the full usage of the attribute
in the following example.
int __attribute__((optimize("O3"))) pandora (void) {
if (maya > axton)
return 1;
return 0;
}

This feature can be used, for instance, to have frequently executed functions compiled with more
aggressive optimization options that produce faster and larger code, while other functions can be
called with less aggressive options. Typically, however, it is not used for production builds.
pure
If a function has no side effects other than its return value, and the return value is dependent
only on parameters and/or (nonvolatile) global variables, the compiler can perform more aggressive
optimizations around invocations of that function. Such functions can be indicated with the pure
attribute.
ramfunc
The ramfunc attribute locates the attributed routine in RAM rather than in Flash memory on devices
that normally execute code from Flash. This attribute can be used for both C functions and C++ class
methods. The compiler's default runtime startup code uses the data-initialization template to copy
the code associated with functions using this attribute from Flash to RAM at program startup.
When this attribute is used with C functions, the function is placed at the highest appropriately
aligned address for executable code. Note that due to ramfunc alignment and placement
requirements, the address attribute should not be used with the ramfunc attribute. The presence
of the ramfunc section causes the linker to emit the symbols necessary for the crt0.S start-up
code to initialize the bus matrix appropriately for executing code out of data memory.
Use this attribute along with the far/longcall attribute and the section attribute. For example:
__attribute__((ramfunc,section(".ramfunc"),far,unique_section))
unsigned int myramfunct (void_
{ /* code */ }

A macro in the <sys/attribs.h> header file makes the ramfunc attribute simple to use:
#include <sys/attribs.h>
__longramfunc__ unsigned int
{ /* code */ }

myramfunct (void)

In C++ code, the attribute can be used with class methods, as shown in the following example.
class printmyname {
// Access specifier
public:
// Data Members
string myname;
int dummy ;
// Member Functions()
printmyname (){

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 164

XC32 Compiler for PIC32M
Functions
}

};

myname = "microchip";

void __attribute__((ramfunc, long_call)) set_name(string newname){
myname = newname;
dummy = 9;
}
void printname() { cout << "name is:" << myname; }

section("name")
Place the function into the named section.
For example:
void __attribute__ ((section (".wilma"))) baz () {return;}
Function baz will be placed in section .wilma.
The -ffunction-sections command line option has no effect on functions defined with a
section attribute.
unique_section
Place the function in a uniquely named section, as if -ffunction-sections had been specified. If
the function also has a section attribute, use that section name as the prefix for generating the
unique section name.
For example:
void __attribute__ ((section (".fred"), unique_section) foo (void) {return;}
Function foo will be placed in section .fred.foo.
unused
Indicate to the compiler that the function may not be used. The compiler will not issue a warning for
this function if it is not used.
used
Indicate to the compiler that the function is always used and code must be generated for the
function even if the compiler cannot see a reference to the function. For example, if inline assembly
is the only reference to a static function.
vector (num)
Generate a branch instruction at the indicated exception vector which targets the function. See
17. Interrupts and 17.4. Exception Handlers.
warn_unused_result
A warning will be issued if the return value of the indicated function is unused by a caller.
weak
A weak symbol indicates that if another version of the same symbol is available, that version should
be used instead. For example, this is useful when a library function is implemented such that it can
be overridden by a user written function.

16.3

Allocation of Function Code
Code associated with C/C++ functions is normally always placed in the program Flash memory of the
target device.
Functions may be located in and executed from RAM rather than Flash by using the __ramfunc__
and __longramfunc__ macros.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 165

XC32 Compiler for PIC32M
Functions

Functions specified as a RAM function will be copied to RAM by the start-up code and all calls to
those functions will reference the RAM location. Functions located in RAM will be in a different
512MB memory segment than functions located in program memory, so the longcall attribute
should be applied to any RAM function, which will be called from a function not in RAM. The
__longramfunc__ macro will apply the longcall attribute as well as place the function in RAM.
#include <sys/attribs.h>
/* function ‘foo’ will be placed in RAM */
void __ramfunc__ foo (void)
{
}
/* function ‘bar’ will be placed in RAM and will be invoked
using the full 32 bit address */
void __longramfunc__ bar (void)
{
}

Note: Specifying __longramfunc__ is functionally equivalent to specifying both __ramfunc__
and __longcall__.

16.4

Changing the Default Function Allocation
The assembly code associated with a C/C++ function can be placed at an absolute address. This can
be accomplished by using the address attribute and specifying the virtual address of the function,
see 9.11. Variable Attributes.
Functions can also be placed at specific positions by placing them in a user-defined section and then
linking this section at an appropriate address, see 9.11. Variable Attributes.

16.5

Function Size Limits
There are no theoretical limits as to how large functions can be made.

16.6

Function Parameters
MPLAB XC uses a fixed convention to pass arguments to a function. The method used to pass the
arguments depends on the size and number of -arguments involved.
Note: The names “argument” and “parameter” are often used interchangeably, but typically an
argument is the actual value that is passed to the function and a parameter is the variable defined
by the function to store the argument.
The Stack Pointer is always aligned on an 8-byte boundary.
•

All integer types smaller than a 32-bit integer are first converted to a 32-bit value. The first four
32 bits of arguments are passed via registers a0-a3 (see the table below for how many registers
are required for each data type).

•

Although some arguments may be passed in registers, space is still allocated on the stack for all
arguments to be passed to a function (see the figure below). Application code should not assume
that the current argument value is on the stack, even when space is allocated.

•

When calling a function:
– Registers a0-a3 are used for passing arguments to functions. Values in these registers are
not preserved across function calls.
– Registers t0-t7 and t8-t9 are caller saved registers. The calling function must push these
values onto the stack for the registers’ values to be saved.
– Registers s0-s7 are called saved registers. The function being called must save any of these
registers it modifies.
– Register s8 is a saved register if the optimizer eliminates its use as the Frame Pointer. s8 is a
reserved register otherwise.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 166

XC32 Compiler for PIC32M
Functions

– Register ra contains the return address of a function call.
Table 16-1. Registers Required
Data Type

Number of Registers Required

char

1

short

1

int

1

long

1

long long

2

float

1

double

1

long double

2

structure

Up to 4, depending on the size of the struct.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 167

XC32 Compiler for PIC32M
Functions

Figure 16-1. Passing Arguments

16.7

Function Return Values
Function return values are returned in registers.
Integral or pointer value are placed in register v0. All floating-point values, regardless of precision,
are returned in floating-point register $f0.
If a function needs to return an actual structure or union – not a pointer to such an object – the
called function copies this object to an area of memory that is reserved by the caller. The caller
passes the address of this memory area in register $4 when the function is called. The function also
returns a pointer to the returned object in register v0. Having the caller supply the return object’s
space allows re-entrance.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 168

XC32 Compiler for PIC32M
Functions

16.8

Calling Functions
By default, functions are called using the direct form of the call (jal) instruction. This allows calls to
destinations within a 256 MB segment. This operation can be changed through the use of attributes
applied to functions or command-line options so that a longer, but unrestricted, call is made.
The -mlong-calls option, see 5.7.1. Options Specific to PIC32M Devices, forces a register form of
the call to be employed by default. Generated code is longer, but calls are not limited in terms of the
destination address.
The attributes longcall or far can be used with a function definition to always enforce the longer
call sequence for that function. The near attribute can be used with a function so that calls to it use
the shorter direct call, even if the -mlong-calls option is in force.

16.9

Inline Functions
By declaring a function inline, you can direct the compiler to integrate that function’s code into the
code for its callers. This usually makes execution faster by eliminating the function-call overhead.
In addition, if any of the actual argument values are constant, their known values may permit
simplifications at compile time, so that not all of the inline function’s code needs to be included. The
effect on code size is less predictable. Machine code may be larger or smaller with inline functions,
depending on the particular case.
Note: Function inlining will only take place when the function’s definition is visible (not just the
prototype). In order to have a function inlined into more than one source file, the function definition
may be placed into a header file that is included by each of the source files.
To declare a function inline, use the inline keyword in its declaration, like this:
inline int
inc (int *a)
{
(*a)++;
}

If you are using the -ansi option, write __inline__ instead of inline. You can also make
all “simple enough” functions inline with the command-line option -finline-functions. The
compiler heuristically decides which functions are simple enough to be worth integrating in this
way, based on an -estimate of the function’s size.
Note: The inline keyword will only be recognized with -finline or optimizations enabled.
Certain usages in a function definition can make it unsuitable for inline substitution. Among these
usages are: use of varargs, use of alloca, use of variable-sized data, use of computed goto and
use of nonlocal goto. Using the command-line option -Winline will warn when a function marked
inline could not be substituted and will give the reason for the failure.
In compiler syntax, the inline keyword does not affect the linkage of the function.
When a function is both inline and static, if all calls to the function are integrated into the
caller and the function’s address is never used, then the function’s own assembler code is never
referenced. In this case, the compiler does not actually output assembler code for the function,
unless you specify the command-line option -fkeep-inline-functions. Some calls cannot be
integrated for various reasons (in particular, calls that precede the function’s definition cannot be
integrated and neither can recursive calls within the definition). If there is a non-integrated call, then
the function is compiled to assembler code as usual. The function must also be compiled as usual
if the program refers to its address, because that can’t be inlined. The compiler will only eliminate
inline functions if they are declared to be static and if the function definition precedes all uses
of the function.
When an inline function is not static, then the compiler must assume that there may be calls
from other source files. Since a global symbol can be defined only once in any program, the function

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 169

XC32 Compiler for PIC32M
Functions

must not be defined in the other source files, so the calls therein cannot be integrated. Therefore, a
non-static inline function is always compiled on its own in the usual fashion.
If you specify both inline and extern in the function definition, then the definition is used only for
inlining. In no case is the function compiled on its own, not even if you refer to its address explicitly.
Such an address becomes an external reference, as if you had only declared the function and had
not defined it.
This combination of inline and extern has a similar effect to a macro. Put a function definition
in a header file with these keywords and put another copy of the definition (lacking inline and
extern) in a library file. The definition in the header file will cause most calls to the function to be
inlined. If any uses of the function remain, they will refer to the single copy in the library.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 170

XC32 Compiler for PIC32M
Interrupts

17.

Interrupts
Interrupt processing is an important aspect of most microcontroller applications. Interrupts may be
used to synchronize software operations with events that occur in real time. When interrupts occur,
the normal flow of software execution is suspended, and special functions are invoked to process
the event. At the completion of interrupt processing, previous context information is restored and
normal execution resumes.
PIC32 devices support multiple interrupts, from both internal and external sources. The devices
allow high-priority interrupts to override any lower priority interrupts that may be in progress.
The compiler provides full support for interrupt processing in C/C++ or inline assembly code. This
section presents an overview of interrupt processing.

17.1

Interrupt Operation
The compiler incorporates features allowing interrupts to be fully handled from C/C++ code.
Interrupt functions are often called interrupt handlers or Interrupt Service Routines (ISRs).
Each interrupt source typically has a control bit in an SFR which can disable that interrupt source.
Check your device data sheet for full information how your device handles interrupts.

Interrupt code is the name given to any code that executes as a result of an interrupt occurring.
Interrupt code completes at the point where the corresponding return from interrupt instruction
is executed. This contrasts with main-line code, which, for a freestanding application, is usually the
main part of the program that executes after Reset.

17.2

Writing an Interrupt Service Routine
An interrupt handler function is different than an ordinary function in that it handles the context
save and restore to ensure that upon return from interrupt, the program context is maintained. A
different code sequence is used to return from these functions as well.
Several attributes can be used to ensure that the compiler generates the correct code for an ISR.
Macros are provided so that this is easier to accomplish, see the following sections.
There are several actions that the compiler needs to take to generate an interrupt service routine.
The compiler has to be told to use an alternate form of return code. The function also needs to be
®
linked to the interrupt vector. All ISRs must use either the MIPS32 r2 or the microMIPS™ ISA modes.
Apply the 'nomips16' function attribute to each interrupt function.
Note: For devices that support multiple Instruction Set Architecture (ISA) modes, there may be a
configuration bit that determines which mode the device uses for an exception/interrupt. If your
device is configured to use the microMIPS ISA on interrupt, be sure to apply the micromips function
attribute to your interrupt function. Consult your the data sheet for your target device to determine
if it supports handling exceptions and interrupts in an alternate ISA mode.
An interrupt function must be declared as type void and may not have parameters. This is the only
function prototype that makes sense for an interrupt function since they are never directly called in
the source code.
Interrupt functions must not be called directly from C/C++ code (due to the different return
instruction that is used), but they themselves may call other functions, both user-defined and library
functions, but be aware that this may use additional registers which will need to be saved and
restored by the context switch code.
A function is marked as an interrupt handler function, or ISR, via either the interrupt attribute or
the interrupt pragma*. While each method is functionally equivalent to the other, the interrupt
attribute is more commonly used and therefore the recommended method. The interrupt is
specified as handling interrupts of a specific priority level or for operating in single vector mode.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 171

XC32 Compiler for PIC32M
Interrupts

For all interrupt vectors without specific handlers, a default interrupt handler will be installed. The
default interrupt handler is supplied by the libpic32.a library and will cause a debug breakpoint and
reset the device. An application may override the default handler and provide an application-specific
default interrupt handler by declaring an interrupt function with the name _DefaultInterrupt.
Note: * Pre-processor macros are not expanded in pragma directives.

17.2.1 Interrupt Attribute
Use the interrupt attribute to indicate that the specified function is an interrupt handler. The
compiler generates function entry and exit sequences suitable for use in an interrupt handler when
this attribute is present. The generated code preserves context by either using a shadow register set
(SRS) or using generated software instructions (SOFT) to push context onto the stack.
The attribute has the general form:
__attribute__((interrupt([IPLn[SRS|SOFT|AUTO]])))

where n is in the range of 0 through 7, inclusive.
Example 17-1. Interrupt Attribute
void __attribute__((interrupt(IPL7SRS))) bambam (void)
{
// interrupt code goes here
}

When programming in C++, the interrupt handler symbol must be allocated to the C namespace,
which can be accomplished using extern "C" with the definition, for example:
extern "C"
void __attribute__((interrupt(IPL7SRS))) bambam (void)
{
// interrupt code goes here
}
®

Note: Some PIC32 target devices allow the exception/interrupt code to be in either the MIPS32 or
microMIPS™ ISA mode via a device configuration bit (BOOTISA). On these devices, if your BOOTISA
bit is set to microMIPS mode, add the 'micromips' attribute to your interrupt function. If your
BOOTISA bit is set to MIPS32 mode, add the 'nomicromips' attribute to your interrupt function. See
your device data sheet for more information on this configuration bit.
Many PIC32 devices allow us to specify, via configuration-bit settings, which interrupt priority level
will use the shadow register set (for example, #pragma config FSRSSEL=PRIORITY_7). Refer to
the device data sheet to determine if your PIC32 target device supports this feature. This means
we must specify which context-saving mechanism to use for each interrupt handler. The compiler
will generate interrupt function prologue and epilogue code utilizing shadow register context saving
for the IPLnSRS Interrupt Priority Level (IPL) specifier. It will use software context saving for the
IPLnSOFT IPL specifier.
Other PIC32 variants may have 8 register sets (1 standard set and 7 shadow register sets) meaning
that there are enough shadow register sets for every interrupt priority level. Therefore, you should
use the IPLnSRS IPL specifier for every interrupt service routine on these device variants.
Note: Application code is responsible for applying the correct IPL specifier value to each ISR.
The interrupt source’s priority level must match the ISR’s IPL value (for example, IPLnSRS) or the
interrupt will not be handled correctly. Mismatching priority levels may result in critical runtime
problems such as a stack overflow that overwrites data memory. This can include corruption of
memory reserved for use by the Debug Executive, causing the debug tool to behave erratically.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 172

XC32 Compiler for PIC32M
Interrupts

The compiler also supports an IPLnAUTO IPL specifier that uses the run-time value in SRSCTL to
determine whether it should use software or SRS context-saving code. The compiler defaults to
using IPLnAUTO when the IPL specifier is omitted from the interrupt() attribute.
For devices that do not support a shadow register set for interrupt context saving, use IPLnSOFT for
all interrupt handlers.
Note: SRS has the shortest latency and SOFT has a longer latency due to registers saved on the
stack. AUTO adds a few cycles to test if SRS or SOFT should be used.
For IPL7(SRS | SOFT | AUTO), the compiler assumes that nothing can interrupt priority 7. This
means that there is no reason to save EPC or SRSCtl and that global disabling of interrupts is
unnecessary.
The IPLnSAVEALL interrupt priority specifier can be used with the interrupt attribute. Use this
specifier in place of IPLnSOFT to force software context saving of all software-saved general
registers even if they are not used within the Interrupt Service Routine (ISR). This attribute can
be useful for some RTOS implementations.
The keep_interrupts_masked attribute can be used to modify the behavior of an interrupt
handler. The attribute keeps interrupts masked for the whole function. Without this attribute, the
XC32 compiler re-enables interrupts for as much of the function as it can. By keeping interrupts
masked, support for nested interrupts is disables. Users can re-enable them as necessary in their
own code.
The attribute keep_interrupts_masked can be combined with the interrupt attribute. This
attribute causes the Interrupt Service Routine (ISR) prologue code to not re-enable interrupts.
Application code may then choose whether and when to re-enable interrupts in the ISR.

17.2.2 Interrupt Pragma
Note: The interrupt pragma is provided only for compatibility when porting code from other
compilers. The interrupt function attribute is the preferred and more common way to write an
interrupt service routine.
# pragma interrupt function-name IPLn[AUTO|SOFT|SRS] [vector [@]vector-number [, vector-numberlist]]
# pragma interrupt function-name single [vector [@] 0

Where n is in the range of 0..7, inclusive.
The IPLn[AUTO|SOFT|SRS] IPL specifier may be all uppercase or all lowercase.
The function definition for a handler function indicated by an interrupt pragma must follow in the
same translation unit as the pragma itself.
The interrupt attribute will also indicate that a function definition is an interrupt handler. It is
functionally equivalent to the interrupt pragma.
For example, the definitions of foo below both indicate that it is an interrupt handler function for an
interrupt of priority 4 that uses software context saving.
#pragma interrupt foo IPL4SOFT
void foo (void)

is functionally equivalent to
void __attribute__ ((interrupt(IPL4SOFT))) foo (void)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 173

XC32 Compiler for PIC32M
Interrupts

17.2.3 __ISR Macros
The <sys/attribs.h> header file provides macros intended to simplify the application of
attributes to interrupt functions. There are also vector macros defined in the processor header
files. (See the appropriate header file in the compiler’s /pic32mx/include/proc directory.)
Note: Some PIC32 target devices allow the exception/interrupt code to be in either the MIPS32® or
microMIPS™ ISA mode via a device configuration bit (BOOTISA). On these devices, if your BOOTISA
bit is set to microMIPS mode, add the 'micromips' attribute to your interrupt function. If your
BOOTISA bit is set to MIPS32 mode, add the 'nomicromips' attribute to your interrupt function. See
your device data sheet for more information on this configuration bit.
__ISR(V, IPL)
Use the __ISR(v, IPL) macro to assign the vector-number location and associate it with the
specified IPL. This will place a jump to the interrupt handler at the associated vector location. This
macro also applies the nomips16 attribute since PIC32 devices require that interrupt handlers must
use the MIPS32 instruction set.
The following example creates an interrupt handler function for the core timer interrupt that has
an interrupt priority level of two. The compiler places a dispatch function at the associated vector
location. To reach this function, the core timer interrupt flag and enable bits must be set, and the
interrupt priority should be set to a level of two. The compiler generates software context-saving
code for this handler function.
Example 17-2. Core Timer Vector, IPL2SOFT
#include <xc.h>
#include <sys/attribs.h>
void __ISR(_CORE_TIMER_VECTOR, IPL2SOFT) CoreTimerHandler(void);

The example below creates an interrupt handler function for the core software interrupt 0 that has
an interrupt priority level of three. The compiler places a dispatch function at the associated vector
location. To reach this function, the core software interrupt flag and enable bits must be set, and
the interrupt priority should be set to a level of three. The device configuration fuses must assign
Shadow Register Set 1 to interrupt priority level three. The compiler generates code that assumes
that register context will be saved in SRS1.
Example 17-3. Core Software 0 Vector, IPL3SRS
#include <xc.h>
#include <sys/attribs.h>
void __ISR(_CORE_SOFTWARE_0_VECTOR,IPL3SRS) CoreSoftwareInt0Handler(void);

The example below creates an interrupt handler function for the core software interrupt 1 that has
an interrupt priority level of zero. The compiler places a dispatch function at the associated vector
location. To reach this function, the core software interrupt 1 flag and enable bits must be set, and
the interrupt priority should be set to a level of zero. The compiler generates code that determines
at run time whether software context saving is required.
Example 17-4. Core Software 1 Vector, IPL0AUTO
#include <xc.h>
#include <sys/attribs.h>
void __ISR(_CORE_SOFTWARE_1_VECTOR, IPL0AUTO) CoreSoftwareInt1Handler(void);

The next example is functionally equivalent to Example 14-4. Because the IPL specifier is omitted,
the compiler assumes IPL0AUTO.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 174

XC32 Compiler for PIC32M
Interrupts

Example 17-5. Core Software 1 Vector, Default
#include <xc.h>
#include <sys/attribs.h>
void __ISR(_CORE_SOFTWARE_1_VECTOR) _CoreSoftwareInt1Handler(void);

__ISR_AT_VECTOR(v, IPL)
Use the __ISR_AT_VECTOR(v, IPL) to place the entire interrupt handler at the vector location
and associate it with the software-assigned interrupt priority. Application code is responsible for
making sure that the vector spacing is set to accommodate the size of the handler. This macro also
applies the nomips16 attribute since ISR functions are required to be MIPS32.
The following example creates an interrupt handler function for the core timer interrupt that has an
interrupt priority level of two. The compiler places the entire interrupt handler at the vector location.
It does not use a dispatch function. To reach this function, the core timer interrupt flag and enable
bits must be set, and the interrupt priority should be set to a level of two. The compiler generates
software context-saving code for this handler function.
Example 17-6. Core Timer Vector, IPL2SOFT
#include <xc.h>
#include <sys/attribs.h>
void __ISR_AT_VECTOR(_CORE_TIMER_VECTOR, IPL2SOFT) CoreTimerHandler(void);

INTERRUPT-VECTOR MACROS
Each processor-support header file provides a macro for each interrupt-vector number (for
example, /pic32mx/include/proc/p32mx360f512l.h. See the appropriate header file in the
compiler install directory). When used in conjunction with the __ISR() macro provided by the
sys\attribs.h header file, these macros help make an Interrupt Service Routine easier to write
and maintain.
The example below creates an interrupt handler function for the Timer 1 interrupt that has an
interrupt priority level of seven. The compiler places a dispatch function at the vector location
associated with macro _TIMER_1_VECTOR as defined in the device-specific header file. To reach this
function, the Timer 1 interrupt flag and enable bits must be set, and the interrupt priority should be
set to a level of seven. For devices that allow assignment of shadow registers to specific IPL values,
the device Configuration bit settings must assign Shadow Register Set 1 to interrupt priority level
seven. The compiler generates code that assumes that register context will be saved in SRS1.
Example 17-7. Interrupt-Vector with Handler
#include <xc.h>
#include <sys/attribs.h>
void __ISR (_TIMER_1_VECTOR, IPL7SRS) Timer1Handler (void);

17.3

Associating a Handler Function with an Exception Vector
For PIC32 devices, each interrupt source is mapped to an exception vector, as specified in the device
data sheet. For devices with a constant vector spacing, a default of four words of space are reserved
at each vector address for a dispatch to the handler function for that exception source. For devices
with a variable vector spacing, the default linker script adjusts each vector's spacing for the size of
the designated interrupt function.
An interrupt handler function can be associated with an interrupt vector either as the target of
a dispatch function located at the exception vector address, or as being located directly at the
exception vector address. A single handler function can be the target of multiple dispatch functions.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 175

XC32 Compiler for PIC32M
Interrupts

The association of a handler function to one or more exception vector addresses is specified via
a vector attribute on the function declaration. For compatibility purposes, you may also associate
a handler function to a vector address using a clause of the interrupt pragma, a separate vector
pragma, or a vector attribute on the function declaration.

17.3.1 Vector Attribute
A handler function can be associated with one or more exception vector addresses via an attribute.
The at_vector attribute indicates that the handler function should itself be placed at the
exception vector address. The vector attribute indicates that a dispatch function should be created
at the exception vector address(es) which will transfer control to the handler function.
For example, the following declaration specifies that function foo will be created as an interrupt
handler function of priority four. foo will be located at the address of exception vector 54.
void __attribute__ ((interrupt(IPL4SOFT))) __attribute__ ((at_vector(54)))
foo void);
The following declaration specifies that function foo will be created as an interrupt handler function
of priority four. Define dispatch functions targeting foo at exception vector addresses 52 and 53.
void __attribute__ ((interrupt(IPL4SOFT))) __attribute__ ((vector(53, 52)))
foo void)
Handler functions that are linked directly to the vector will be executed faster. Although the vector
spacing can be adjusted, there is limited space between vectors and linking a substantial handler
function directly at a vector may cause it to overlap the higher vector locations, preventing their use.
In such situations, using a dispatch function is a safer option.
The newer devices family features variable offsets for vector spacing. The compiler and linker work
together to treat the OFFnnn SFRs as initialized data so that they are initialized at startup. This
means there is no need for application code to initialize the OFFnnn SFRs. This also means that it is
often more efficient to place the ISR within the vector table rather than using a dispatch function.
Example 17-8. Example Interrupt Service Routine
#include <xc.h>
#include <sys/attribs.h>
void
__ISR_AT_VECTOR(_CORE_TIMER_VECTOR, IPL7SRS)
CoreTimerHandler(void)
{
// ISR code here
}

17.3.2 Interrupt-Pragma Vector Clause
Note: The interrupt pragma and its vector clause are provided only for compatibility when porting
code from other compilers. The vector function attribute is the preferred way to associate a handler
function to an exception vector address.
The interrupt pragma has an optional vector clause following the priority specifier.
# pragma interrupt function-nameIPL-specifier [vector [@]vector-number [,
vector-number-list]]
A dispatch function targeting the specified handler function will be created at the exception vector
address for the specified vector numbers. If the first vector number is specified with a preceding “@”
symbol, the handler function itself will be located there directly.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 176

XC32 Compiler for PIC32M
Interrupts

For example, the following pragma specifies that function foo will be created as an interrupt
handler function of priority four. foo will be located at the address of exception vector 54. A
dispatch function targeting foo will be created at exception vector address 34.
#pragma interrupt foo IPL4AUTO vector @54, 34
The following pragma specifies that function bar will be created as an interrupt handler function
of priority five. bar will be located in general purpose program memory (.text section). A dispatch
function targeting bar will be created at exception vector address 23.
#pragma interrupt bar IPL5SOFT vector 23

17.3.3 Vector Pragma
Note: The vector pragma is provided only for compatibility when porting code from other
compilers. The vector function attribute is the preferred way to associate a handler function to
an exception vector address.
The vector pragma creates one or more dispatch functions targeting the indicated function.
For target functions specified with the interrupt pragma, this functions as if the vector clause
had been used. The target function of a vector pragma can be any function, including external
functions implemented in assembly or by other means.
# pragma vector function-name vector vector-number [, vector-number-list]
The following pragma defines a dispatch function targeting foo at exception vector address 54.
#pragma vector foo 54

17.4

Exception Handlers
The PIC32 devices also have exception vectors for non-interrupt exceptions. These exceptions are
grouped into bootstrap exceptions and general exceptions.

17.4.1 Bootstrap Exception
A Reset exception is any exception which occurs while bootstrap code is running (StatusBEV=1). All
Reset exceptions are vectored to 0xBFC00380.
At this location, the 32-bit toolchain places a branch instruction targeting a function named
_bootstrap_exception_handler(). In the standard library, a default weak version of this
function is provided, which merely causes a software Reset. When compiling for in-circuit debugging
or emulation, the default implementation of _bootstrap_exception_handler will first cause a
software breakpoint and then a software Reset. If the user application provides an implementation
of _bootstrap_exception_handler(), that implementation will be used instead.

17.4.2 General Exception
A general exception is any non-interrupt exception which occurs during program execution outside
of bootstrap code (StatusBEV=0). General exceptions are vectored to offset 0x180 from EBase.
At this location, the 32-bit toolchain places a branch instruction targeting a function named
_general_exception_context(). The provided implementation of this function saves context,
calls an application handler function, restores context and performs a return from the exception
instruction. The context saved is the hi and lo registers, and all General Purpose Registers except
s0-s8, which are defined to be preserved by all called functions and so are not necessary to actively
save here again.
void _general_exception_handler (void);
A weak default implementation of _general_exception_handler() is provided in the standard
library which merely causes a software Reset. When compiling for in-circuit debugging or
emulation, the default implementation of _general_exception_handler will first cause a

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 177

XC32 Compiler for PIC32M
Interrupts

software breakpoint and then a software Reset. If the user application provides an implementation
of _general_exception_handler(), that implementation will be used instead.

17.4.3 Simple TLB Refill Exception
During an instruction fetch or data access, a TLB refill exception occurs when no TLB entry matches
a reference to a mapped address space and the EXL bit is 0 in the Status register. Note that this is
distinct from the case in which an entry matches, but has the valid bit off. In that case, a TLB Invalid
exception occurs.
void _simple_tlb_refill_exception_handler(void);
A weak default implementation of _simple_tlb_refill_exception_handler() is provided
which merely causes a software Reset.
When compiling for in-circuit debugging or emulation, the default implementation of
_simple_tlb_refill_exception_handler will first cause a software breakpoint and then a
software Reset.

17.4.4 Cache Error Exception
A cache-error exception occurs when an instruction or data reference detects a cache tag or data
error. This exception is not maskable. To avoid disturbing the error in the cache array the exception
vector is to an unmapped, uncached address. This exception is precise.
void _cache_err_exception_handler(void);
A weak default implementation of _cache_err_exception_handler() is provided which merely
causes a software Reset. When compiling for in-circuit debugging or emulation, the default
implementation of _cache_err_exception_handler will first cause a software breakpoint and
then a software Reset.

17.5

Context Switching

The compiler will automatically link code into your project which saves the current status when an
interrupt occurs and then restores this status when the interrupt returns.

17.5.1 Context Save on Interrupt
The standard calling convention for C/C++ functions will already preserve zero, s0-s7, gp, sp,
and fp. k0 and k1 are used by the compiler to access and preserve non-GPR context, but are
always accessed atomically (that is, in sequences with global interrupts disabled), so they need not
be preserved actively. A handler function will actively preserve the a0-a3, t0-t9, v0, v1 and ra
registers in addition to the standard registers.
An interrupt handler function will also actively save processor status registers that are utilized by the
handler function. Specifically, the EPC, SR, hi and lo registers are preserved as context. All available
DSP accumulators are preserved as necessary.
In addition, if a DSP accumulator register is preserved, the DSP Control register is also preserved.
Handler functions may use a shadow register set to preserve the General Purpose Registers,
enabling lower latency entry into the application code of the handler function. On some devices,
the shadow register set is assigned to an interrupt priority level (IPL) using the device Configuration
bit settings (for example, #pragma config FSRSSEL=PRIORITY_6). While on other devices, the
shadow register set may be hard wired to IPL7. Consult the target device’s data sheet for more
information on the shadow register set.
By default, the compiler saves the Floating-point Unit (FPU) general registers and the FCSR register
on the stack as required for interrupt() attributed functions. This includes functions that use the
__ISR(vector,priority) macro. As always, to minimize the required context saving for an ISR,
avoid making calling functions from within the ISR so that the compiler generates code for only the
registers used within the ISR.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 178

XC32 Compiler for PIC32M
Interrupts

The no_fpu function attribute can be used to suppress context saving of the FPU register. For
example:
void __attribute__((interrupt(IPL7SRS),vector(_CORE_TIMER_VECTOR),no_fpu)) ct_isr(void)
{
foo();
}

It also causes the compiler to disable the FPU in the ISR prologue, such that any use of the FPU from
within the ISR context would result in a general exception. This means that any higher-priority ISR
interrupting an ISR using the no_fpu attribute must re-enable the FPU if floating-point operations
are required.

17.5.2 Context Restoration

Any objects saved by software are automatically restored by software before the interrupt function
returns. The order of restoration is the reverse to that used when context is saved.
If the no_fpu function attribute has been used with an interrupt function, the FPU-enable bit is
restored to its original state in the function's epilogue code.

17.6

17.7

Latency

There are two elements that affect the number of cycles between the time the interrupt source
occurs and the execution of the first instruction of your ISR code. These are:
•

Processor Servicing of Interrupt – The amount of time it takes the processor to recognize the
interrupt and branch to the first address of the interrupt vector. To determine this value, refer to
the processor data sheet for the specific processor and interrupt source being used.

•

ISR Code – The compiler saves the registers that were used by the ISR. Moreover, if the ISR calls
an ordinary function, then the compiler will save all the working registers, even if they are not all
used explicitly in the ISR itself. This must be done, because the compiler cannot know, in general,
which resources are used by the called function.

Nesting Interrupts

Interrupts may be nested. The interrupt priority scheme implemented in the PIC32 architecture
allows you to specify which interrupt sources may be interruptible by others. See your device data
sheet for explicit details on interrupt operation.
The compiler Interrupt Service Routine prologue code automatically re-enables interrupts by
default.

17.8

17.9

Enabling/Disabling Interrupts

The built-in functions __builtin_get_isr_state and __builtin_set_isr_state can be
used to check and set the Interrupt Priority Level and Interrupt Enable bits. The
__builtin_disable_interrupts and __builtin_enable_interrupts built-in functions can
be used to disable and enable interrupts. See 29.1. Built-In Function Descriptions for a description
of these built-in functions.

ISR Considerations

There are a few things to consider when writing an interrupt service routine.
As with all compilers, limiting the number of registers used by the interrupt function, or any
functions called by the interrupt function, may result in less context switch code being generated
and executed by the compiler, see 17.6. Latency. Keeping interrupt functions small and simple will
help you achieve this.
When interrupt latency is a concern, avoid calling other functions from your ISR. You may be able to
replace a function call with a volatile flag that is handled by your application's main control loop.
If you are building with link-time optimizations (the -flto option), you might need to take special
steps to ensure that code associated with interrupts is not removed. These optimizations for the

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 179

XC32 Compiler for PIC32M
Interrupts

most part work on the whole program. When the whole program is analyzed, interrupt functions will
be found to be not called by any other function, so the compiler believes it can remove them. To
prevent this from occurring, interrupt functions must be marked with the used attribute to inform
the compiler that they are not redundant. The same attribute should be used with data objects that
are used by interrupt functions. As an alternative, consider building source files containing interrupt
functions with link-time optimizations disabled.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 180

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

18.

Main, Runtime Start-up and Reset
When creating C/C++ code, there are elements that are required to ensure proper program
operation: a main function must be present; start-up code will be needed to initialize and clear
variables and setup registers and the processor; and Reset conditions will need to be handled.

18.1

The Main Function
The identifier main is special. It must be used as the name of a function that will be the first
function to execute in a program. You must always have one and only one function called main in
your programs. Code associated with main, however, is not the first code to execute after Reset.
Additional code provided by the compiler and known as the runtime start-up code is executed first
and is responsible for transferring control to the main() function.

18.2

Runtime Start-Up Code
A C/C++ program requires certain objects to be initialized and the processor to be in a particular
state before it can begin execution of its function main(). It is the job of the runtime start-up code
to perform these tasks before the execution of main().
If you require any additional initialization to be performed, you typically do not need to modify the
default runtime startup code provided by the compiler. That would only be required if any of the
existing actions taken by the startup code needed to be changed. The special On Reset and On
Bootstrap hooks allow the startup code to be customized at various places in the startup sequence.
The PIC32 start-up code will perform the following tasks, which are discussed in the sections that
follow.
1. Switch to the selected instruction set (ISA) mode.
2. Jump to NMI handler (_nmi_handler) if an NMI occurred.
3. Initialize stack pointer and heap.
4. Initialize global pointer in all register sets available on the selected target device.
5. Call the application-provided “on reset” routine (_on_reset).
6. Call the __pic32_init_cache routine to initialize the L1 cache on target devices that feature an
L1 cache.
7. Call the __pic32_tlb_init_ebi_sqi routine to initialize the TLB on -target devices that use
pre-mapped EBI and SQI external memory regions.
8. Clear uninitialized small bss sections.
9. Initialize data using the linker-generated data-initialization template.
10. If the target device that features a bus matrix and the application uses a RAM function, initialize
the bus matrix for execution from data memory.
11. Initialize the CP0 registers, including the enabling of the DSPr2 engine and Floating-Point Unit
(FPU) for devices on which these are implemented.
12. Call the “On Bootstrap” routine (_on_bootstrap).
13. Change the location of exception vectors.
14. For C++, call the C++ initialization code to invoke all constructors for file-scope static storage
objects.
15. Call main().
16. On return from main(), call exit() if the CALL_EXIT macro is defined; otherwise, enter an
infinite loop.
The following provisions are made regarding the run-time model:

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 181

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

•

Kernel mode only

•

KSEG1 only

•

RAM functions are attributed with __ramfunc__ or __longramfunc__, (defined in sys/
attribs.h), meaning that all RAM functions end up in the .ramfunc section and the function
is ramfunc attributed.

18.2.1 Switch to the Selected Instruction Set (ISA) Mode
Some PIC32 MCUs support both the MIPS32 and microMIPS Instruction Set Architecture (ISA)
modes. The microMIPS instruction set delivers the same functionality as the MIPS32 ISA, with the
added benefit of smaller code size.
Devices that support both the MIPS32 and microMIPS ISA modes use the BOOTISA configuration bit
in a device Configuration Word to determine the ISA mode on boot. The device can be configured
to boot to either the MIPS32 or the microMIPS ISA mode. See the target-device data sheet for more
information on the BOOTISA bit.
The microMIPS ISA supplies assembler-source code compatibility with MIPS32 instead of binary
compatibility. Because of this, the XC32 toolchain provides a copy of the runtime start-up code
compiled for the MIPS32 ISA as well as a copy compiled for the microMIPS ISA. The toolchain
determines which copy to link based on the presence of the -mmicromips command-line option.
In the MPLAB X IDE project properties, select xc32-ld >Option category: Libraries> "Link microMIPS
compressed startup code and libraries" to get the -mmicromips option.
For added flexibility, the default start-up code attempts to ensure that the linked Precompiled mode
matches the current ISA mode at runtime. To enable this, a binary code sequence is required that
can be run in either instruction set and change code paths, depending on the instruction set that is
being used.
The following binary sequence achieves this goal:
0x1000wxyz
0x00000000

// where w,x,y,z represent hexadecimal digits

For the MIPS32 instruction set, this binary sequence is interpreted as:
// branch to location of more MIPS32 instructions
BEQ $0, $0, wxyz
NOP

For the microMIPS instruction set, this binary sequence is interpreted as:
ADDI32 $0, $0, wxyz // do nothing
NOP
// fall through to more microMIPS instructions

In the default runtime startup-code, we place this binary sequence at the _reset symbol, which is
then located at the reset vector by the default linker script. We follow this binary sequence with a
jal _startup to jump to the remainder of the startup code.
This sequence is included only for devices that support both the MIPS32 and microMIPS ISA modes.
On PIC32M devices, bit 0 of the address indicates the ISA mode. When this bit is clear, the device is
running in MIPS32 Mode. When this bit is set, the device is running in either MIPS16 or microMIPS
mode, depending on the device core. This means that if you execute a hard-coded jump, bit 0 must
be set to the appropriate value for your target function. Hard-coded jumps are most commonly
seen when jumping from a bootloader to a bootloaded application.

18.2.2 Jump to NMI Handler (_nmi_handler) if an NMI Occurred
If a Non-Maskable Interrupt (NMI) caused entry to the Reset vector, which is located at 0xBFC00000
on PIC32M MIPS cores, the startup code’s _reset function jumps to an NMI Handler procedure

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 182

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

named _nmi_handler. A weak version of the NMI handler procedure is provided that performs an
ERET.
To override the default NMI Handler with an application-specific handler, use an assembly-code .S
file to create a routine named __nmi_handler. This routine must be written in assembly code
because the startup code calls this routine before the C runtime environment is initialized. The
__nmi_handler routine must either use only the k0, k1 CPU registers or it must save context before
using other registers.

18.2.3 Initialize Stack Pointer and Heap
The Stack Pointer (sp) register must be initialized in the start-up code. To enable the start-up code to
initialize the sp register, the linker must initialize a variable which points to the end of KSEG0/KSEG1
data memory.
Note: The end of data memory is different based on whether RAM functions exist. If RAM functions
exist, then part of the DRM must be configured for the kernel program to contain the RAM
functions, and the Stack Pointer is located one word prior to the beginning of the DRM kernel
program boundary address. If RAM functions do not exist, then the Stack Pointer is located at the
true end of DRM.
The linker allocates the stack to KSEG0 on devices featuring an L1 data cache. It allocates the stack
to KSEG1 on devices that do not have an L1 cache.
This variable is named _stack. The user can change the minimum amount of stack space
allocated by providing the command line option --defsym _min_stack_size=N to the linker.
_min_stack_size is provided by the linker script with a default value of 1024. On a similar note,
the user may wish to utilize a heap with their application. While the start-up code does not need to
initialize the heap, the standard C libraries (sbrk) must be made aware of the heap location and its
size. The linker creates a variable to identify the beginning of the heap. The location of the heap is
the end of the utilized KSEG0/KSEG1 data memory.
The linker allocates the heap to KSEG0 on devices that have an L1 cache. It allocates the heap to
KSEG1 on devices that do not have an L1 cache.
This variable is named _heap. A user can change the minimum amount of heap space allocated by
providing the command line option --defsym=_min_heap_size=M to the linker. If the heap is used
when the heap size is set to zero, the behavior is the same as when the heap usage exceeds the
minimum heap size. Namely, it overflows into the space allocated for the stack.
The heap and the stack use the unallocated KSEG0/KSEG1 data memory, with the heap starting from
a low address in KSEG0/KSEG1 data memory, and growing upwards towards the stack while the
stack starts at a higher address in KSEG1 data memory and grows downwards towards the heap.
The linker attempts to allocate the heap and stack together in the largest gap of memory available
in the KSEG0/KSEG1 data memory region. If enough space is not available based on the minimum
amount of heap size and stack size requested, the linker issues an error.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 183

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

Figure 18-1. Stack and Heap Layout

Figure 18-2. Stack and Heap Layout with RAM Functions

The linker must then group all of the above input sections together. This grouping is handled by
the default linker script. The run-time start-up code must initialize the gp register to point to the
“middle” of this output section. To enable the start-up code to initialize the gp register, the linker
script must initialize a variable which is 32 KB from the start of the output section containing the
“small” variables and constants. This variable is named _gp (to match core linker scripts). Besides
being initialized in the standard GPR set, the Global Pointer must also be initialized in the register
shadow set.

18.2.4 Initialize Global Pointer
The compiler toolchain supports Global Pointer (gp) relative addressing. Loads and stores to data
residing within 32KB of either side of the address stored in the gp register can be performed in a
single instruction using the gp register as the base register. Without the Global Pointer, loading data
from a static memory area takes two instructions – one to load the Most Significant bits of the 32-bit
constant address computed by the compiler/linker and one to do the data load.
To utilize gp-relative addressing, the compiler and assembler must group all of the “small” variables
and constants into one of the following sections:
.lit4.

lit8

.sdata.

sbss

.sdata.*

sbss.*

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 184

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset
.gnu.linkonce.s.*

.gnu.linkonce.sb.*

The linker must then group all of the above input sections together. This grouping is handled by
the default linker script. The run-time start-up code must initialize the gp register to point to the
“middle” of this output section. To enable the start-up code to initialize the gp register, the linker
script must initialize a variable which is 32 KB from the start of the output section containing the
“small” variables and constants. This variable is named _gp (to match core linker scripts).
Some PIC32 MCUs have more than one register set. The additional register sets can be used as
interrupt shadow register sets. The Global Pointer must be initialized in each of the register sets.
The default start-up code does this by looping through each of the register sets.
In the loop, the CP0 SRSCtl register's PSS field must be set to the shadow set in which to initialize
the global pointer. In the source code, we start with the highest register set, as defined by the
PIC32_SRS_SET_COUNT macro, and work down to zero. By initializing the global pointer in the
previous set as iterate through the register sets, we initialize the register in each of the sets on the
device.

18.2.5 The “On Reset” Routine
Some hardware configurations require special initialization, often within the first few instruction
cycles after Reset. For instance, you might need to initialize a DDR RAM controller before the
program's variables are initialized. To achieve this, there is an On Reset hook provided, so that you
do not need to customize the entire startup code sequence.
An empty weak implementation of the On Reset routine (_on_reset) is provided with the start-up
code. It is called by the runtime startup code after minimal initialization of the C/C++ language
context.
If you do need to implement your own version of this routine, you can modify the following stub
(note the leading underscore character in the function’s name).
void _on_reset(void)
{
// Add code to be executed soon after reset here
}

This routine can be placed into any source file in your project and you do not need to adjust any
compiler options to have it executed.
Special consideration needs to be taken when writing this routine in C or C++. The code should
not assume that the runtime environment has been fulled established. See 18.2. Runtime StartUp Code for the order in which the environment is set up. Most importantly, statically allocated
variables will not have been initialized (with either the specified initializer or a zero value, as
required for uninitialized variables), nor will any static constructors have been called for C++
applications. References to non-automatic variables in C/C++ applications might yield unexpected
or unpredictable results; however, the stack pointer will have been initialized.

18.2.6 Initialize L1 Cache
If the target device implements a L1 cache, this is automatically initialized by the runtime
startup code. Based on the definition of the symbol INIT_L1_CACHE, the startup code will call
the __pic32_init_cache assembly routine, which will initialize the primary instruction and
primary data caches and ensure the cache and line sizes for both caches are appropriately
configured. By default, the instruction cache will use a base address that corresponds to the
kseg0_program_mem memory region and the data cache will use a base address that corresponds
to the kseg0_data_mem memory region.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 185

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

18.2.7 Initialize Translation Lookaside Buffer
Some PIC32 devices feature a Memory Management Unit (MMU) with a Translation Lookaside Buffer
(TLB). On some of these devices, the data sheet describes specific ranges of KSEG2/KSEG3 regions as
being dedicated to the Serial Quad Interface (SQI) and/or the External Bus Interface (EBI).
For these devices, the default runtime startup code will call the __pic32_tlb_init_ebi_sqi
assembly routine that initializes the TLB from a table of values (.tlb_init_values) defined in the
linker script.

18.2.8 Clearing Objects
The runtime start-up code will clear all memory locations occupied by uninitialized variables so they
will contain zero before main() is executed.
Variables whose contents should be preserved over a Reset should use the persistent attribute,
see 9.9. Standard Type Qualifiers for more information. Such variables are linked in a different area
of memory and are not altered by the runtime start-up code in any way.

18.2.9 Initialize Objects and RAM Functions
Objects accessed from RAM and functions executed from RAM must have their allocated RAM
initialized before execution of the main() function can commence, and this is a significant task
performed by the runtime startup code.
Those non-auto objects that are uninitialized must be cleared (assigned the value 0) before
execution of main() begins. Such objects are not assigned a value in their definition, for example
output in the following example:
int output;
int main(void) { ...

Another task of the runtime start-up code is to ensure that any initialized objects contain their initial
value before the program begins execution. Initialized objects are those that are not auto objects
and that are assigned an initial value in their definition, for example input in the following example:
int input = 0x88;
int main(void) { ...

Such initialized objects have two components: their initial value (0x0088 in the above example)
stored in program memory (that is, placed in the HEX file), and space reserved in RAM, where the
objects will reside and be accessed during program execution (runtime).
Four initialized data sections exist: .sdata, .data, .lit4, and .lit8. The .sdata section is
a data segment containing initialized objects less than or equal to n bytes, as specified by the
-Gn command line option. The .data section is a data segment containing initialized objects not
included in .sdata. The .lit4 and .lit8 sections contain constants, (usually floating-point) which
the assembler stores in memory rather than in the instruction stream.
The runtime start-up code will copy all the blocks of initial values from program memory to RAM so
the objects will contain the correct values before main() is executed.
Since auto objects are dynamically created, they require code to be positioned in the function in
which they are defined to perform their initialization. It is possible that the initial value of an auto
object may change on each instance of the function and so the initial values cannot be stored in
program memory and copied. As a result, initialized auto objects are not considered by the runtime
start-up code, but are instead initialized by assembly code in each function output.
Note: Initialized auto objects can impact code performance, particularly if the objects are large in
size. Consider using global or static objects instead.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 186

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

Objects whose contents should be preserved over a Reset should be qualified with the persistent
attribute, see 9.9. Standard Type Qualifiers. Such objects are linked at a different area of memory
and are not altered by the runtime start-up code in any way.
Any functions that use the ramfunc attribute are copied from program memory to RAM before
they are executed. This is also performed by the runtime startup code, in much the same way that
initialized objects have their initial value copied before they are accessed.

18.2.9.1 Data-initialization Template
In order to clear or initialize all the data and RAM function sections, the linker creates a datainitialization template, which is loaded into an output section named .dinit and allocated space in
program memory. The code in the C/C++ start-up module, crt0.o, interprets this template, which
indicates how the appropriate sections must be initialized.
The sections initialized by this template includes those holding intialized objects (such as the .data
section) as well as sections containing ramfunc attributed functions, all of which must have values
copied from the template in program to data memory where the objects and functions will be
accessed at runtime. Other data sections holding unititialized objects (such as the .bss section) are
cleared by the template before the main() function is called. The persistent data section (.pbss) is
not considered by the runtime startup code. When the application’s main program takes control, all
objects and RAM functions in data memory will have been initialized.
The data initialization template contains one record for each output section that needs initializing.
Each record has one of several formats, represented by a format code within the record. The record
formats specify how the data values are stored in the record itself and how they should be used to
initialize the corresponding section. The --dinit-compression linker option (see 5.7.10.1. Dinitcompression Option) controls which of these records can be utilized by the template. The numerical
format codes and the type of initialization they represent are as follows:
#0

Fill the RAM defined by the corresponding output section with zeros. No data bytes are stored in the
record. Used by bss sections.

#1

Copy each byte of data from the record's array to the RAM associated with the output section. Used by
data and lit sections, and sections associated with ramfunc functions.

#2

Copy the same 16-bit value into the RAM associated with the output section multiples times. Used by
data and lit sections whose initial values are a repeating sequence.

#3

Copy the same 32-bit value into the RAM associated with the output section multiple times. Used by
data and lit sections whose initial values are a repeating sequence.

#4

Copy and decompress a simplified version of PackBits encoded data_record. Used by data and lit
sections, and sections associated with ramfunc functions which contain large numbers of consecutive
zero bytes.

The data contained in each record type can be represented by the equivalent C structures that are
presented below. The first element of the record is a pointer to the section in data memory. The
second element is the section length or repeat count. The third element is the format code, which
indicates the type of the record (listed above) and hence how the corresponding section should be
initialized. The forth element is used for either alignment padding or an initial value. A fifth element,
if present, is an array of data bytes.The template is terminated by a null instruction word.
/* For format values of 0 */
struct data_record_bss {
uint32_t *dst;
/* destination address */
uint32_t len;
/* length in bytes */
uint16_t format;
/* format code */
uint16_t padding; /* padding for alignment */
};
/* For format values of 1 and 3 (also identical to format value 4) */
struct data_record_standard {
uint32_t *dst;
/* destination address */
uint32_t len;
/* length in bytes */
uint16_t format;
/* format code */

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 187

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

};

uint16_t padding;
uint32_t dat[0];

/* padding for alignment or a 16-bit initialization value */
/* object-length data - holding initialization data */

/* For format values of 2 - objects are initialised with the same 16-bit value */
struct data_record_short_standard {
uint32_t *dst;
/* destination address */
uint32_t count;
/* count in bytes */
uint16_t format;
/* format code */
uint16_t dat
/* 16-bit repeated value data */
};
/* For format values of 4 - A simplified PackBits data compression is applied, where
each run of zeros is replaced by two 8-bit characters in the compressed array:
zero followed by the number of zeros in the original run. */
struct data_record_compressed {
uint32_t *dst;
/* destination address */
uint32_t count;
/* count in bytes */
uint16_t format;
/* format code */
uint16_t padding;
/* 16-bit repeated value data */
uint32_t compressed_data[0]; /* compressed intialized data */
};

18.2.10 Initialize Bus Matrix Registers
On some of the PIC32 MCUs, the bus matrix registers (BMXDKPBA, BMXDUDBA, BMXDUPBA) must be
initialized by the start-up code if any RAM functions exist. The startup code leaves these registers
in their state when RAM functions do not exist in the projects. The linker collects all RAM functions
and allocates them to a section of data memory that is aligned on a 2K-alignment boundary. To
determine whether any RAM functions exist in the application, the linker provides a variable that
contains the beginning address of this section. This variable is named _ramfunc_begin.
In addition, the linker provides a 2K-aligned variable required for the boundary register
(BMXDKPBA). The variable is named _bmxdkpba_address. The linker also provides two
variables that contains the addresses for the bus matrix register. These variables are named
_bmxdkpba_address, _bmxdudba_address, and _bmxdupba_address.
The linker ensures that RAM functions are aligned to a 2K-alignment boundary as is required by the
BMXDKPBA register.
On other PIC32 devices, no special bus initialization is required to execute RAM functions.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 188

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

Figure 18-3. Bus Matrix Initialization

Initialize CP0 Registers
The CP0 registers are initialized in the following order:
1. Count register
2. Compare register
3. EBase register
4. IntCtl register
5. Cause register
6. Status register
Hardware Enable Register (HWREna – CP0 Register 7, Select 0)
This register contains a bit mask that determines which hardware registers are accessible via
the RDHWR instruction. Privileged software may determine which of the hardware registers are
accessible by the RDHWR instruction. In doing so, a register may be virtualized at the cost of handling
a Reserved Instruction Exception, interpreting the instruction, and returning the virtualized value.
For example, if it is not desirable to provide direct access to the Count register, access to the
register may be individually dis-abled, and the return value can be virtualized by the operating
system.
No initialization is performed on this register in the PIC32 start-up code.
Bad Virtual Address Register (BadVAddr – CP0 Register 8, Select 0)
This register is a read-only register that captures the most recent virtual address that caused an
Address Error exception (AdEL or AdES).No initialization is performed on this register in the PIC32
start-up code.
Count Register (Count – CP0 Register 9, Select 0)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 189

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

This register acts as a timer, incrementing at a constant rate, whether or not an instruction is
executed, retired, or any forward progress is made through the pipeline. The counter increments
every other clock if the DC bit in the Cause register is '0'. The Count register can be written for
functional or diagnostic purposes, including at Reset or to synchronize processors. By writing the
CountDM bit in the Debug register, it is possible to control whether the Count register continues
incrementing while the processor is in Debug mode. This register is cleared in the default PIC32
start-up code.
Status Register (Status – CP0 Register 12, Select 0)
This register is a read/write register that contains the operating mode, Interrupt Enabling, and the
diagnostic states of the processor. Fields of this register combine to create operating modes for the
processor.
The following settings are initialized by the default PIC32 start-up code (0b000000000x0xx0?
00000000000000000):
•

Access to Coprocessor 0 not allowed in User mode (CU0 = 0)

•

User mode uses configured endianess (RE = 0)

•

No change to exception vectors location (BEV = no change)

•

No change to flag bits that indicate reason for entry to the Reset exception vector (SR, NMI =
no change)

•

Interrupt masks are cleared to disable any pending interrupt requests (IM7..IM2 = 0,
IM1..IM0 = 0)

•

Interrupt priority level is 0 (IPL = 0)

•

Base mode is Kernel mode (UM = 0)

•

Error level is normal (ERL = 0)

•

Exception level is normal (EXL = 0)

•

Interrupts are disabled (IE = 0)

The DSPr2 engine is enabled on target devices featuring the DSPr2 engine (MX = 1).
The IEEE 754 compliant Floating-Point Unit is enabled for target devices that support the FPU. The
FPU is configured in the FR64 mode, which defines 32 64-bit float-ing-point general registers (FPRs)
with all formats supported in each register (CU1=1) and (FR=1).
Interrupt Control Register (IntCtl – CP0 Register 12, Select 1)
This register controls the expanded interrupt capability added in Release 2 of the Architecture,
including vectored interrupts and support for an external interrupt controller.
This register contains the vector spacing for interrupt handling. The vector spacing portion of this
register (bits 9..5) is initialized with the value of the _vector_spacing symbol by the PIC32 start-up
code. All other bits are set to '1'.
Shadow Register Control Register (SRSCtl – CP0 Register 12, Select 2)
This register controls the operation of the GPR shadow sets in the processor. The default startup
code uses the SRSCtl register when it initializes the Global Pointer register in all register sets.
However, it restores the original SRSCtl value after the GP register is initialized.
Shadow Register Map Register (SRSMap – CP0 Register 12, Select 3)
This register contains eight 4-bit fields that provide the mapping from a vector number to the
shadow set number to use when servicing such an interrupt. The values from this register are not
used for a non-interrupt exception, or a non-vectored interrupt (CauseIV = 0 or IntCtlVS = 0).
In such cases, the shadow set number comes from SRSCtlESS. If SRSCtlHSS is zero, the results

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 190

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

of a software read or write of this register are UNPREDICTABLE. The operation of the processor
is UNDEFINED if a value is written to any field in this register that is greater than the value of
SRSCtlHSS. The SRSMap register contains the shadow register set numbers for vector numbers
7..0. The same shadow set number can be established for multiple interrupt vectors, creating a
many-to-one mapping from a vector to a single shadow register set number.
No initialization is performed on this register in the PIC32 start-up code.
Cause Register (Cause – CP0 Register 13, Select 0)
This register primarily describes the cause of the most recent exception. In addition, fields also
control software interrupt requests and the vector through which interrupts are dispatched. With
the exception of the DC, IV, and IP1..IP0 fields, all fields in the Cause register are read-only.
Release 2 of the Architecture added optional support for an External Interrupt Controller (EIC)
interrupt mode, in which IP7..IP2 are interpreted as the Requested Interrupt Priority Level (RIPL).
The following settings are initialized by the PIC32 start-up code:
•

Enable counting of Count register (DC = no change)

•

Use the special exception vector (16#200) (IV = 1)

•

Disable software interrupt requests (IP1..IP0 = 0)

Exception Program Counter (EPC – CP0 Register 14, Select 0)
This register is a read/write register that contains the address at which processing resumes after an
exception has been serviced. All bits of the EPC register are significant and must be writable. For
synchronous (precise) exceptions, the EPC contains one of the following:
•

The virtual address of the instruction that was the direct cause of the exception

•

The virtual address of the immediately preceding branch or jump instruction, when the exception
causing instruction is a branch delay slot and the Branch Delay bit in the Cause register is set.

On new exceptions, the processor does not write to the EPC register when the EXL bit in the Status
register is set; however, the register can still be written via the MTC0 instruction.
No initialization is performed on this register in the PIC32 start-up code.
Processor Identification Register (PRId – CP0 Register 15, Select 0)
This register is a 32-bit read-only register that contains information identifying the manufacturer,
manufacturer options, processor identification, and revision level of the processor.
No initialization is performed on this register in the PIC32 start-up code.
Exception Base Register (EBase – CP0 Register 15, Select 1)
This register is a read/write register containing the base address of the exception vectors used
when StatusBEV equals 0, and a read-only CPU number value that may be used by software
to distinguish different processors in a multi-processor system. The EBase register provides the
ability for software to identify the specific processor within a multi-processor system, and allows
the exception vectors for each processor to be different, especially in systems composed of
heterogeneous processors. Bits 31..12 of the EBase register are concatenated with zeros to form
the base of the exception vectors when StatusBEV is 0. The exception vector base address comes
from fixed defaults when StatusBEV is 1, or for any EJTAG Debug exception. The Reset state of
bits 31..12 of the EBase register initialize the exception base register to 16#8000-0000, providing
backward compatibility with Release 1 implementations. Bits 31..30 of the EBase register are fixed
with the value 2#10 to force the exception base address to be in KSEG0 or KSEG1 unmapped virtual
address segments.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 191

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

If the value of the exception base register is to be changed, this must be done with StatusBEV
equal 1. The operation of the processor is UNDEFINED if the Exception Base field is written with a
different value when StatusBEV is 0.
Combining bits 31..30 with the Exception Base field allows the base address of the exception vectors
to be placed at any 4K byte page boundary. If vectored interrupts are used, a vector offset greater
than 4K byte can be generated. In this case, bit 12 of the Exception Base field must be zero. The
operation of the processor is UNDEFINED if software writes bit 12 of the Exception Base field with
a 1 and enables the use of a vectored interrupt whose offset is greater than 4K bytes from the
exception base address.
This register is initialized with the value of the _ebase_address symbol by the PIC32 start-up
code. _ebase_address is provided by the linker script with a default value of the start of KSEG1
program memory. The user can change this value by providing the command line option -–defsym
_ebase_address=A to the linker.

Config Register (Config – CP0 Register 16, Select 0)
This register specifies various configuration and capabilities information. Most of the fields in the
Config register are initialized by hardware during the Reset exception pr-ocess, or are constant.
No initialization is performed on this register in the PIC32 start-up code.

Config1 Register (Config1 – CP0 Register 16, Select 1)
This register is an adjunct to the Config register and encodes additional information about the
capabilities present on the core. All fields in the Config1 register are read-only.
No initialization is performed on this register in the PIC32 start-up code.

Config2 Register (Config2 – CP0 Register 16, Select 2)
This register is an adjunct to the Config register and is reserved to encode additional capabilities
information. Config2 is allocated for showing the configuration of level 2/3 caches. These fields are
reset to 0 because L2/L3 caches are not supported on the core. All fields in the Config2 register are
read-only.
No initialization is performed on this register in the PIC32 start-up code.

Config3 Register (Config3 – CP0 Register 16, Select 3)
This register encodes additional capabilities. All fields in the Config3 register are read-only.
No initialization is performed on this register in the PIC32 start-up code.
Debug Register (Debug – CP0 Register 23, Select 0)
This register is used to control the debug exception and provide information about the cause of the
debug exception, and when re-entering at the debug exception vector due to a normal exception
in Debug mode. The read-only information bits are updated every time the debug exception is
taken, or when a normal exception is taken when already in Debug mode. Only the DM bit and the
EJTAGver field are valid when read from non-Debug mode. The values of all other bits and fields
are UNPREDICTABLE. Operation of the processor is UNDEFINED if the Debug register is written from
non-Debug mode.
No initialization is performed on this register in the PIC32 start-up code.
Trace Control Register (TraceControl – CP0 Register 23, Select 1)
This register provides control and status information. The TraceControl register is only
implemented if the EJTAG Trace capability is present.
No initialization is performed on this register in the PIC32 start-up code.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 192

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

Trace Control 2 Register (TraceControl2 – CP0 Register 23, Select 2)
This register provides additional control and status information. The TraceControl2 register is
only implemented if the EJTAG Trace capability is present.
No initialization is performed on this register in the PIC32 start-up code.
User Trace Data Register (UserTraceData – CP0 Register 23, Select 3)
When this register is written to, a trace record is written indicating a type 1 or type 2 user format.
This type is based on the UT bit in the TraceControl register. This register cannot be written in
consecutive cycles. The trace output data is UNPREDICTABLE if this register is written in consecutive
cycles. The UserTraceData register is only implemented if the EJTAG Trace capability is present.
No initialization is performed on this register in the PIC32 start-up code.
TraceBPC Register (TraceBPC – CP0 Register 23, Select 4)
This register is used to control start and stop of tracing using an EJTAG hardware breakpoint.
The hardware breakpoint would then be set as a triggered source and optionally also as a
Debug exception breakpoint. The TraceBPC register is only impl-emented if both the hardware
breakpoints and the EJTAG Trace cap are present.
No initialization is performed on this register in the PIC32 start-up code.
Debug2 Register (Debug2 – CP0 Register 23, Select 5)
This register holds additional information about complex breakpoint exceptions. The Debug2
register is only implemented if complex hardware breakpoints are present.
No initialization is performed on this register in the PIC32 start-up code.
Debug Exception Program Counter (DEPC – CP0 Register 24, Select 0)
This register is a read/write register that contains the address at which processing resumes after a
debug exception or Debug mode exception has been serviced. For synchronous (precise) debug and
Debug mode exceptions, the DEPC contains either:
•

The virtual address of the instruction that was the direct cause of the debug exception, or

•

The virtual address of the immediately preceding branch or jump instruction, when the debug
exception causing instruction is in a branch delay slot, and the Debug Branch Delay (DBD) bit in
the Debug register is set.

For asynchronous debug exceptions (debug interrupt, complex break), the DEPC contains the
virtual address of the instruction where execution should resume after the debug handler code
is executed.
No initialization is performed on this register in the PIC32 start-up code.
Error Exception Program Counter (ErrorEPC – CP0 Register 30, Select 0)
This register is a read/write register, similar to the EPC register, except that it is used on error
exceptions. All bits of the ErrorEPC are significant and must be writable. It is also used to store the
program counter on Reset, Soft Reset, and Non-Maskable Interrupt (NMI) exceptions. The ErrorEPC
register contains the virtual address at which instr-uction processing can resume after servicing an
error. This address can be:
•

The virtual address of the instruction that caused the exception, or

•

The virtual address of the immediately preceding branch or jump instruction when the error
causing instruction is a branch delay slot.

Unlike the EPC register, there is no corresponding branch delay slot indication for the ErrorEPC
register.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 193

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

No initialization is performed on this register in the PIC32 start-up code.
Debug Exception Save Register (DeSave – CP0 Register 31, Select 0)
This register is a read/write register that functions as a simple memory location. This register is used
by the debug exception handler to save one of the GPRs that is then used to save the rest of the
context to a pre-determined memory area (such as in the EJTAG Probe). This register allows the safe
debugging of exception handlers and other types of code where the existence of a valid stack for
context saving cannot be assumed.
No initialization is performed on this register in the PIC32 start-up code.

18.2.11 Initialize CP0 Registers
The MIPS System Control Coprocessor 0 (CP0) controls interrupts and exceptions. This coprocessor
implements many registers, which are initialized by the runtime startup code to reasonable values.
Some registers (for example the PRISS register) should be explicitly reassigned by user code to
ensure that they are correct for the application.
The registers in the coprocessor control the DSPr2 engine and Floating-Point Unit (FPU) where these
are implemented on the device. These are both enabled as part of the coprocessor initialization.

18.2.12 The “On Bootstrap” Routine
Some hardware configurations require special initialization once most of the C/C++ runtime
environment has been initialized, while StatusBEV is still set and before the main() function has
been called. For instance, special hardware initialization and/or initialization of the environment
might be required by an RTOS. To achieve this, there is an On Bootstrap hook provided, so that you
do not need to customize the entire startup code sequence.
An empty weak implementation of the On Bootstrap routine (_on_bootstrap) is provided with the
start-up code. It is called by the runtime startup code after most of the C/C++ language context
initialization has been performed.
If you do need to implement your own version of this routine, you can modify the following stub
(note the leading underscore character in the function’s name).
void _on_bootstrap(void)
{
// Add code to be executed just before main() here
}

This routine can be placed into any source file in your project and you do not need to adjust any
compiler options to have it executed.
This routine can be written assuming that the runtime environment has been mostly established.
The StatusBEV is cleared immediately after this routine returns. See 18.2. Runtime Start-Up Code
for the order in which the environment is set up.

18.2.13 Change Location of Exception Vectors
Immediately before executing any application code, the StatusBEV is cleared to change the location
of the exception vectors from the bootstrap location to the normal location.

18.2.14 Call the C++ Initialization Code
Invoke all constructors for C++ file-scope static-storage objects. The startup code must call the
constructors last because the low-level initialization must be done before executing application
code.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 194

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

18.2.15 Call Main
The last thing that the start-up code performs is a call to the main routine. If the user returns from
main, the start-up code goes into an infinite loop. When you are compiling for use with a debugger
in MPLAB X IDE with the -mdebugger option, this loop contains a software breakpoint.

18.2.16 Symbols Required by Start-Up Code and C/C++ Library
This section details the symbols that are required by the start-up code and C/C++ library. Currently
the default device-specific linker script defines these symbols. If an application provides a custom
linker script, the user must ensure that all of the following symbols are provided in order for the
start-up code and C library to function:
Symbol Name

Description

_bmxdkpba_address

The address to place into the BMXDKPBA register if _ramfunc_length is
greater than 0.

_bmxdudba_address

The address to place into the BMXDUDBA register if _ramfunc_length is
greater than 0.

_bmxdupba_address

The address to place into the BMXDUPBA register if _ramfunc_length is
greater than 0.

_ebase_address

The initialization value for the ExceptionBase field of the EBASE register. The
ExceptionBase is the base address for the exception vectors, adjustable to a
resolution of 4 Kbytes. The default device-specific linker scripts provided with
the XC32 toolchain provide a default location for the ExceptionBase.

_end

The end of data allocation.

_gp

Points to the “middle” of the small variables region. By convention this is
0x8000 bytes from the first location used for small variables.

_heap

The starting location of the heap in DRM.

_ramfunc_begin

The starting location of the RAM functions. This should be located at a 2K
boundary as it is used to initialize the BMXDKPBA register.

_ramfunc_length

The length of the .ramfunc section.

_stack

The starting location of the stack in DRM. Remember that the stack grows from
the bottom of data memory so this symbol should point to the bottom of the
section allocated for the stack.

_vector_spacing

The initialization value for the vector spacing field in the IntCtl register.

18.2.17 Exceptions
In addition, two weak general exception handlers are provided that can be overridden by the
application — one to handle exceptions when StatusBEV is 1 (_bootstrap_exception_handler),
and one to handle exceptions when StatusBEV is 0 (_general_exception_handler). Both the
weak Reset exception handler and the weak general exception handler provided with the start-up
code causes a software Reset. The start-up code arranges for a jump to the bootstrap exception
handler to be located at 0xBFC00380, and a jump to the general exception handler to be located at
EBASE + 0x180.
Both handlers must be attributed with the nomips16 [for example, __attribute__
((nomips16))], since the start-up code jumps to these functions.
When the BOOTISA configuration bit is set for exceptions to be in the microMIPS
mode, both handlers must be attributed with the micromips attribute [for example,
__attribute__((micromips))].

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 195

XC32 Compiler for PIC32M
Main, Runtime Start-up and Reset

Figure 18-4. Exceptions

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 196

XC32 Compiler for PIC32M
Library Routines

19.

Library Routines

19.1

Smart IO Routines
The library code associated with the print and scan families of IO functions can be customized by
the compiler with each compilation, based on compiler options and how you use these functions in
your project. This can reduce the amount of redundant library code being linked into the program
image, hence can reduce the program memory and data memory used by a program.
The smart output (print family) functions are:
printf

fprintf

snprintf

sprintf

vfprintf

vprintf

vsnprintf

vsprintf

The smart input (scan family) functions are:
scanf

fscanf

sscanf

vfscanf

vscanf

vsscanf

When this feature is enabled, the compiler analyzes your project's C source code every time you
build, searching for calls to any of the smart IO functions. The conversion specifications present
in the format strings are collated across all calls, and their presence triggers inclusion of library
routines with the associated functionality in the program image output.
For example, if a program contained only the following call:
printf("input is: %d\n", input);

when smart IO is enabled, the compiler will note that only the %d placeholder has been used by the
printf function in the program, and the linked library routine defining printf will thus contain a
basic functionality that can at least handle the printing of decimal integers. If the following call was
added to the program:
printf("input is: %f\n", ratio);

the compiler will then see that both the %d and %f placeholders were used by printf. The linked
library routine would then have additional functionality to ensure that all the requirements of the
program can be met.
Specific details of how the smart IO feature operates for this compiler are detailed in the following
section. The syntax and usage of all IO functions, which are part of the <stdio.h> header, are
described in the Microchip Unified Standard Library Reference Guide.

19.1.1 Smart IO For PIC32M Devices
When using MPLAB XC32 C Compiler, multiple IO library variants, representing increasingly complex
subsets of IO functionality, are available and are linked into your program based on the -msmartio option and how you use the smart IO functions in your project's source code.
When the smart IO feature is disabled (-msmart-io=0), a full implementation of the IO functions
will be linked into your program. All features of the IO library functions will be available, and these
may consume a significant amount of the available program and data memory on the target device.
When the smart IO feature is enabled (-msmart-io=1 or -msmart-io), the compiler will link in
the least complex variant of the IO library that implements all of the IO functionality required by
the program, based on the conversion specifications detected in the program's IO function format
strings. This can substantially reduce the memory requirements of your program, especially if you
can eliminate in your program the use of floating-point features in calls to smart IO functions. This is
the default setting.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 197

XC32 Compiler for PIC32M
Library Routines

The compiler analyzes the usage of each IO function independently, so while the code for
a particular program might require that the printf function be full featured, only a basic
implementation of the snprintf function might be required, for example.
If the format string in a call to an IO function is not a string literal, the compiler will not be able to
detect the exact usage of the IO function, and a full-featured variant of the IO library will be linked
into the program image, even with smart IO enabled. In this instance, the -msmart-io=2 form of
the option can be used. This has the compiler assume that no floating-point has been used by
formatted IO functions and that it is safe to link in integer-only format IO libraries. You must ensure
that your program only uses the indicated conversion specifications; otherwise, IO functions may
not work as expected.
For example, consider the following four calls to smart IO functions.
vscanf("%d:%li", va_list1);
vprintf("%-s%d", va_list2);
vprintf(fmt1, va_list3); // ambiguous usage
vscanf(fmt2, va_list4); // ambiguous usage

When processing the last two calls, the compiler cannot deduce any usage information from either
of the format strings. If it is known that the format strings pointed to by fmt1 and fmt2 collectively
use only the %d, %i and %s conversion specifiers, the -msmart-io=2 form of the option can be
used.
These options should be used consistently across all program modules to ensure an optimal
selection of the library routines included in the program image.

19.2

Using Library Routines
Library functions or routines (and any associated variables) will be automatically linked into a
program once they have been referenced in your source code. The use of a function from one
library file will not include any other functions from that library. Only used library functions will be
linked into the program output and consume memory.
Note: Do not specify an MPLAB XC32 system include directory (e.g., /pic32mx/include/) in
your project properties. The xc32-gcc compilation drivers automatically select the XC libc and their
respective include-file directory for you. The xc32-g++ compilation drivers automatically select the
C++ library and their respective include-file directory for you. Manually adding a system include
file path may disrupt this mechanism and cause the incorrect libc include files to be compiled into
your project, causing a conflict between the include files and the library. Note that adding a system
include path to your project properties has never been a recommended practice.
Your program will require declarations for any functions or symbols used from libraries. These are
contained in the standard C header (.h) files. Header files are not library files and the two files types
should not be confused. Library files contain precompiled code, typically functions and variable
definitions; the header files provide declarations (as opposed to definitions) for functions, variables
and types in the library files, as well as other preprocessor macros.
#include <math.h> // declare function prototype for sqrt
int main(void)
{
double i;

}

// sqrt referenced; sqrt will be linked in from library file
i = sqrt(23.5);

MPLAB® Harmony includes a set of peripheral libraries, drivers, and system services that are readily
accessible for application development. For access to the plib.h (peripheral header files), go to the
Harmony web site (www.microchip.com/mplab/mplab-harmony) to download MPLAB Harmony.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 198

XC32 Compiler for PIC32M
Mixing C/C++ and Assembly Language

20.

Mixing C/C++ and Assembly Language
Assembly language code can be mixed with C/C++ code using two different techniques: writing
assembly code and placing it into a separate assembler module, or including it as in-line assembly in
a C/C++ module. This section describes how to use assembly language and C/C++ modules together.
It gives examples of using C/C++ variables and functions in assembly code, and examples of using
assembly language variables and functions in C/C++.
The more assembly code a project contains, the more difficult and time consuming its maintenance
will be. As the project is developed, the compiler may work in different ways as some optimizations
look at the entire program. The assembly code is more likely to fail if the compiler is updated due to
differences in the way the updated compiler may work. These factors do not affect code written in
C/C++.
Note: If assembly must be added, it is preferable to write this as self-contained routine in a
separate assembly module rather than in-lining it in C code.

20.1

Mixing Assembly Language and C Variables and Functions
The following guidelines indicate how to interface separate assembly language modules with C
modules.
•

Follow the register conventions described in 14.2. Register Conventions. In particular, registers
$4-$7 are used for parameter passing. An assembly -language function will receive parameters,
and should pass arguments to called functions, in these registers.

•

Table 14-1 describes which registers must be saved across non-interrupt function calls.

•

Interrupt functions must preserve all registers. Unlike a normal function call, an interrupt may
occur at any point during the execution of a program. When returning to the normal program, all
registers must be as they were before the interrupt occurred.

•

Variables or functions declared within a separate assembly file that will be referenced by any
C source file should be declared as global using the assembler directive .global. Undeclared
symbols used in assembly files will be treated as externally defined.

The following example shows how to use variables and functions in both assembly language and C
regardless of where they were originally defined.
The file ex1.c defines foo and cVariable to be used in the assembly language file. The C file also
shows how to call an assembly function, asmFunction, and how to access the assembly defined
variable, asmVariable.
Example 20-1. Mixing C and Assembly
/*
** file: ex1.S
*/
#include <xc.h>
/* define which section (for example "text")
* does this portion of code resides in. Typically,
* all your code will reside in .text section as
* shown below.
*/
.text
/* This is important for an assembly programmer. This
* directive tells the assembler that don't optimize
* the order of the instructions as well as don't insert
* 'nop' instructions after jumps and branches.
*/
.set noreorder
/*********************************************************************
* asmFunction(int bits)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 199

XC32 Compiler for PIC32M
Mixing C/C++ and Assembly Language
* This function clears the specified bites in IOPORT A.
********************************************************************/
.global asmFunction
.ent asmFunction
asmFunction:
/* function prologue - save registers used in this function
* on stack and adjust stack-pointer
*/
addiu
sp, sp, -4
sw
s0, 0(sp)
la
sw

s0, LATACLR
a0, 0(s0)

/* clear specified bits */

la
lw
la
sw

s0, PORTA
s1, 0(s0)
s0, cVariable
s1, 0(s0)

/* keep a copy */

/* function epilogue - restore registers used in this function
* from stack and adjust stack-pointer
*/
lw
s0, 0(sp)
addiu
sp, sp,
addu
s1, ra, zero
jal
foo
nop
addu
ra, s1, zero
nop
/* return to caller */
jr
ra
nop
.end asmFunction
.bss
.global asmVariable
.align 2
asmVariable: .space 4

The file ex1.S defines asmFunction and asmVariable as required for use in a
linked application. The assembly file also shows how to call a C function, foo, and
how to access a C defined variable, cVariable.
/*
* file: ex2.c
*/
#include <xc.h>
extern void asmFunction(int bits);
extern unsigned int asmVariable;
volatile unsigned int cVariable = 0;
volatile unsigned int jak = 0;
int
main(void) {
TRISA = 0;
LATA = 0xC6FFul;
asmFunction(0xA55Au);
while (1) {
asmVariable++;
}
}
void
foo(void) {
jak++;
}

In the C file, ex2.c, external references to symbols declared in an assembly file are
declared using the standard extern keyword; note that asmFunction is a void
function and is declared accordingly.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 200

XC32 Compiler for PIC32M
Mixing C/C++ and Assembly Language

In the assembly file, ex1.S, the symbols asmFunction and asmVariable are made
globally visible through the use of the .global assembler directive and can be
accessed by any other source file.

20.2

Using Inline Assembly Language
Within a C/C++ function, the asm statement may be used to insert a line of assembly-language code
into the assembly language that the compiler generates. Inline -assembly has two forms: simple and
extended.
In the simple form, the assembler instruction is written using the syntax:
asm ("instruction");
where instruction is a valid assembly-language construct. If you are writing inline assembly in
ANSI C programs, write _ _asm_ _ instead of asm.
Note: Only a single string can be passed to the simple form of inline assembly.
In an extended assembler instruction using asm, the operands of the instruction are specified using
C/C++ expressions. The extended syntax is:
asm("template" [ : [ "constraint"(output-operand) [ , ... ] ]
[ : [ "constraint"(input-operand) [ , ... ] ]
[ "clobber" [ , ... ] ]
]
]);

You must specify an assembler instruction template, plus an operand constraint string for each
operand. The template specifies the instruction mnemonic, and optionally placeholders for the
operands. The constraint strings specify operand constraints, for example, that an operand must
be in a register (the usual case), or that an operand must be an immediate value.
Constraint letters and modifiers supported by the compiler are listed in the following tables.
Table 20-1. Register Constraint Letters Supported by the Compiler
Letter

Constraint

c

A register suitable for use in an indirect jump

d

An address register. This is equivalent to @code{r} unless generating MIPS16
code

ka

Registers that can be used as the target of multiply-accumulate instructions

l

The @code{lo} register. Use this register to store values that are no bigger than
a word

x

The concatenated @code{hi} and @code{lo} registers. Use this register to
store double-word values

Table 20-2. Integer Constraint Letters Supported by the Compiler
Letter

Constraint

I

A signed 32-bit constant (for arithmetic instructions)

J

Integer zero

K

An unsigned 32-bit constant (for logic instructions)

L

A signed 32-bit constant in which the lower 32 bits are zero. Such constants
can be loaded using @code{lui}

M

A constant that cannot be loaded using @code{lui}, @code{addiu} or
@code{ori}

N

A constant in the range -65535 to -1 (inclusive)

O

A signed 15-bit constant

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 201

XC32 Compiler for PIC32M
Mixing C/C++ and Assembly Language

...........continued
Letter

Constraint

P

A constant in the range 1 to 65535 (inclusive)

Table 20-3. General Constraint Letters Supported by the Compiler
Letter

Constraint

R

An address that can be used in a non-macro load or store.

Table 20-4. Constraint Modifiers Supported by the Compiler
Letter

Constraint

=

Means that this operand is write-only for this instruction: the previous value
is discarded and replaced by output data

+

Means that this operand is both read and written by the instruction

&

Means that this operand is an earlyclobber operand, which is modified
before the instruction is finished using the input operands. Therefore, this
operand may not lie in a register that is used as an input operand or as part
of any memory address

d

Second register for operand number n, that is, %dn..

q

Fourth register for operand number n, that is, %qn..

t

Third register for operand number n, that is, %tn..

20.2.1 Inline Examples
Insert Bit Field
This example demonstrates how to use the INS instruction to insert a bit field into a 32-bit wide
variable. This function-like macro uses inline assembly to emit the INS instruction, which is not
commonly generated from C/C++ code.
/* MIPS32r2 insert bits */
#define _ins(tgt,val,pos,sz) __extension__({
\
unsigned int __t = (tgt), __v = (val);
\
__asm__ ("ins %0,%z1,%2,%3"
/* template */ \
: "+d" (__t)
/* output
*/ \
: "dJ" (__v), "I" (pos), "I" (sz)); /* input
*/ \
__t;
\
})

Here__v, pos, and sz are input operands. The __v operand is constrained to be of type 'd' (an
address register) or 'J' (integer zero). The pos and sz operands are constrained to be of type 'I' (a
signed 32-bit constant).
The __t output operand is constrained to be of type 'd' (an address register). The '+' modifier means
that this operand is both read and written by the instruction and so the operand is both an input
and an output.
The following example shows this macro in use.
unsigned int result;
void example (void)
{
unsigned int insertval = 0x12;
result = 0xAAAAAAAAu;
result = _ins(result, insertval, 4, 8);
/* result is now 0xAAAAA12A */
}

For this example, the compiler may generate assembly code similar to the following.
li
ori

$2,-1431699456
$2,$2,0xaaaa

# 0xaaaa0000
# 0xaaaa0000 | 0xaaaa

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 202

XC32 Compiler for PIC32M
Mixing C/C++ and Assembly Language
li
ins

$3,18
$2,$3,4,8

# 0x12
# inline assembly

lui
j
sw

$3,%hi(result)
# assign the result back
$31
# return
$2,%lo(result)($3)

Multiple Assembler Instructions
This example demonstrates how to use the WSBH and ROTR instructions together for a byte swap.
The WSBH instruction is a 32-bit byte swap within each of the two halfwords. The ROTR instruction
is a rotate right by immediate. This function-like macro uses inline assembly to create a “byte-swap
word” using instructions that are not commonly generated from C/C++ code.
The following shows the definition of the function-like macro, _bswapw.
/* MIPS32r2 byte-swap word */
#define _bswapw(x) __extension__({
\
unsigned int __x = (x), __v;
\
__asm__ ("wsbh %0,%1;\n\t"
\
"rotr %0,16" /* template */ \
: "=d" (__v) /* output */
\
: "d" (__x)) /* input*/ ;
\
__v;
\
})

Here __x is the C expression for the input operand. The operand is constrained to be of type 'd',
which denotes an address register.
The C expression __v is the output operand. This operand is also constrained to be of type 'd'. The
'=' means that this operand is write-only for this instruction: the previous value is discarded and
replaced by output data.
The function-like macro is shown in the following example assigning to result the content of
value, swapped.
unsigned int result;
int example (void)
{
unsigned int value = 0x12345678u;
result = _bswapw(value);
/* result == 0x78563412 */
}

The compiler may generate assembly code similar to the following for this example:
li
addiu
wsbh
rotr
lui
j
sw

$2,305397760
$2,$2,22136
$2,$2
$2,16
$2,%hi(result)
$31
$3,%lo(result)($2)

# 0x12340000
# 0x12340000 + 0x5678
# From inline asm
# From inline asm
# assign back to result
# return

20.2.2 Equivalent Assembly Symbols
C/C++ symbols can be accessed directly with no modification in extended assembly code.

20.3

Predefined Macros
Several predefined macros are available once you include <xc.h>. The exact operation of these
macros is dependent on the instruction set employed. The following table shows general purpose
predefined macros and their operation.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 203

XC32 Compiler for PIC32M
Mixing C/C++ and Assembly Language

Table 20-5. Predefined Macros in XC.H
Macro

Description

_bcc0(rn, sel, clr)

For the CP0 register specified by rn and sel, clear bits corresponding to
those bits in clr which are non-zero.

_bcsc0(rn, sel, clr, set)

For the CP0 register specified by rn and sel, clear bits corresponding to
those bits in clr which are non-zero, and set bits corresponding to those
bits in set which are non-zero.

_bsc0(rn, sel, set)

For the CP0 register specified by rn and sel, clear bits corresponding to
those bits in clr which are non-zero.

_bswapw(x)

See <xc.h> file. Byte-swap word.

_cache(op,addr)

Do an operation to a cache line. See the device documentation for details
on the available operations.

_clo(x)

Count leading ones in x.

_clz(x)

Count leading zeros in x.

_ctz(x)

Count trailing zeros in x.

_dclo(x)

Simulate 64-bit count leading ones in x.

_dclz(x)

Simulate 64-bit count leading zeros in x.

_dctz(x

Simulate 64-bit count trailing zeros in x.

_ehb()

Insert Execution Hazard Barrier instruction.

_ext(x,pos,sz)

See <xc.h> file. Extract bitfield from a 32-bit variable.

_get_byte(addr, errp)

Return the least significant byte of addr.

_get_dword(addr, errp)

Return the least significant 64-bit word of addr.

_get_half(addr, errp)

Return the least significant 16-bit word of addr.

_get_word(addr, errp)

Return the least significant 32-bit word of addr.

_ins(tgt,val,pos,sz)

See <xc.h> file. Insert bits.

_jr_hb()

See <xc.h> file. Jump register with hazard barrier.

_mfc0(rn, sel)

See <xc.h> file. Move a value from a coprocessor 0 register.

_mtc0(rn, sel, v)

See <xc.h> file. Move a value to a coprocessor 0 register.

_mxc0(rn, sel, v)

See <xc.h> file. Exchange a value with a value in a coprocessor 0 register.

_nop()

Insert a No Operation instruction.

_prefetch(hint,x)

Prefetch instruction for memory reference optimization. An application
that knows in advance it may need data can arrange for it to be brought
into cache. 'hint' defines which sort of prefetch this is.

_put_byte(addr, v)

Write the least significant byte of addr with v.

_put_dword(addr, v)

Write the least significant 64-bit word of addr with v.

_put_half(addr, v)

Write the least significant 16-bit word of addr with v.

_put_word(addr, v)

Write the least significant 32-bit word of addr with v.

_rdpgpr(regno)

See <xc.h> file. Read register from previous register set.

_sync()

Insert Synchronize Shared Memory instruction.

_synci(addr)

Synchronize the I-cache with the D-cache; Run instruction for each cacheline-sized block after writing instructions but before executing them.

_wait()

Insert instruction to enter Standby mode.

_wrpgpr(regno, val)

See <xc.h> file. Write to a register in the previous register set.

_wsbh(x)

See <xc.h> file. 32-bit byte-swap within each of the two halfword.

__XC32_PART_SUPPORT_UPDATE

This macro expands to the letter corresponding to the partsupport update version being used. The value is based upon the
major and minor version numbers of the current release. For
example, part-support update version v1.42(B) will have #define
__XC32_PART_SUPPORT_UPDATE B

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 204

XC32 Compiler for PIC32M
Mixing C/C++ and Assembly Language

...........continued
Macro

Description

__XC32_PART_SUPPORT_VERSION

This macro expands to a numeric value corresponding to the partsupport update version being used. The value is based upon the
major and minor version numbers of the current release. For
example, part-support update version v1.42(B) will have #define
__XC32_PART_SUPPORT_UPDATE 1420.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 205

XC32 Compiler for PIC32M
Optimizations

21.

Optimizations
Activation of a compiler license controls which code optimizations are available.
An unlicensed compiler operating in Free mode allows access to only basic optimizations. You can
purchase a PRO compiler license at any time. Activating the compiler with a PRO license unlocks all
available speed- and space-orientated optimizations. Prior to purchase, you can, if desired, obtain
and activate a free 60-day PRO license evaluation, which also permits full optimization of source
code and shows the benefits that a PRO license would deliver.
Visit www.microchip.com/mplab/compilers for more information on C and C++ licenses.
MPLAB XC32 C/C++ Compiler license types are Free, EVAL and PRO. The initial compiler download
begins as an Evaluation (EVAL) license allows 60 days to evaluate the compiler as a Professional
(PRO) license with the most optimizations. The Free license has minimal optimizations.
Different MPLAB XC32 C/C++ Compiler editions support different levels of optimization. Some
editions are free to download and others must be purchased. Visit www.microchip.com/mplab/
compilers for more information on C and C++ licenses.
The compiler editions are:

21.1

Edition

Cost

Description

Professional (PRO)

Yes

Implemented with the highest optimizations and
performance levels.

Free

No

Implemented with the most code optimizations restrictions.

Evaluation (EVAL)

No

PRO edition enabled for 60 days and then reverts to Free
edition.

Optimization Feature Summary
Licensing your compiler entitles you to optimizations that are not available with the Free product.
Those optimizations available with the Free and Licensed XC32 compiler are tabulated below. The
optimization names are derived from the option that can typically be used to enable or disable
them, for example the "Defer pop" optimization can be manually enabled using the -fdefer-pop
option if it is not already enabled at the selected optimization level, or disabled using -fno-deferpop. For details on compiler options used to set optimizations, see 5.7.7. Options for Controlling
Optimization.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 206

XC32 Compiler for PIC32M
Optimizations

Table 21-1. License Optimization Features
Free

PRO License

•

Align functions

All Free optimizations, plus:

•

Align labels

•

Align loops

•

Caller saves

•

Cse follow jumps

•

Cse skip blocks

•

Data sections

•

Defer pop

•

Expensive optimizations

•

Function cse

•

Function sections

•

Gcse

•

Gsce lm

•

Gsce sm

•

Inline functions

•

Inline limit

•

Keep inline functions

•

Keep static consts

•

Omit frame pointer

•

Optimize register move

•

Optimize sibling calls

•

Peephole/2

•

Rename registers

•

Rerun cse after loop

•

Rerun loop opt

•

Schedule insns/2

•

Strength reduce

•

Strict aliasing

•

Thread jumps

•

Toplevel reorder

•

Unroll/all loops

•

Lto

•

Whole program

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 207

XC32 Compiler for PIC32M
Preprocessing

22.

Preprocessing
All C/C++ source files are preprocessed before compilation. Assembly source files that use the .S
extension (upper case) are also preprocessed. A large number of options control the operation of
the preprocessor and preprocessed code, see 5.7.8. Options for Controlling the Preprocessor.

22.1

C/C++ Language Comments
A C/C++ comment is ignored by the compiler and can be used to provide information to someone
reading the source code. They should be used freely.
Comments may be added by enclosing the desired characters within /* and */. The comment can
run over multiple lines, but comments cannot be nested. Comments can be placed anywhere in
C/C++ code, even in the middle of expressions, but cannot be placed in character constants or string
literals.
Since comments cannot be nested, it may be desirable to use the #if preprocessor directive to
comment out code that already contains comments, for example:
#if 0
result = read();
#endif

/* TODO: Jim, check this function is right */

Single-line, C++ style comments may also be specified. Any characters following // to the end of the
line are taken to be a comment and will be ignored by the compiler, as shown below:
result = read(); // TODO: Jim, check this function is right

22.2

Preprocessor Directives
The XC32 accepts several specialized preprocessor directives, in addition to the standard directives.
All of these are tabulated below.
Table 22-1. Preprocessor Directives
Directive

Meaning

Example

#

Preprocessor null directive, do nothing.

#

#assert

Generate error if condition false.

#assert SIZE > 10

#define

Define preprocessor macro.

#elif

Short for #else #if.

see #ifdef

#else

Conditionally include source lines.

see #if

#endif

Terminate conditional source inclusion.

see #if

#error

Generate an error message.

#error Size too big

#if

Include source lines if constant expression true.

#ifdef

Include source lines if preprocessor symbol defined.

#define SIZE (5)
#define FLAG
#define add(a,b) ((a)+(b))

#if SIZE < 10
c = process(10)
#else
skip();
#endif
#ifdef FLAG
do_loop();
#elif SIZE == 5
skip_loop();
#endif

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 208

XC32 Compiler for PIC32M
Preprocessing

...........continued
Directive

Meaning

Example

#ifndef

Include source lines if preprocessor symbol not defined.

#include

Include text file into source.

#line

Specify line number and filename for listing

#ifndef FLAG
jump();
#endif
#include <stdio.h>
#include “project.h”

#nn filename (where nn is a number, and filename is the name of
the source file) the following content originated from the
specified file and line number.

#line 3 final
#20 init.c

#pragma

Compiler specific options.

See the Pragma Directives section in this guide.

#undef

Undefines preprocessor symbol.

#undef FLAG

#warning

Generate a warning message.

#warning Length not set

Macro expansion using arguments can use the # character to convert an argument to a string and
the ## sequence to concatenate arguments. If two expressions are being concatenated, consider
using two macros in case either expression requires substitution itself; for example
#define __paste1(a,b)
#define __paste(a,b)

a##b
__paste1(a,b)

lets you use the paste macro to concatenate two expressions that themselves can require further
expansion. Remember, that once a macro identifier has been expanded, it will not be expanded
again if it appears after concatenation.

22.2.1 Preprocessor Arithmetic
Preprocessor macro replacement expressions are textual and do not utilize types. Unless they are
part of the controlling expression to the inclusion directives (discussed below), macros are not
evaluated by the preprocessor. Once macros have been textually expanded and preprocessing is
complete, the expansion forms a C expression which is evaluated by the code generator along with
other C code. Tokens within the expanded C expression inherit a type, with values then subject to
integral promotion and type conversion in the usual way.
If a macro is part of the controlling expression to a conditional inclusion directive (#if or #elif),
the macro must be evaluated by the preprocessor. The result of this evaluation is often different
to the C-domain result for the same sequence. The preprocessor assigns sizes to literal values in
the controlling expression that are equal to the largest integer size accepted by the compiler, as
specified by the size of intmax_t defined in <stdint.h>.
For the MPLAB XC32 C Compiler, this size is 64 bits.

22.3

Pragma Directives
There are certain compile-time directives that can be used to modify the behavior of the compiler.
These are implemented through the use of the ANSI standard #pragma facility. Any pragma which is
not understood by the compiler will be ignored.
The format of a pragma is:
#pragma keyword options

where keyword is one of a set of keywords, some of which are followed by certain options. A
description of the keywords is given below.
#pragma config

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 209

XC32 Compiler for PIC32M
Preprocessing

The #pragma config directive specifies the processor-specific configuration settings (that is,
Configuration bits) to be used by the application. See 7.3. Configuration Bit Access.
default_function_attributes
The default_function_attributes = [@ "section"] pragma sets default section placement
attributes for function declarations and definitions that do not otherwise specify this attribute.
All functions after the pragma will be placed in the section whose name is quoted after the @
token. Using the default_function_attributes = form of this pragma will reset the section
specification, so that subsequent functions are not placed in any special section.
default_variable_attributes
The #pragma default_variable_attributes = [@ "section"] pragma sets default section
placement attributes for variable declarations and definitions that do not otherwise specify this
attribute. All variables after the pragma will be placed in the section whose name is quoted after the
@ token. Using the #pragma default_variable_attributes = form of this pragma will reset the
section specification, so that subsequent variables are not placed in any special section.
#pragma interrupt
Mark a function as an interrupt handler. The prologue and epilogue code for the function will
perform more extensive context preservation. Note that the interrupt attribute (rather than
this pragma) is the recommended mechanism for marking a function as an interrupt handler.
The interrupt pragma is provided for compatibility with other compilers. See 17. Interrupts and
17.4. Exception Handlers.
#pragma message
The message = "text" pragma prints the quoted text at build time, as neither a warning nor
error, but purely as an advisory.
#pragma GCC optimize
The #pragma GCC optimize ("string"...) pragma sets default optimization attributes for
function declarations and definitions that do not otherwise specify these attributes. All functions
after the pragma will be optimized accordingly. The parentheses are optional. The arguments
allowed may be:
• A number n, to be interpreted as an optimization level, i.e., the -On option.
•

A string beginning with O, which is interpreted as an optimization option, i.e., -Ostring.

•

Otherwise, string should be an option that can be used with a -f prefix.

The #pragma GCC reset_options pragma clears the default optimizations, so that the
optimization of subsequent functions is not controlled by optimize pragma.
#pragma pack
The #pragma pack pragma allows the maximum alignment of members of structures (other than
zero-width bit-fields), unions, and classes to be changed. All aggregate objects after the pragma will
be packed accordingly. subsequently defined.
The #pragma pack(n) form of this pragma specifies the new packing alignment. The n value
should be a small power of two and specifies the new packing alignment in bytes.
The #pragma pack() form of this pragma resets the packing alignment to that in effect when
compilation started. This might have been specified with the -fpack-struct option.
The #pragma pack(push[,n]) form of this pragma pushes the current alignment setting on an
internal stack and then optionally sets the new packing alignment to the value n.
The #pragma pack(pop) form of this pragma restores the alignment setting to the one saved at
the top of the internal stack by a previous #pragma pack(push) (and removes that stack entry).

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 210

XC32 Compiler for PIC32M
Preprocessing

#pragma vector
Generate a branch instruction at the indicated exception vector that targets the function. Note that
the vector attribute (rather than this pragma) is the recommended mechanism for generating an
exception/interrupt vector. See 17. Interrupts and 17.4. Exception Handlers.
#pragma weak
The #pragma weak pragma can be used to declare weak symbols and defining weak aliases.
The #pragma weak symbol form of this pragma declares symbol to be weak, as if the declaration
had used the weak attribute. The pragma can appear before or after the declaration of symbol, or
can be used in situations where symbol is never defined.
The #pragma weak symbol1 = symbol2 form of this pragma declares symbol1 to be a weak alias
of symbol2. The symbol2 symbol must be defined in the current translation unit.

22.4

Predefined Macros
These predefined macros are available for use with the compiler.

22.4.1 32-Bit C/C++ Compiler Macros
The compiler defines a number of macros, most with the prefix “_MCHP_”, which characterize the
various target specific options, the target processor and other aspects of the host environment.
_MCHP_SZINT

32 or 64, depending on command line options to set the size of an integer
(-mint32 -mint64).

_MCHP_SZLONG

32 or 64, depending on command line options to set the size of an integer
(-mlong32 -mlong64).

_MCHP_SZPTR

32 always since all pointers are 32 bits.

__mchp_no_float

Defined if -mno-float specified.

__NO_FLOAT

Defined if -mno-float specified.

__SOFT_FLOAT

Defined if -mno-float not specified and the specified device does not feature
a hardware Floating-Point Unit (FPU). Indicates that floating-point operations
are supported via library calls.

__HARD_FLOAT

Defined if -mno-float and -msoft-float are not specified and the specified
device features a hardware Floating-Point Unit (FPU). Indicates that floatingpoint operations utilize the FPU.

__PIC32MX
__PIC32MX__

Defined when a PIC32MX device is specified with the -mprocessor option.

__PIC32MZ

Defined when a PIC32MZ device is specified with the -mprocessor option.

__PIC32_FEATURE_SET__

The compiler predefines a macro based on the features available for the
selected device. These macros are intended to be used when writing code
to take advantage of features available on newer devices while maintaining
compatibility with older devices.
Examples: PIC32MX795F512L would use: __PIC32_FEATURE_SET__ == 795,
and PIC32MX340F128H would use: __PIC32_FEATURE_SET__ == 340.
Examples: PIC32MZ2048ECH100 would use:
__PIC32_FEATURE_SET "EC" /* PIC32MZ2048ECH100 */
__PIC32_FEATURE_SET0 69 /* PIC32MZ2048ECH100 */
__PIC32_FEATURE_SET1 67 /* PIC32MZ2048ECH100 */

PIC32MX

Defined if -ansi is not specified.

__LANGUAGE_ASSEMBLY
__LANGUAGE_ASSEMBLY__

Defined if compiling a pre-processed assembly file (.S files).

_LANGUAGE_ASSEMBLY
LANGUAGE_ASSEMBLY

Defined if compiling a pre-processed assembly file (.S files) and -ansi is not
specified.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 211

XC32 Compiler for PIC32M
Preprocessing
__LANGUAGE_C
__LANGUAGE_C__

Defined if compiling a C file.

_LANGUAGE_C
LANGUAGE_C

Defined if compiling a C file and -ansi is not specified.

__LANGUAGE_C_PLUS_PLUS
__cplusplus

Defined if compiling a C++ file.

_LANGUAGE_C_PLUS_PLUS__
__EXCEPTIONS

Defined if X++ exceptions are enabled.

__GXX_RTTI

Defined if runtime type information is enabled.

__processor__

Where “processor” is the capitalized argument to the -mprocessor option. for
example, -mprocessor=32mx12f3456 will define __32MX12F3456__

__XC

Always defined to indicate that this is a Microchip XC compiler.

__XC32

Always defined to indicate this the XC32 compiler.

__VERSION__

The __VERSION__ macro expands to a string constant describing the compiler
in use. Do not rely on its contents having any particular form, but it should
contain at least the release number. Use the __XC32_VERSION macro for a
numeric version number.

__XC32_VERSION
or __C32_VERSION__

The C compiler defines the constant __XC32_VERSION, giving a numeric value
to the version identifier. This macro can be used to construct applications
that take advantage of new compiler features while still remaining backward
compatible with older versions. The value is based upon the major and
minor version numbers of the current release. For example, release version
1.03 will have a __XC32_VERSION definition of 1030. This macro can be
used, in conjunction with standard preprocessor comparison statements, to
conditionally include/exclude various code constructs.

__mips_dsp 1
__mips_dspr2 1

The C compiler defines these constants when the selected target device
supports the DSPr2 engine.

__mips_dsp_rev 2
__mips_micromips 1

The compiler defines these constants when we are building for the microMIPS
compressed ISA as the default using the -mmicromips option.

__mips_soft_float 1

The compiler defines this constant when we are compiling for software
floating-point operations.

See also the device-specific include files (pic32mx/include/proc/p32*.h) for other macros that
can be used to determine the features available on the selected device. You will find these macros
near the end of the header file.

22.4.2 SDE Compatibility Macros
®

The MIPS SDE (Software Development Environment) defines a number of macros, most with the
prefix “_MIPS_”, which characterize various target specific options, some determined by command
line options (for example, -mint64). Where applicable, these macros will be defined by the compiler
in order to ease porting applications and middleware from the SDE to the compiler.
_MIPS_SZINT
_MIPS_SZLONG
_MIPS_SZPTR
__mips_no_float

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 212

XC32 Compiler for PIC32M
Preprocessing
__mips__
_mips

Always defined.

_MIPS_ARCH_PIC32MX
_MIPS_TUNE_PIC32MX
_R3000
__R3000
__R3000__
__mips_soft_float
__MIPSEL
__MIPSEL__
_MIPSEL
R3000
MIPSEL

Defined if -ansi is not specified.

_mips_fpr

Defined as 32.

__mips16

Defined if -mips16 specified.

__mips

Defined as 32.

__mips_isa_rev

Defined as 2.

_MIPS_ISA

Defined as _MIPS_ISA_MIPS32.

22.4.3 Processor-Specific Macros
The proc/p*.h header files define a number of processor-specific macros. To use these macros,
#include <xc.h> in your source file. This list is not comprehensive.
__PIC32_HAS_L1CACHE

Defined if and only if the target device supports an L1 cache

__PIC32_HAS_MIPS32R2

Defined if and only if the target device supports the MIPS32r2
Instruction Set

__PIC32_HAS_MICROMIPS

Defined if and only if the target device supports the microMIPS32
Instruction Set

__PIC32_HAS_MIPS16

Defined if and only if the target device supports the MIPS16
Instruction Set

__PIC32_HAS_DSPR2

Defined if and only if the target device supports the DSPenhanced core

__PIC32_HAS_FPU64

Defined if and only if the target device supports the 64-bit
Hardware Floating-Point Unit. Also check __mips_hard_float to
determine if the compiler is set to compile for the FPU.

_<Interrupt-Source>_VECTOR

Defined to the vector number for the interrupt source and
intended to be used with the vector function attribute. for
example, #define _CORE_TIMER_VECTOR 0

_<Interrupt-Source>_IRQ

Defined to the IRQ number for the interrupt source. for example,
#define _CORE_SOFTWARE_0_IRQ 1

_<SFR>_<Bitfield>_POSITION

Defined to the position of a bitfield within a special function
register (SFR). for example, #define _WDTCON_ON_POSITION
0x0000000F

_<SFR>_<Bitfield>_MASK

Defined to a mask of the bitfield within a special function register
(SFR). for example, #define _WDTCON_ON_MASK 0x00008000

_<SFR>_<Bitfield>_LENGTH

Defined to the length of the bitfield within a special function
register (SFR). for example, #define _WDTCON_ON_LENGTH
0x00000001

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 213

XC32 Compiler for PIC32M
Preprocessing
<Special-Function-Register>

Defined to the Special Function Register name. for example,
#define T5CON T5CON
This macro allows preprocessor testing for the existence of an SFR
before using it. For example:
#if defined(T5CON)
T5CONbits.ON = 1;
#endif

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 214

XC32 Compiler for PIC32M
Linking Programs

23.

Linking Programs
®

See the MPLAB XC32 Assembler, Linker and Utilities User’s Guide (DS50002186) for more detailed
information on the linker.
The compiler will automatically invoke the linker unless the compiler has been requested to stop
after producing an intermediate file.
Linker scripts are used to specify the available memory regions and where sections should be
positioned in those regions.
The linker creates a map file which details the memory assigned to sections. The map file is the best
place to look for memory information.

23.1

23.2

Replacing Library Symbols

Unlike with the Microchip MPLAB XC8 compiler, not all library functions can be replaced with
user-defined routines using MPLAB XC32 C/C++ Compiler. Only weak library functions (see ) can
be replaced in this way. For those that are weak, any function you write in your code will replace an
identically named function in the library files.

Linker-Defined Symbols

The 32-bit linker defines several symbols that can be used in your C code development. Please see
®
the MPLAB XC32 Assembler, Linker and Utilities User’s Guide (DS50002186) for more information.
The linker defines the symbols _ramfunc_begin and _bmxdkpba_address, which represent the
starting address in RAM where ram functions will be accessed, and the corresponding address in
the program memory from which the functions will be copied. They are used by the default runtime
start-up code to initialize the bus matrix if ram functions exist in the project, see 16.3. Allocation of
Function Code.
The linker also defines the symbol _stack, which is used by the runtime start-up code to initialize
the stack pointer. This symbol represents the starting address for the software stack.
All the above symbols are rarely required for most programs, but may assist you if you are writing
your own runtime start-up code.

23.3

Default Linker Script

For PIC32MX Devices Only:
If no linker script or alternative Device Family Pack (DFP) is specified on the command line, the linker
will use an internal version known as the built-in default linker script. The default linker script has
section mapping that is appropriate for all PIC32 MCUs. It uses an INCLUDE directive to include the
device-specific memory regions.
The default linker script is appropriate for most PIC32 MCU applications. Only applications with
specific memory-allocation needs will require an application-specific linker script. The default linker
script can be examined by invoking the linker with the --verbose option:
xc32-ld --verbose
In a normal tool-suite installation, a copy of the default linker script is located at
\pic32mx\lib\ldscripts\elf32pic32mx.x. Note that this file is only a copy of the default linker
script. The script that the linker uses is internal to the linker.
The device-specific portion of the linker script is located in
\pic32mx\pic32mx\lib\proc\32MXGENERIC\procdefs.ld, where device is the device value
specified to the -mprocessor compilation-driver (xc32-gcc) option.
If the -mdfp option has been used, the linker script in the specified DFP will be used instead.
For PIC32MZ and Later Devices:

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 215

XC32 Compiler for PIC32M
Linking Programs

The linker script for PIC32MZ devices are contained within a single file (for example, pic32mx/lib/
proc/32MZ2048ECH100/p32MZ2048ECH100.ld). This eliminates the dependency on two files
(elf32pic32mx.x and procdefs.ld) used by the older linker-script model. Like before, the xc32gcc compilation driver will pass the device-specific linker script to the linker when building with
-mprocessor option. And additionally, the linker script in the specified DFP will be selected if the
-mdfp option has been used.
The default linker script contains the following categories of information:
•

23.3.1. Output Format and Entry Points

•

23.3.2. Default Values for Minimum Stack and Heap Sizes

•

23.3.3. Processor Definitions Include File for PIC32MX Family
– 23.3.3.1. Inclusion of Processor-Specific Object File(s)
– 23.3.3.2. Optional Inclusion of Processor-Specific Peripheral Libraries
– 23.3.3.3. Base Exception Vector Address and Vector Spacing Symbols
– 23.3.3.4. Memory Address Equates
– 23.3.3.5. Memory Regions
– 23.3.3.6. Configuration Words Input/Output Section Map

•

23.3.4. Input/Output Section Map

Note: All addresses specified in the linker scripts should be specified as virtual addresses, not
physical addresses.

23.3.1 Output Format and Entry Points
The first several lines of the default linker script define the output format and the entry point for the
application.
OUTPUT_FORMAT("elf32-tradlittlemips")
OUTPUT_ARCH(pic32mx)
ENTRY(_reset)
The OUTPUT_FORMAT line selects the object file format for the output file. The output object file
format generated by the 32-bit language tools is a traditional, little-endian, MIPS, ELF32 format.
The OUTPUT_ARCH line selects the specific machine architecture for the output file. The output files
generated by the 32-bit language tools contain information that identifies the file was generated for
the PIC32 architecture.
The ENTRY line selects the entry point of the application. This is the symbol identifying the location
of the first instruction to execute. The 32-bit language tools begins execution at the instruction
identified by the _reset label.

23.3.2 Default Values for Minimum Stack and Heap Sizes
The next section of the default linker script provides default values for the minimum stack and heap
sizes.
/*
* Provide for a minimum stack and heap size
* - _min_stack_size - represents the minimum space that must
*
be made available for the stack. Can
*
be overridden from the command line
*
using the linker's --defsym option.
* - _min_heap_size - represents the minimum space that must
*
be made available for the heap. Can
*
be overridden from the command line
*
using the linker's --defsym option.
*/

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 216

XC32 Compiler for PIC32M
Linking Programs
EXTERN (_min_stack_size _min_heap_size)
PROVIDE(_min_stack_size = 0x400) ;
PROVIDE(_min_heap_size = 0) ;

The EXTERN line ensures that the rest of the linker script has access to the default values of
_min_stack_size and _min_heap_size assuming that the user does not override these values
using the linker’s --defsym command line option.
The two PROVIDE lines ensure that a default value is provided for both _min_stack_size and
_min_heap_size. The default value for the minimum stack size is 1024 bytes (0x400). The default
value for the minimum heap size is 0 bytes.

23.3.3 Processor Definitions Include File for PIC32MX Family
The next line in the default linker script pulls in information specific to the processor.
INCLUDE procdefs.ld
The file procdefs.ld is included in the linker script at this point. The file is searched for in the
current directory and in any directory specified with the -L command line option. The compiler shell
ensures that the correct directory is passed to the linker with the -L command line option based on
the processor selected with the -mprocessor command line option.
The processor definitions linker script contains the following pieces of information:
•

23.3.3.1. Inclusion of Processor-Specific Object File(s)

•

23.3.3.3. Base Exception Vector Address and Vector Spacing Symbols

•

23.3.3.4. Memory Address Equates

•

23.3.3.5. Memory Regions

•

23.3.3.6. Configuration Words Input/Output Section Map

23.3.3.1 Inclusion of Processor-Specific Object File(s)

This section of the processor definitions linker script ensures that the processor-specific object file(s)
get included in the link.
/**************************************************************
* Processor-specific object file. Contains SFR
definitions.

**************************************************************/
INPUT("processor.o")
The INPUT line specifies that processor.o should be included in the link as if this file were named
on the command line. The linker attempts to find this file in the current directory. If it is not
found, the linker searches through the library search paths (that is, the paths specified with the -L
command line option).

23.3.3.2 Optional Inclusion of Processor-Specific Peripheral Libraries

Note: The legacy peripheral libraries are deprecated and are replaced by the MPLAB Harmony
libraries, installed separately.
This section of the processor definitions linker script ensures that the processor-specific peripheral
libraries get included, but only if the files exist.

/*********************************************************************
* Processor-specific peripheral libraries are
optional

*********************************************************************/

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 217

XC32 Compiler for PIC32M
Linking Programs

OPTIONAL("libmchp_peripheral.a")
OPTIONAL("libmchp_peripheral_32MX795F512L.a")
The OPTIONAL lines specify that libmchp_peripheral.a and
libmchp_peripheral_32MX795F512L.a should be included in the link as if the files were named
on the command line. The linker attempts to find these files in the current directory. If they are not
found in the current directory, the linker searches through the library search paths. If they are not
found in the library search paths, the link process continues without error. The linker will error only
when a symbol from the -peripheral library is required but not found elsewhere.

23.3.3.3 Base Exception Vector Address and Vector Spacing Symbols

This section of the processor definitions linker script defines values for the base exception vector
address and vector spacing.
/**************************************************************
* For interrupt vector handling
**************************************************************/
_vector_spacing = 0x00000001;
_ebase_address = 0x9FC01000;
The first line defines a value of 1 for _vector_spacing. The available memory for exceptions only
supports a vector spacing of 1. The second line defines the location of the base exception vector
address (EBASE).

On some devices, the base exception vector address is located in the KSEG0 boot segment. On
other devices, the size of the KSEG0 boot segment is not sufficient for the vector table, so the base
exception vector address is located in the KSEG0 program segment. In general, devices with at least
12 KB in the KSEG0 boot segment use the boot flash for the exception vector table. Devices with less
than 12 KB in the KSEG0 boot segment use the KSEG0 program segment for the exception vector
table. Be sure to check the procdefs.ld include file for the default address for your target device.

23.3.3.4 Memory Address Equates

This section of the processor definitions linker script provides information about certain memory
addresses required by the default linker script.
/**************************************************************
* Memory Address Equates
**************************************************************/
_RESET_ADDR
0xBFC00000;

=

_BEV_EXCPT_ADDR
0xBFC00380;

=

_DBG_EXCPT_ADDR
0xBFC00480;

=

_DBG_CODE_ADDR
0xBFC02000;

=

_GEN_EXCPT_ADDR
=
_ebase_address + 0x180;

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 218

XC32 Compiler for PIC32M
Linking Programs

The _RESET_ADDR defines the processor’s Reset address. This is the virtual begin address of the IFM
boot section in Kernel mode.
The _BEV_EXCPT_ADDR defines the address that the processor jumps to when an exception is
encountered and StatusBEV = 1.
The _DBG_EXCPT_ADDR defines the address that the processor jumps to when a debug exception is
encountered.
The _DBG_CODE_ADDR defines the address that is the start address of the debug executive. Note
that this address may vary depending on the size of the KSEG0 boot segment on your target device.
The _GEN_EXCPT_ADDR defines the address that the processor jumps to when an exception is
encountered and StatusBEV = 0.

23.3.3.5 Memory Regions

This section of the processor definitions linker script provides information about the memory
regions that are available on the device.
/**************************************************************
* Memory Regions
*
* Memory regions without attributes cannot be
used for
* orphaned sections. Only sections specifically
assigned to
* these regions can be allocated into these
regions.

**************************************************************/
MEMORY
{
kseg0_program_mem (rx) : ORIGIN = 0x9D000000,
LENGTH = 0x8000

kseg0_boot_mem : ORIGIN = 0x9FC00490, LENGTH = 0x970
exception_mem : ORIGIN = 0x9FC01000, LENGTH = 0x1000
kseg1_boot_mem : ORIGIN = 0xBFC00000, LENGTH = 0x490
debug_exec_mem : ORIGIN = 0xBFC02000, LENGTH = 0xFF0
config3
0x4

: ORIGIN = 0xBFC02FF0, LENGTH =

config2
0x4

: ORIGIN = 0xBFC02FF4, LENGTH =

config1
0x4

: ORIGIN = 0xBFC02FF8, LENGTH =

config0
0x4

: ORIGIN = 0xBFC02FFC, LENGTH =

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 219

XC32 Compiler for PIC32M
Linking Programs

kseg1_data_mem : ORIGIN = 0xA0000000, LENGTH = 0x2000
sfrs

0x10000

: ORIGIN = 0xBF800000, LENGTH =

}
Note: L1 cache devices use kseg1_data_mem.
Eleven memory regions are defined with an associated start address and length:
•

Program memory region (kseg0_program_mem) for application code

•

Boot memory regions (kseg0_boot_mem and kseg1_boot_mem)

•

Exception memory region (exception_mem)

•

Debug executive memory region (debug_exec_mem)

•

Configuration memory regions (config3, config2, config1, and config0)

•

Data memory region (kseg1_data_mem)

•

SFR memory region (sfrs)

The default linker script uses these names to locate sections into the correct regions. Sections which
are non-standard become orphaned sections. The attributes of the memory regions are used to
locate these orphaned sections. The attributes (rx) specify that read-only sections or executable
sections can be located into the program memory regions. Similarly, the attributes (w!x) specify that
sections that are not read-only and not executable can be located in the data memory region. Since
no attributes are specified for the boot memory region, the configuration memory regions, or the
SFR memory region, only specified sections may be located in these regions (that is, orphaned
sections may not be located in the boot memory regions, the exception memory region, the
configuration memory regions, the debug executive memory region, or the SFR memory region).

23.3.3.6 Configuration Words Input/Output Section Map

The last section in the processor definitions linker script is the input/output section map for
Configuration Words. This section map is additive to the Input/Output Section Map found in the
default linker script (see 23.3.4. Input/Output Section Map). It defines how input sections for
Configuration Words are mapped to output sections for Configuration Words. Note that input
sections are portions of an application that are defined in source code, while output sections
are created by the linker. Generally, several input sections may be combined into a single output
section. All output sections are specified within a SECTIONS command in the linker script.

For each Configuration Word that exists on the specific processor, a distinct output section
named .config_address exists where address is the location of the Configuration Word in
memory. Each of these sections contains the data created by the #pragma config directive (see
22.3. Pragma Directives) for that Configuration Word. Each section is assigned to their respective
memory region (con-fign).
SECTIONS
{
.config_BFC02FF0 : {
*(.config_BFC02FF0)
} > config3
.config_BFC02FF4 : {
*(.config_BFC02FF4)
} > config2

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 220

XC32 Compiler for PIC32M
Linking Programs

.config_BFC02FF8 : {
*(.config_BFC02FF8)
} > config1
.config_BFC02FFC : {
*(.config_BFC02FFC)
} > config0
}

23.3.4 Input/Output Section Map

The last section in the default linker script is the input/output section map. The section map is the
heart of the linker script. It defines how input sections are mapped to output sections. Note that
input sections are portions of an application that are defined in source code, while output sections
are created by the linker. Generally, several input sections may be combined into a single output
section. All output sections are specified within a SECTIONS command in the linker script.

23.3.4.1 .Config_<Address> Sections

These sections map the Configuration Words to their corresponding absolute addresses on the
target device. The compiler's config pragma generates the input sections using this naming
convention, and the linker script then maps the compiler-generated input section to the output
section mapped to the corresponding absolute address.

23.3.4.2 .Reset Section

This section contains the code that is executed when the processor performs a Reset. This section
is located at the Reset address (_RESET_ADDR), as specified in the processor definitions linker script
and is assigned to the boot memory region (kseg1_boot_mem). The .reset output section also
contains the C start-up code from the .reset.startup input section.
.reset _RESET_ADDR :
{
KEEP(*(.reset))
KEEP(*(.reset.startup))
} > kseg1_boot_mem

23.3.4.3 .bev_excpt Section

This section contains the handler for exceptions that occur when StatusBEV = 1. This section is
located at the BEV exception address (_BEV_EXCPT_ADDR) as specified in the processor definitions
linker script and is assigned to the boot memory region (kseg1_boot_mem).
(kseg1_boot_mem).
.bev_excpt _BEV_EXCPT_ADDR :
{
(*(.bev_handler))
} > kseg1_boot_mem

23.3.4.4 .dbg_excpt Section

This section reserves space for the debug exception vector. This section is only allocated if the
symbol _DEBUGGER has been defined. (This symbol is defined if the -mde-bugger command
line option is specified to the shell.) This section is located at the debug exception address
(_DBG_EXCPT_ADDR) as specified in the processor definitions linker script and is assigned to the
boot memory region (kseg1_boot_mem). The section is marked as NOLOAD as it is only intended to
ensure that application code cannot be placed at locations reserved for the debug executive.
.dbg_excpt _DBG_EXCPT_ADDR (NOLOAD) :
{
. += (DEFINED (_DEBUGGER) ? 0x8 : 0x0);
} > kseg1_boot_mem

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 221

XC32 Compiler for PIC32M
Linking Programs

23.3.4.5 .dbg_code Section

This section reserves space for the debug exception handler. This section is only allocated if the
symbol _DEBUGGER has been defined. (This symbol is defined if the -mde-bugger command line
option is specified to the shell.) This section is located at the debug code address (_DBG_CODE_ADDR)
as specified in the processor definitions linker script and is assigned to the debug executive memory
region (debug_exec_mem). The section is marked as NOLOAD because it is only intended to ensure
that application code cannot be placed at locations reserved for the debug executive.
.dbg_code _DBG_CODE_ADDR (NOLOAD) :
{
. += (DEFINED (_DEBUGGER) ? 0xFF0 : 0x0);
} > debug_exec_mem

23.3.4.6 .app_excpt Section

This section contains the handler for exceptions that occur when StatusBEV = 0. This section
is located at the general exception address (_GEN_EXCPT_ADDR) as specified in the processor
definitions linker script and is assigned to the exception memory region (exception_mem).
.app_excpt _GEN_EXCPT_ADDR :
{
KEEP(*(.gen_handler))
} > exception_mem

23.3.4.7 .vector_0 .. .vector_63 Sections (PIC32MX Interrupt Vector Tables)

PIC32MX devices use an Interrupt Vector Controller that provides 64 interrupt vectors with uniform,
user-configurable spacing.
For these devices, each vector in the table is created as an output section located at an absolute
address based on values of the _ebase_address and _vector_spacing symbols. There is
one .vector_n output section for each of the 64 vectors in the table.
These sections contain the handler for each of the interrupt vectors. These sections are located at
the correct vectored addresses using the formula:
_ebase_address + 0x200 + (_vector_spacing << 5) * n
where n is the respective vector number.
Each of the sections is followed by an assert that ensures the code located at the vector does not
exceed the vector spacing specified.
.vector_n _ebase_address + 0x200 + (_vector_spacing << 5) * n :
{
KEEP(*(.vector_n))
} > exception_mem
ASSERT (SIZEOF(.vector_n) < (_vector_spacing << 5), "function at exception vector n too
large")

23.3.4.8 .vectors Section

Some PIC32 families feature variable offsets for vector spacing. This feature allows the interrupt
vector spacing to be configured according to application needs. A specific interrupt vector offset can
be set for each vector using its associated OFFxxx register. For details on the interrupt vector-table
variable offset feature, refer to the “PIC32 -Family Reference Manual” (DS61108) and also the data
sheet for your specific PIC32 MCU.
The application source code is responsible for creating a .vector_n input section for each interrupt
vector. The C/C++ compiler creates this section when either the -vector(n) or the at_vector(n)
attribute is applied to the interrupt service routine. In assembly code, use the .section directive to
create a new named section.
The device-specific linker script creates a single output section named .vectors that groups all of
the individual .vector_n input sections from the project. The start of the interrupt-vector table is

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 222

XC32 Compiler for PIC32M
Linking Programs

mapped to the address (_ebase_address + 0x200). The default value of the _ebase_address
symbol is also provided in the linker script.
For each vector, the linker script also creates a symbol named __vector_offset_n, whose value is
the offset of the vector address from the _ebase_address address.
PROVIDE(_ebase_address = 0x9D000000);
SECTIONS {
/* Interrupt vector table with vector offsets */
.vectors _ebase_address + 0x200 :
{
/* Symbol __vector_offset_n points to .vector_n if it exists,
* otherwise points to the default handler. The
* vector_offset_init.o module then provides a .data section
* containing values used to initialize the vector-offset SFRs
* in the crt0 startup code.
*/
__vector_offset_0 = (DEFINED(__vector_dispatch_0) ? (. - _ebase_address) :
__vector_offset_default); KEEP(*(.vector_0))
__vector_offset_1 = (DEFINED(__vector_dispatch_1) ? (. - _ebase_address) :
__vector_offset_default); KEEP(*(.vector_1))
__vector_offset_2 = (DEFINED(__vector_dispatch_2) ? (. - _ebase_address) :
__vector_offset_default); KEEP(*(.vector_2))
/* ... */
__vector_offset_190 = (DEFINED(__vector_dispatch_190) ? (. - _ebase_address) :
__vector_offset_default); KEEP(*(.vector_190))
}
}

The vector-offset initialization module (vector_offset_init.o) uses the __vector_offset_n
symbols defined in the default linker script. The value of each symbol is the offset of the vector’s
address from the ebase register’s address. The vector-offset initialization module, uses the symbol
value to create a .data section using the address of the corresponding OFFxxx special function
register. This means that the standard linker-generated data-initialization template contains the
values used to initialize the OFFxxx registers.
With these .data sections added to the project and the linker-generated data-initialization
template, the standard runtime startup code initializes the OFFxxx special function registers as
regular initialized data. No special code is required in the startup code to initialize the OFFxxx
registers.

23.3.4.9 .text Section

The standard executable code sections are no longer mapped to the .text output section.
However, a few special executable sections are still mapped here as shown below. This section
is assigned to the program memory region (kseg0_program_mem) and has a fill value of NOP (0).
The built-in linker script no longer maps standard .text executable code input sections. By not
mapping these sections in the linker script, we allow these sections to be allocated using the best-fit
allocator rather than the sequential allocator. Sections that are unmapped in the linker script can
flow around absolute sections specified in code, whereas sections that are linker-script mapped are
grouped together and allocated sequentially. This potentially causes conflicts with absolute sections
(using the address function attribute).
.text ORIGIN(kseg0_program_mem) :
{
*(.stub .gnu.linkonce.t.*)
KEEP (*(.text.*personality*))
*(.gnu.warning)
*(.mips16.fn.*)
*(.mips16.call.*)
} > kseg0_program_mem =0

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 223

XC32 Compiler for PIC32M
Linking Programs

23.3.4.10 C++ Initilization Sections

The sections .init, .preinit_array, .init_array, .fini_array, .ctors, and .dtors are all
used for the construction and destruction of file-scope static-storage C++ objects.
/* Global-namespace object initialization */
.init
:
{
KEEP (*crti.o(.init))
KEEP (*crtbegin.o(.init))
KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o *crtn.o ).init))
KEEP (*crtend.o(.init))
KEEP (*crtn.o(.init))
. = ALIGN(4) ;
} >kseg0_program_mem
.fini
:
{
KEEP (*(.fini))
. = ALIGN(4) ;
} >kseg0_program_mem
.preinit_array
:
{
PROVIDE_HIDDEN (__preinit_array_start = .);
KEEP (*(.preinit_array))
PROVIDE_HIDDEN (__preinit_array_end = .);
. = ALIGN(4) ;
} >kseg0_program_mem
.init_array
:
{
PROVIDE_HIDDEN (__init_array_start = .);
KEEP (*(SORT(.init_array.*)))
KEEP (*(.init_array))
PROVIDE_HIDDEN (__init_array_end = .);
. = ALIGN(4) ;
} >kseg0_program_mem
.fini_array
:
{
PROVIDE_HIDDEN (__fini_array_start = .);
KEEP (*(SORT(.fini_array.*)))
KEEP (*(.fini_array))
PROVIDE_HIDDEN (__fini_array_end = .);
. = ALIGN(4) ;
} >kseg0_program_mem
.ctors
:
{
/* XC32 uses crtbegin.o to find the start of
the constructors, so we make sure it is
first. Because this is a wildcard, it
doesn't matter if the user does not
actually link against crtbegin.o; the
linker won't look for a file to match a
wildcard. The wildcard also means that it
doesn't matter which directory crtbegin.o
is in. */
KEEP (*crtbegin.o(.ctors))
KEEP (*crtbegin?.o(.ctors))
/* We don't want to include the .ctor section from
the crtend.o file until after the sorted ctors.
The .ctor section from the crtend file contains the
end of ctors marker and it must be last */
KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .ctors))
KEEP (*(SORT(.ctors.*)))
KEEP (*(.ctors))
. = ALIGN(4) ;
} >kseg0_program_mem
.dtors
:
{
KEEP (*crtbegin.o(.dtors))
KEEP (*crtbegin?.o(.dtors))
KEEP (*(EXCLUDE_FILE (*crtend.o *crtend?.o ) .dtors))
KEEP (*(SORT(.dtors.*)))
KEEP (*(.dtors))
. = ALIGN(4) ;
} >kseg0_program_mem
The order of the input sections within each output section is significant.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 224

XC32 Compiler for PIC32M
Linking Programs

Note: The order of the input sections within each output section is significant.

23.3.4.11 .rodata Section

Standard read-only sections are not mapped in the linker script. A few special read-only sections
are still mapped in the linker script, but most sections are unmapped, allowing them to be
handled by the best fit allocator. This section is assigned to the program memory region
(kseg0_program_mem).
.rodata
:
{
*(.gnu.linkonce.r.*)
*(.rodata1)
} > kseg0_program_mem

23.3.4.12 .sdata2 Section

This section collects the small initialized constant global and static data from all of the application’s
input files. Because of the constant nature of the data, this section is also a read-only section. This
section is assigned to the program memory region (kseg0_program_mem).
/*
* Small initialized constant global and static data can be
* placed in the .sdata2 section. This is different from
* .sdata, which contains small initialized non-constant
* global and static data.
*/
.sdata2
:
{
*(.sdata2 .sdata2.* .gnu.linkonce.s2.*)
} > kseg0_program_mem

23.3.4.13 .sbss2 Section

This section collects the small uninitialized constant global and static data from all of the
application’s input files. Because of the constant nature of the data, this section is also a read-only
section. This section is assigned to the program memory region (kseg0_program_mem).
/*
* Uninitialized constant global and static data (that is,
* variables which will always be zero). Again, this is
* different from .sbss, which contains small non-initialized,
* non-constant global and static data.
*/
.sbss2
:
{
*(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)
} > kseg0_program_mem

23.3.4.14 .dbg_data Section

This section reserves space for the data required by the debug exception handler. This section
is only allocated if the symbol _DEBUGGER has been defined. (This symbol is defined if the
-mdebugger command line option is specified to the shell.) This section is assigned to the data
memory region (kseg1_data_mem). The section is marked as NOLOAD as it is only intended to
ensure that application data cannot be placed at locations reserved for the debug executive.
.dbg_data (NOLOAD) :
{
. += (DEFINED (_DEBUGGER) ? 0x200 : 0x0);
} > kseg1_data_mem

23.3.4.15 .data Section

The linker generates a data-initialization template that the C start-up code uses to initialize variables.

23.3.4.16 .got Section

This section collects the global offset table from all of the application’s input files. This section is
assigned to the data memory region (kseg1_data_mem) with a load address located in the program

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 225

XC32 Compiler for PIC32M
Linking Programs

memory region (kseg0_program_mem). A symbol is defined to represent the location of the Global
Pointer (_gp).
_gp = ALIGN(16) + 0x7FF0 ;
.got
:
{
*(.got.plt) *(.got)
} > kseg1_data_mem AT> kseg0_program_mem

23.3.4.17 .sdata Section

This section collects the small initialized data from all of the application’s input files. This section
is assigned to the data memory region (kseg1_data_mem) with a load address located in the
program memory region (kseg0_program_mem). Symbols are defined to represent the virtual begin
(_sdata_begin) and end (_sdata_end) addresses of this section.
/*
* We want the small data sections together, so
* single-instruction offsets can access them all, and
* initialized data all before uninitialized, so
* we can shorten the on-disk segment size.
*/
.sdata
:
{
_sdata_begin = . ;
*(.sdata .sdata.* .gnu.linkonce.s.*)
_sdata_end = . ;
} > kseg1_data_mem AT> kseg0_program_mem

23.3.4.18 .lit8 Section

This section collects the 8-byte constants (usually floating-point) which the assembler decides to
store in memory rather than in the instruction stream from all of the application’s input files. This
section is assigned to the data memory region (kseg1_data_mem) with a load address located in the
program memory region (kseg0_program_mem).
.lit8
:
{
*(.lit8)
} > kseg1_data_mem AT> kseg0_program_mem

23.3.4.19 .lit4 Section

This section collects the 4-byte constants (usually floating-point) which the assembler decides to
store in memory rather than in the instruction stream from all of the application’s input files. This
section is assigned to the data memory region (kseg1_data_mem) with a load address located in the
program memory region (kseg0_program_mem). A symbol is defined to represent the virtual end
address of the initialized data (_data_end).
.lit4
:
{
*(.lit4)
} > kseg1_data_mem AT> kseg0_program_mem
_data_end = . ;

23.3.4.20 .sbss Section

This section collects the small uninitialized data from all of the application’s input files. This section
is assigned to the data memory region (kseg1_data_mem). A symbol is defined to represent the
virtual begin address of uninitialized data (_bss_begin). Symbols are also defined to represent the
virtual begin (_sbss_begin) and end (_sbss_end) addresses of this section.
_bss_begin = . ;
.sbss
:
{
_sbss_begin = . ;
*(.dynsbss)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 226

XC32 Compiler for PIC32M
Linking Programs
*(.sbss .sbss.* .gnu.linkonce.sb.*)
*(.scommon)
_sbss_end = . ;
} > kseg1_data_mem

23.3.4.21 .bss Section
This section collects the uninitialized data from all of the application’s input files. This section is
assigned to the data memory region (kseg1_data_mem). A symbol is defined to represent the
virtual end address of uninitialized data (_bss_end). A symbol is also to represent the virtual end
address of data memory (_end).
.bss
:
{
*(.dynbss)
*(.bss .bss.* .gnu.linkonce.b.*)
*(COMMON)
/*
* Align here to ensure that the .bss section occupies
* space up to _end. Align after .bss to ensure correct
* alignment even if the .bss section disappears because
* there are no input sections.
*/
. = ALIGN(32 / 8) ;
} > kseg1_data_mem
. = ALIGN(32 / 8) ;
_end = . ;
_bss_end = . ;

23.3.4.22 .heap Section
The linker now dynamically reserves an area of memory for the heap. The .heap section is no
longer mapped in the linker script. The linker finds the largest unused gap of memory after all other
sections are allocated and uses that gap for both the heap and the stack. The minimum amount of
space reserved for the heap is determined by the symbol _min_heap_size.

23.3.4.23 .stack Section
The linker now dynamically reserves an area of memory for the stack. The .stack section is no
longer mapped in the linker script. The linker finds the largest unused gap of memory after all other
sections are allocated and uses that gap for both the heap and the stack. The minimum amount of
space reserved for the stack is determined by the symbol _min_stack_size.

23.3.4.24 .ramfunc Section
The linker now dynamically collects the 'ramfunc' attributed and ".ramfunc" named sections
and allocates them sequentially in an appropriate range of memory. The first ramfunc attributed
function is placed at the highest appropriately aligned address.
The presence of a ramfunc section causes the linker to emit the symbols necessary for the crt0.S
start-up code to initialize the PIC32 bus matrix appropriately.
/*
* RAM functions go at the end of our stack and heap allocation.
* Alignment of 2K required by the boundary register (BMXDKPBA).
*
* RAM functions are now allocated by the linker. The linker generates
* _ramfunc_begin and _bmxdkpba_address symbols depending on the
* location of RAM functions.
*/
_bmxdudba_address = LENGTH(kseg1_data_mem) ;
_bmxdupba_address = LENGTH(kseg1_data_mem) ;

23.3.4.25 Stack Location
A symbol is defined to represent the location of the Stack Pointer (_stack). As described previously,
the heap and the stack are now allocated to the largest available gap of memory after other sections
have been allocated.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 227

XC32 Compiler for PIC32M
Linking Programs

For PIC32 devices with more than 64K of data memory, GP relative addressing mode should
not be used. To avoid conflict of using GP-relative addressing to the linker generated
symbols, allocate the symbols in section "_linkergenerated": extern unsigned int
__attribute__((section("_linkergenerated"))) _splim;

23.3.4.26 Debug Sections

The debug sections contain DWARF2 debugging information. They are not loaded into program
Flash.
/* Stabs debugging sections. */
.stab
0 : { *(.stab) }
.stabstr
0 : { *(.stabstr) }
.stab.excl
0 : { *(.stab.excl) }
.stab.exclstr 0 : { *(.stab.exclstr) }
.stab.index
0 : { *(.stab.index) }
.stab.indexstr 0 : { *(.stab.indexstr) }
.comment
0 : { *(.comment) }
/* DWARF debug sections.
Symbols in the DWARF debugging sections are relative to the beginning
of the section so we begin them at 0. */
/* DWARF 1 */
.debug
0 : { *(.debug) }
.line
0 : { *(.line) }
/* GNU DWARF 1 extensions */
.debug_srcinfo 0 : { *(.debug_srcinfo) }
.debug_sfnames 0 : { *(.debug_sfnames) }
/* DWARF 1.1 and DWARF 2 */
.debug_aranges 0 : { *(.debug_aranges) }
.debug_pubnames 0 : { *(.debug_pubnames) }
/* DWARF 2 */
.debug_info
0 : { *(.debug_info .gnu.linkonce.wi.*) }
.debug_abbrev
0 : { *(.debug_abbrev) }
.debug_line
0 : { *(.debug_line) }
.debug_frame
0 : { *(.debug_frame) }
.debug_str
0 : { *(.debug_str) }
.debug_loc
0 : { *(.debug_loc) }
.debug_macinfo 0 : { *(.debug_macinfo) }
/* SGI/MIPS DWARF 2 extensions */
.debug_weaknames 0 : { *(.debug_weaknames) }
.debug_funcnames 0 : { *(.debug_funcnames) }
.debug_typenames 0 : { *(.debug_typenames) }
.debug_varnames 0 : { *(.debug_varnames) }
.debug_pubtypes 0 : { *(.debug_pubtypes) }
.debug_ranges
0 : { *(.debug_ranges) }
/DISCARD/ : { *(.rel.dyn) }
.gnu.attributes 0 : { KEEP (*(.gnu.attributes)) }
/DISCARD/ : { *(.note.GNU-stack) }
/DISCARD/ : { *(.note.GNU-stack) *(.gnu_debuglink) *(.gnu.lto_*) *(.discard) }

23.3.4.27 Variables Allocated to L1 Cached Memory

For devices featuring an L1 data cache, data variables are now allocated to the KSEG0 data-memory
region (kseg0_data_mem) making it accessible through the L1 cache. Likewise, the linker-allocated
heap and stack are allocated to the KSEG0 region. The startup code initializes the L1 cache using
symbols defining the base addresses in the linker script.

Example:
EXTERN (__pic32_init_cache_program_base_addr)
PROVIDE (__pic32_init_cache_program_base_addr = 0x9D000000) ;
EXTERN (__pic32_init_cache_data_base_addr)
PROVIDE (__pic32_init_cache_data_base_addr = 0x80000000) ;

23.3.4.28 .tlb_init_values Section

Some PIC32 devices feature a Memory Management Unit (MMU) with a Translation Lookaside Buffer
(TLB). On some of these devices, the data sheet describes specific ranges of KSEG2/KSEG3 regions as
dedicated to the Serial Quad Interface (SQI) and/or the External Bus Interface (EBI).
For these devices, the default startup code calls a module that initializes the TLB for this dedicated
memory mapping. The TLB initialization module, pic32_init_tlb_ebi_sqi.o, uses the table

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 228

XC32 Compiler for PIC32M
Linking Programs

created by this section to initialize the TLB. For more information on this format, see the copy
of the pic32_init_tlb_ebi_sqi.S source file located in your pic32m-libs/libpic32/stubs
directory.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 229

XC32 Compiler for PIC32M
Embedded Compiler Compatibility Mode

24.

Embedded Compiler Compatibility Mode
All four MPLAB XC C compilers can be placed into a compatibility mode. In this mode, they
are syntactically compatible with non-standard C language extensions, some used by other nonMicrochip embedded compiler vendors. This compatibility can allow C source code written for
other compilers to be compiled with minimum modification when using the appropriate MPLAB XC
compiler.
Since very different device architectures may be targeted by other compilers, the semantics of the
non-standard extensions associated with these compilers might be different to that in the MPLAB XC
compilers. This document indicates when the original C code may need to be reviewed.

24.1

Compiling in Compatibility Mode
The -mext=vendor option is used to enable vendor-specific syntax compatibility. The argument
vendor is a key that is used to represent the syntax. See the following table for a list of all keys
usable with the MPLAB XC compilers.
Table 24-1. Vendor Keys
Vendor key

Syntax

XC8 Support

XC16/XC-DSC Support

XC32 Support

cci

Common Compiler
Interface

Yes

Yes

Yes

iar

IAR C/C++ Compiler™
for Arm

No

Yes

Yes

The Common Compiler Interface is a language standard that is common to all Microchip MPLAB
XC compilers (although this is not implemented by XC32 when targeting PIC32C/SAM devices).
The non-standard extensions associated with this syntax are already described in 25. Common C
Interface and are not repeated here.

24.2

Syntax Compatibility
The goal of this syntax compatibility feature is to ease the migration process when porting source
code from other C compilers to the native MPLAB XC compiler syntax.
Many non-standard extensions are not required when compiling for Microchip devices and, for
these, there are no equivalent extensions offered by MPLAB XC compilers. These extensions are
then simply ignored by the MPLAB XC compilers, although a warning message is usually produced to
ensure that you are aware of the different compiler behavior. You should confirm that your project
will still operate correctly with these features disabled.
Other non-standard extensions are not compatible with Microchip devices. Errors will be generated
by the MPLAB XC compiler if these extensions are not removed from the source code. You should
review the ramifications of removing the extension and decide whether changes are required to
other source code in your project.
The following table indicates the various levels of compatibility used in the tables that are presented
throughout this guide.
Table 24-2. Level of Support Indicators
Level

Explanation

support

The syntax is accepted in the specified compatibility mode, and its meaning will mimic
its meaning when it is used with the original compiler.

support (no args)

In the case of pragmas, the base pragma is supported in the specified compatibility
mode, but the arguments are ignored.

native support

The syntax is equivalent to that which is already accepted by the MPLAB XC compiler,
and the semantics are compatible. You can use this feature without a vendor
compatibility mode having been enabled.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 230

XC32 Compiler for PIC32M
Embedded Compiler Compatibility Mode

...........continued
Level

Explanation

ignore

The syntax is accepted in the specified compatibility mode, but the implied action is
not required or performed. The extension is ignored and a warning will be issued by
the compiler.

error

The syntax is not accepted in the specified compatibility mode. An error will be issued
and compilation will be terminated.

Note that even if a C feature is supported by an MPLAB XC compiler, addresses, register names,
assembly instructions, or any other device-specific argument is unlikely to be valid when compiling
for a Microchip device. Always review code which uses these items in conjunction with the data
sheet of your target Microchip device.

24.3

Data Type
Some compilers allow use of the boolean type, bool, as well as associated values true and false,
as specified by the C99 C Language Standard. This type and these values may be used by all MPLAB
XC compilers when in compatibility mode (see note), as shown in the table below.
As indicated by the Standard, the <stdbool.h> header must be included for this feature to work as
expected when it is used with MPLAB XC compilers.
Table 24-3. Support for C99 Bool Type
IAR Compatibility Mode
Type

XC16/XC-DSC

XC32

bool

support

support

Note: Not all C99 features have been adopted by all Microchip MPLAB XC compilers.

24.4

Operator
The @ operator may be used with other compilers to indicate the desired memory location of an
object. As the table below indicates, this syntax in MPLAB XC compilers is not supported.
Any address specified with another device is unlikely to be correct on a new architecture. Review
the address in conjunction with the data sheet for your target Microchip device. For MPLAB XC16,
XC-DSC and XC32, consider using the address attribute with the revised address.
Table 24-4. Support for Non-Standard Operator
IAR Compatibility Mode

24.5

Operator

XC16/XC-DSC

XC32

@

error

error

Extended Keywords
Non-standard extensions often specify how objects are defined or accessed. Keywords are usually
used to indicate the feature. The non-standard C keywords corresponding to other compilers are
listed in the following table, as well as the level of compatibility offered by MPLAB XC compilers. The
table notes offer more information about extensions.
Table 24-5. Support for Non-Standard Keywords
IAR Compatibility Mode
Keyword

XC16/XC-DSC

XC32

__section_begin

support

support

__section_end

support

support

__section_size

support

support

__segment_begin

support

support

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 231

XC32 Compiler for PIC32M
Embedded Compiler Compatibility Mode
__segment_end

support

support

__segment_size

support

support

__sfb

support

support

__sfe

support

support

__sfs

support

support

asm(1)

native support

native support

__arm

ignore

ignore

__big_endian

error

error

__fiq

error

error

__intrinsic

ignore

ignore

__interwork

ignore

ignore

__irq

error

error

__little_endian(2)

ignore

ignore

__nested

ignore

ignore

__no_init

support

support

__noreturn

support

support

__ramfunc

ignore

support(3)

__packed

support

support

__root

support

support

__swi

ignore

ignore

__task

support

support

__weak

support

support

__thumb

ignore

ignore

__farfunc

ignore

ignore

__huge

ignore

ignore

__nearfunc

ignore

ignore

__inline

native support

native support

__asm or

Notes:
1. All assembly code specified by this construct is device-specific and will need review when porting
to any Microchip device.
2. This is the default (and only) endianism used by all MPLAB XC compilers.
3. When used with MPLAB XC32, this must be used with the __longcall__ macro for full
compatibility.

24.6

Intrinsic Functions
Intrinsic functions can be used to perform common tasks in the source code. The MPLAB XC
compilers’ support for the intrinsic functions offered by other compilers is shown in the following
table.
Table 24-6. Support for Non-Standard Intrinsic Functions
IAR Compatibility Mode
Function

XC16/XC-DSC

XC32

__disable_fiq

ignore

ignore

__disable_interrupt

support

support

__disable_irq

ignore

ignore

__enable_fiq

ignore

ignore

__enable_interrupt

support

support

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 232

XC32 Compiler for PIC32M
Embedded Compiler Compatibility Mode
__enable_irq

ignore

ignore

__get_interrupt_state

support

support

__set_interrupt_state

support

support

The header file <xc.h> must be included for supported functions to operate correctly.

24.7

Pragmas
Pragmas may be used by a compiler to control code generation. Any compiler will ignore
an unknown pragma, but many pragmas implemented by another compiler have also been
implemented by the MPLAB XC compilers in compatibility mode. The table below shows the
pragmas and the level of support when using each of the MPLAB XC compilers.
Many of these pragmas take arguments. Even if a pragma is supported by an MPLAB XC compiler,
this support may not apply to all of the pragma’s arguments. This is indicated in the table.
Table 24-7. Support for Non-Standard Pragmas
IAR Compatibility Mode
Pragma

XC16/XC-DSC

XC32

bitfields

ignore

ignore

data_alignment

support

support

default_variable_attributes

ignore

native support (section attribute)

default_function_attributes

ignore

native support (section attribute)

diag_default

ignore

ignore

diag_error

ignore

ignore

diag_remark

ignore

ignore

diag_suppress

ignore

ignore

diag_warning

ignore

ignore

include_alias

ignore

ignore

inline

support (no args)

support (no args)

language

ignore

ignore

location

support

support

message

native support

native support

object_attribute

ignore

ignore

optimize

native support

native support

pack

native support

native support

__printf_args

support

support

required

support

support

rtmodel

ignore

ignore

__scanf__args

support

support

section

support

support

segment

support

support

swi_number

ignore

ignore

type_attribute

ignore

ignore

weak

native support

native support

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 233

XC32 Compiler for PIC32M
Common C Interface

25.

Common C Interface
The Common C Interface (CCI) is available with all MPLAB XC C compilers and is designed to enhance
code portability between these compilers. For example, CCI-conforming code would make it easier
to port from a PIC18 MCU using the MPLAB XC8 C compiler to a PIC32 MCU using the MPLAB XC32
C/C++ Compiler.
The CCI assumes that your source code already conforms to the C90 or C99 Language Standard. If
you intend to use the CCI, it is your responsibility to write code that conforms. Legacy projects will
need to be migrated to achieve conformance. A compiler option must also be set to ensure that the
operation of the compiler is consistent with the interface when the project is built.

25.1

Background - The Desire for Portable Code
All programmers want to write portable source code.
Portability means that the same source code can be compiled and run in a different execution
environment than that for which it was written. Rarely can code be one hundred percent portable,
but the more tolerant it is to change, the less time and effort it takes to have it running in a new
environment.
Embedded engineers typically think of code portability as being across target devices, but this is only
part of the situation. The same code could be compiled for the same target but with a different
compiler. Differences between those compilers might lead to the code failing at compile time or
runtime, so this must be considered as well.
You can only write code for one target device and only use one brand of compiler; but if there is
no regulation of the compiler’s operation, simply updating your compiler version can change your
code’s behavior.
Code must be portable across targets, tools, and time to be truly flexible.
Clearly, this portability cannot be achieved by the programmer alone, since the compiler vendors
can base their products on different technologies, implement different features and code syntax,
or improve the way their product works. Many a great compiler optimization has broken many an
unsuspecting project.
Standards for the C language have been developed to ensure that change is managed and
code is more portable. The International Standards Organization (ISO) publishes standards for
many disciplines, including programming languages. Standards such as the ISO/IEC 9899:1999 are
universally adopted for the C programming language.

25.1.1 The C Language Standard
A C Language Standard, such as ISO/IEC 9899:1999 Standard (C99), has to reconcile two opposing
goals: freedom for compilers vendors to target new devices and improve code generation, against
the known functional operation of source code for programmers. If both goals can be met, source
code can be made portable.
The C Language Standards are implemented as a set of rules that detail not only the syntax
that a conforming C program must follow, but the semantic rules by which that program will be
interpreted. Thus, for a compiler to conform to the standard, it must ensure that a conforming C
program functions as described by the standard.
Language Standards describe implementation as the set of tools and the runtime environment on
which the code will run. If any of these change; for example, you build for and run on a different
target device, or if you update the version of the compiler you use to build, then you are using a
different implementation.
The standards uses the term behavior to mean the external appearance or action of the program.
This has nothing to do with how a program is encoded.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 234

XC32 Compiler for PIC32M
Common C Interface

Since the Language Standard is trying to achieve goals that could be construed as conflicting, some
specifications appear somewhat vague. For example, C standards states that an int type must be
able to hold at least a 16-bit value, but it does not go as far as saying what the size of an int
actually is; and the action of right-shifting a signed integer can produce different results on different
implementations; yet these different results are still compliant with the standard.
If a standard is too strict, device architectures cannot allow the compiler to conform. But if it is too
weak, programmers would see wildly differing results within different compilers and architectures,
causing the standard to lose its effectiveness.
For example, the mid-range PIC® microcontrollers do not have a data stack. Because a compiler
targeting this device cannot implement recursion, it (strictly speaking) cannot conform to the C
Language Standard. This example illustrates a situation in which the standard is too strict for
mid-range devices and tools.
The standard organizes source code whose behavior is not fully defined into groups that include the
following behaviors:
Implementation-defined behavior

This is unspecified behavior in which each implementation documents
how the choice is made.

Unspecified behavior

The standard provides two or more possibilities and imposes no
further requirements on which possibility is chosen in any particular
instance.

Undefined behavior

This is behavior for which the standard imposes no requirements.

Code that strictly conforms to a Language Standard does not produce output that is dependent
on any unspecified, undefined, or implementation-defined behavior. The size of an int, which was
used as an example earlier, falls into the category of behavior that is defined by implementation.
That is to say, the size of an int is defined by which compiler is being used, how that compiler is
being used, and the device that is being targeted.
The MPLAB XC compilers are freestanding implementations that conform to the ISO/IEC 9899:1990
Standard (referred to as the C90 standard) as well the ISO/IEC 9899:1999 Standard (C99) for
programming languages, unless otherwise stated.
For freestanding implementations (or for what are typically called embedded applications), the
standard allows non-standard extensions to the language, but obviously does not enforce how they
are specified or how they work. When working so closely to the device hardware, a programmer
needs a means of specifying device setup and interrupts, as well as utilizing the often complex world
of small-device memory architectures. This cannot be offered by the standard in a consistent way.
While the C Language Standards provides a mutual understanding for programmers and compiler
vendors, programmers need to consider the implementation-defined behavior of their tools and the
probability that they may need to use extensions to the C language that are non-standard. Both of
these circumstances can have an impact on code portability.

25.1.2 The Common C Interface
The Common C Interface (CCI) supplements the C Language Standard, such as ISO/IEC 9899:1999,
and makes it easier for programmers to achieve consistent outcomes on all Microchip devices when
using MPLAB XC C compilers.
It delivers the following improvements, all designed with portability in mind.
Refinement of the C Language Standard

The CCI documents specific behavior for some code in which actions are
implementation-defined behavior under the C Language Standard. For
example, the result of right-shifting a signed integer is fully defined by
the CCI. Note that many implementation-defined items that closely couple
with device characteristics, such as the size of an int, are not defined by
the CCI.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 235

XC32 Compiler for PIC32M
Common C Interface

25.2

Consistent syntax for non-standard
extensions

The CCI non-standard extensions are mostly implemented using keywords
with a uniform syntax. They replace keywords, macros and attributes that
are the native compiler implementation. The interpretation of the keyword
can differ across each compiler, and any arguments to the keywords can
be device specific.

Coding guidelines

The CCI can indicate advice on how code should be written so that it can
be ported to other devices or compilers. While you may choose not to
follow the advice, it will not conform to the CCI.

Using the CCI

The CCI allows enhanced portability by refining implementation-defined behavior and standardizing
the syntax for extensions to the language.

The CCI is something you choose to follow and put into effect, thus it is relevant for new projects,
although you can choose to modify existing projects so they conform.
For your project to conform to the CCI, you must do the following things.
•

Enable the CCI
Select the MPLAB X IDE widget Use CCI Syntax in your project, or use the command-line option
that is equivalent.

•

Include <xc.h> in every module
Some CCI features are only enabled if this header is seen by the compiler.

•

Ensure C Language Standard compliance
Code that does not conform to the C Language Standard does not conform to the CCI.

•

Observe refinements to the Language Standard by the CCI
Some implementation-defined behavior is defined explicitly by the CCI.

•

Use the CCI extensions to the language
Use the CCI extensions rather than the native language extensions.

The next sections detail specific items associated with the CCI. These items are segregated into
those that refine the standard, those that deal with the C Language Standard extensions, and other
miscellaneous compiler options and usage. Guidelines are indicated with these items.
If any implementation-defined behavior or any non-standard extension is not discussed in this
document, then it is not part of the CCI. For example, GCC case ranges, label addresses and 24-bit
short long types are not part of the CCI. Programs which use these features do not conform to
the CCI. The compiler may issue a warning or error to indicate a non-CCI feature has been used and
the CCI is enabled.

25.3

C Language Standard Refinement

The following topics describe how the CCI refines the implementation-defined behaviors outlined in
the C Langauge Standard.

25.3.1 Source File Encoding

Under the CCI, a source file must be written using characters from the 7-bit ASCII set. Lines can be
terminated using a line feed (\n) or carriage return (\r) that is immediately followed by a line
feed. Escaped characters can be used in character constants or string literals to represent extended
characters that are not in the basic character set.
Example
The following shows a string constant being defined that uses escaped characters.
const char myName[] = "Bj\370rk\n";
Differences
All compilers have used this character set.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 236

XC32 Compiler for PIC32M
Common C Interface

Migration to the CCI
No action required.

25.3.2 The Prototype for main
The prototype for the main() function is:
int main(void);
Example
The following shows an example of how main() might be defined:
int main(void)
{
while(1)
process();
}

Differences
When targeting PIC MCUs using MPLAB XC8 a void return type for this function has been assumed.
Migration to the CCI
Each program has one definition for the main() function. Confirm the return type for main() in all
projects previously compiled for 8-bit targets.

25.3.3 Header File Specification
Header file specifications that use directory separators do not conform to the CCI.
Example
The following example shows two conforming include directives.
#include <usb_main.h>
#include "global.h"
Differences
Header file specifications that use directory separators have been allowed in previous versions of all
compilers. Compatibility problems arose when Windows-style separators “\” were used and the code
was compiled under other host operating systems. Under the CCI, no directory separators should be
used.
Migration to the CCI
Any #include directives that use directory separators in the header file specifications should be
changed. Remove all but the header file name in the directive. Add the directory path to the
compiler’s include search path or MPLAB X IDE equivalent. This will force the compiler to search the
directories specified with this option.
For example, the following code:
#include <inc/lcd.h>
should be changed to:
#include <lcd.h>
and the path to the inc directory added to the compiler’s header search path in your MPLAB X IDE
project properties, or on the command-line as follows:
-Ilcd

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 237

XC32 Compiler for PIC32M
Common C Interface

25.3.4 Include Search Paths
When you include a header file under the CCI, the file should be discoverable in the paths searched
by the compiler that are detailed below.
Header files specified in angle bracket delimiters < > should be discoverable in the search paths
that are specified by -I options (or the equivalent MPLAB X IDE option), or in the standard compiler
include directories. The -I options are searched in the order in which they are specified.
Header files specified in quote characters " " should be discoverable in the current working
directory or in the same directories that are searched when the header files are specified in angle
bracket delimiters (as above). In the case of an MPLAB X project, the current working directory is
the directory in which the C source file is located. If unsuccessful, the search paths should be to the
same directories searched when the header file is specified in angle bracket delimiters.
Any other options to specify search paths for header files do not conform to the CCI.
Example
If including a header file, as in the following directive:
#include "myGlobals.h"
the header file should be locatable in the current working directory, or the paths specified by any
-I options, or the standard compiler directories. A header file being located elsewhere does not
conform to the CCI.
Differences
The compiler operation under the CCI is not changed. This is purely a coding guideline.
Migration to the CCI
Remove any option that specifies header file search paths other than the -I option (or the
equivalent MPLAB X IDE option), and use the -I option in place of this. Ensure the header file
can be found in the directories specified in this section.

25.3.5 The Number of Significant Initial Characters in an Identifier
At least the first 255 characters in an identifier (internal and external) are significant. This extends
upon the requirement of the C Language Standard, which states a lower number of significant
characters are used to identify an object.
Example
The following example shows two poorly named variables, but names that are considered unique
under the CCI.
int stateOfPortBWhenTheOperatorHasSelectedAutomaticModeAndMotorIsRunningFast;
int stateOfPortBWhenTheOperatorHasSelectedAutomaticModeAndMotorIsRunningSlow;
Differences
When using MPLAB XC8 for PIC targets and in C90 mode, only 31 significant characters have been
accepted by default, but an option allowed this to be extended. When building in C99 mode for
these devices, there has been no limit on the number of significant characters. There has also been
no character limit when using MPLAB XC8 to target AVR MCUs, or when using any other compiler.
Migration to the CCI
No action required. You can take advantage of the less restrictive naming scheme.

25.3.6 Sizes of Types

The sizes of the basic C types, for example char, int and long, are not fully defined by the CCI.
These types, by design, reflect the size of registers and other architectural features in the target

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 238

XC32 Compiler for PIC32M
Common C Interface

device. They allow the device to efficiently access objects of this type. The C Language Standard
does, however, indicate minimum requirements for these types, as specified in <limits.h>.
If you need fixed-size types in your project, use the types defined in <stdint.h>, for example,
uint8_t or int16_t. These types are consistently defined across all XC compilers, even outside of
the CCI.
Essentially, the C language offers a choice of two groups of types: those that offer sizes and formats
that are tailored to the device you are using; or those that have a fixed size, regardless of the target.
Example
The following example shows the definition of a variable, native, whose size will allow efficient
access on the target device; and a variable, fixed, whose size is clearly indicated and remains fixed,
even though it may not allow efficient access on every device.
int native;
int16_t fixed;

Differences
This is consistent with previous types implemented by the compiler.
Migration to the CCI
If you require a C type that has a fixed size, regardless of the target device, use one of the types
defined by <stdint.h>.

25.3.7 Plain char Types
The type of a plain char is unsigned char. It is generally recommended that all definitions for the
char type explicitly state the signedness of the object.
Example
The following example:
char foobar;

defines an unsigned char object called foobar.
Differences
When targeting PIC MCUs, the MPLAB XC8 compiler has always treated plain char as an unsigned
type. When targeting AVR MCUs, the compiler has used signed char as the default plain char
type. Use of signed char has been true for MPLAB XC16, XC-DSC, and XC32. The -funsignedchar option on these compilers changes the default type to be unsigned char.
Migration to the CCI
Any definition of an object defined as a plain char needs review. Any plain char that was intended
to be a signed quantity should be replaced with an explicit definition, for example:
signed char foobar;

which is the recommended method of defining such an object.
You can alternatively use the -funsigned-char option to change the type of plain char.

25.3.8 Signed Integer Representation
The value of a signed integer is determined by taking the two’s complement of the integer.
Example
The following shows a variable, test, that is assigned the value -28 decimal.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 239

XC32 Compiler for PIC32M
Common C Interface

signed char test = 0xE4;
Differences
All compilers have represented signed integers in the way described in this section.
Migration to the CCI
No action required.

25.3.9 Integer Conversion
When converting an integer type to a signed integer of insufficient size, the original value is
truncated from the most-significant bit to accommodate the target size.
Example
The following shows an assignment of a value that is truncated.
signed char destination;
unsigned int source = 0x12FE;
destination = source;

Under the CCI, the value of destination after the alignment is -2 (that is, the bit pattern 0xFE).
Differences
All compilers have performed integer conversion in an identical fashion to that described in this
section.
Migration to the CCI
No action required.

25.3.10 Bitwise Operations on Signed Values
Bitwise operations on signed values act on the two’s complement representation, including the sign
bit. See also 25.3.11. Right-Shifting Signed Values.
Example
The following shows an example of a negative quantity involved in a bitwise AND operation.
signed char output, input = -13;
output = input & 0x7E;

Under the CCI, the value of output after the assignment is 0x72.
Differences
All compilers have performed bitwise operations in an identical fashion to that described in this
section.
Migration to the CCI
No action required.

25.3.11 Right-Shifting Signed Values
Right-shifting a signed value will involve sign extension. This will preserve the sign of the original
value.
Example
The following example shows a negative quantity involved in a right-shift operation.
signed char output, input = -13;
output = input >> 3;

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 240

XC32 Compiler for PIC32M
Common C Interface

Under the CCI, the value of output after the assignment is -2 (that is, the bit pattern 0xFE).
Differences
All compilers have performed right-shifting as described in this section.
Migration to the CCI
No action required.

25.3.12 Conversion of Union Member Accessed Using Member with Different Type
If a union defines several members of different types and you use one member identifier to try to
access the contents of another (whether any conversion is applied to the result) is implementationdefined behavior in the standard. In the CCI, no conversion is applied and the bytes of the union
object are interpreted as an object of the type of the member being accessed, without regard for
alignment or other possible invalid conditions.
Example
The following shows an example of a union defining several members.
union {
signed char code;
unsigned int data;
float offset;
} foobar;

Code that attempts to extract offset by reading data is not guaranteed to read the correct value.
float result;
result = foobbar.data;

Differences
All compilers have not converted union members accessed via other members.
Migration to the CCI
No action required.

25.3.13 Default Bit-field int Type
The type of a bit-field specified as a plain int is identical to that of one defined using unsigned
int. This is quite different from other objects where the types int, signed and signed int are
synonymous. It is recommended that the signedness of the bit-field be explicitly stated in all bit-field
definitions.
Example
The following shows an example of a structure tag containing bit-fields that are unsigned integers
and with the size specified.
struct OUTPUTS {
int direction :1;
int parity
:3;
int value
:4;
};

Differences
When targeting PIC devices, the MPLAB XC8 compiler has issued a warning if an int type was
specified for bit-fields, and it has instead implemented the bit-field with an unsigned int type. For
other devices, this compiler has implemented bit-fields defined using int as having a signed int
type, unless the option -funsigned-bitfields was specified. Use of a signed int type is also
true for the MPLAB XC16, XC-DSC, and XC32 compilers.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 241

XC32 Compiler for PIC32M
Common C Interface

Migration to the CCI
Any code that defines a bit-field with the plain int type should be reviewed. If the intention was
for these to be signed quantities, then the type of these should be changed to signed int. In the
following example:
struct WAYPT {
int log
int direction
};

:3;
:4;

the bit-field type should be changed to signed int, as in:
struct WAYPT {
signed int log
:3;
signed int direction :4;
};

25.3.14 Bit-Fields Straddling a Storage Unit Boundary
The standard indicates that implementations can determine whether bit-fields cross a storage unit
boundary. In the CCI, bit-fields do not straddle a storage unit boundary; a new storage unit is
allocated to the structure, and padding bits fill the gap.
Note that the size of a storage unit differs with each compiler and target device, as this is based on
the size of the base data type (for example, int) from which the bit-field type is derived. For MPLAB
XC8, this unit is 8-bits in size; for MPLAB XC16, it is 16 bits; and for MPLAB XC32, it is 32 bits in size.
For MPLAB XC-DSC compiler, the size depends on the device used.
Example
The following shows a structure containing bit-fields being defined.
struct {

unsigned first : 6;
unsigned second : 6;
} order;

Under the CCI and using MPLAB XC8, the storage allocation unit is byte sized. The bit-field second is
allocated a new storage unit since there are only 2 bits remaining in the first storage unit in which
first is allocated. The size of this structure, order, is 2 bytes.
Differences
This allocation is identical with that used by all previous compilers.
Migration to the CCI
No action required.

25.3.15 The Allocation Order of Bit-Field
The memory ordering of bit-fields into their storage unit is not specified by the C Language
Standard. In the CCI, the first bit defined is the least significant bit (LSb) of the storage unit in
which it is allocated.
Example
The following shows a structure containing bit-fields being defined.
struct {

} foo;

unsigned lo : 1;
unsigned mid :6;
unsigned hi : 1;

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 242

XC32 Compiler for PIC32M
Common C Interface

The bit-field lo is assigned the least significant bit of the storage unit assigned to the structure foo.
The bit-field mid is assigned the next 6 least significant bits, and hi, the most significant bit of that
same storage unit byte.
Differences
This is identical with the previous operation of all compilers.
Migration to the CCI
No action required.

25.3.16 The NULL Macro
The NULL macro is defined by <stddef.h>; however, its definition is implementation-defined.
Under the CCI, the definition of NULL is the expression (0).
Example
The following shows a pointer being assigned a null pointer constant via the NULL macro.
int * ip = NULL;
The value of NULL, (0), is implicitly converted to the destination type.
Differences
MPLAB XC32 has assigned NULL the expression ((void *)0). The same is true for MPLAB XC8
when targeting AVR MCUs.
Migration to the CCI
No action required.

25.3.17 Floating-Point Sizes
Under the CCI, floating-point types must not be smaller than 32 bits in size.
Example
The following shows the definition for outY, which is at least 32-bit in size.
float outY;
Differences
The MPLAB XC8 when targeting PIC MCUs and building with C90 language standard has allowed the
use of 24-bit float and double types.
Migration to the CCI
When using MPLAB XC8, the float and double type will be made 32 bits in size once the CCI is
enabled, regardless of target device or operating mode. Review any source code that assumes a
float or double type is 24 bits in size.
No migration is required for other compilers.

25.4

C Language Standard Extensions

The following topics describe how the CCI provides device-specific extensions to the C Language
Standard.

25.4.1 Generic Header File
A single header file <xc.h> must be used to declare all compiler- and device-specific types and SFRs.
You must include this file into every module to conform with the CCI. Some CCI definitions depend
on this header being seen.
Example

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 243

XC32 Compiler for PIC32M
Common C Interface

The following shows this header file being included, thus allowing conformance with the CCI, as well
as allowing access to SFRs.
#include <xc.h>

Differences
Although device-specific headers are shipped with the compilers, always include the top-level
<xc.h> header.
Early compilers for 8-bit PIC devices used <htc.h> as the equivalent header. Other compilers used
a variety of device-related headers to do the same job.
Migration to the CCI
Change for example:
#include <p32xxxx.h>
#include <p30fxxxx.h>
#include <pic16lf18324.h> /* or */
#include "p30f6014.h"

to:
#include <xc.h>

25.4.2 Absolute Addressing
Variables and functions can be placed at an absolute address by using the __at() construct.
Stack-based (auto and parameter) variables cannot use the __at() specifier.
Example
The following shows two variables and a function being made absolute.
int scanMode __at(0x200);
const char keys[] __at(124) = { ’r’, ’s’, ’u’, ’d’};
__at(0x1000) int modify(int x) {
return x * 2 + 3;
}

Differences
The legacy syntax used by MPLAB XC8 when targeting PIC MCUs has been an @ symbol to specify an
absolute address.
When targeting AVR MCUs, MPLAB XC8 has used the address attribute to specify an object’s
address. This attribute has also been used by the other compilers.
Migration to the CCI
Avoid making objects and functions absolute if possible.
If any source code uses the legacy MPLAB XC8 syntax, for example:
int scanMode @ 0x200;

change this to:
int scanMode __at(0x200);

When building for AVR MCUs with the MPLAB XC8 compiler or when using any other compiler,
change code, for example, from:
int scanMode __attribute__((address(0x200)));

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 244

XC32 Compiler for PIC32M
Common C Interface

to:
int scanMode __at(0x200);

Caveats
If building for PIC device using MPLAB XC8 and the __at() and __section() specifiers have both
been applied to an object, the __section() specifier is currently ignored.
The MPLAB XC32 compiler for PIC32C/SAM devices supports only 4-byte aligned absolute addresses.

25.4.3 Far Objects and Functions
The __far qualifier can be used to indicate that variables or functions are located in ‘far memory’.
Exactly what constitutes far memory is dependent on the target device, but it is typically memory
that requires more complex code to access. Expressions involving far-qualified objects usually
generate slower and larger code.
Use the native keywords discussed in the Differences section to look up information on the
semantics of this qualifier.
Some devices may not have such memory implemented, in which case, use of this qualifier is
ignored. Stack-based (auto and parameter) variables cannot use the __far specifier.
Example
The following shows a variable and function qualified using __far.
__far int serialNo;
__far int ext_getCond(int selector);
Differences
When targeting PIC devices, the MPLAB XC8 compiler has allowed the far specifier to be used with
variables. This specifier has not been allowed with functions. When targeting AVR devices, MPLAB
XC8 has not implemented any “far” memory.
The MPLAB XC16 and XC-DSC compilers have used the far attribute with both variables and
functions.
The MPLAB XC32 compiler has used the far attribute with functions only.
Migration to the CCI
When targeting PIC devices with the MPLAB XC8 compiler, change any occurrence of the far
qualifier to __far, for example, from:
far char template[20];
to:
__far char template[20];
When using MPLAB XC16, XC-DSC or XC32 compilers, change any occurrence of the far attribute to
the __far specifier, for example, from:
void bar(void) __attribute__ ((far));
int tblIdx __attribute__ ((far));
to:
void __far bar(void);
int __far tblIdx;
Caveats

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 245

XC32 Compiler for PIC32M
Common C Interface

None.

25.4.4 Near Objects
The __near qualifier can be used to indicate that variables or functions are located in ‘near
memory’. Exactly what constitutes near memory is dependent on the target device, but it is typically
memory that can be accessed with less complex code. Expressions involving near-qualified objects
generally are faster and result in smaller code.
Use the native keywords discussed in the Differences section to look up information on the
semantics of this qualifier.
Some devices may not have such memory implemented, in which case, use of this qualifier is
ignored. Stack-based (auto and parameter) variables cannot use the __near specifier.
Example
The following shows a variable and function qualified using __near.
__near int serialNo;
__near int ext_getCond(int selector);
Differences
When targeting PIC devices, the MPLAB XC8 compiler has allowed the near specifier to be used with
variables. This specifier has not been allowed with functions. When targeting AVR devices, MPLAB
XC8 has not implemented any “near” memory.
The MPLAB XC16 and XC-DSC compilers have used the near attribute with both variables and
functions.
The MPLAB XC32 compiler has used the near attribute for functions, only.
Migration to the CCI
When targeting PIC devices with the MPLAB XC8 compiler, change any occurrence of the near
qualifier to __near, for example, from:
near char template[20];
to:
__near char template[20];
When using the other compilers, change any occurrence of the near attribute to the __near
specifier, for example, from:
void bar(void) __attribute__ ((near));
int tblIdx __attribute__ ((near));
to
void __near bar(void);
int __near tblIdx;
Caveats
None.

25.4.5 Persistent Objects
The __persistent qualifier can be used to indicate that variables should not be cleared by the
runtime startup code.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 246

XC32 Compiler for PIC32M
Common C Interface

Use the native keywords discussed in the Differences section to look up information on the
semantics of this qualifier.
Example
The following shows a variable qualified using __persistent.
__persistent int serialNo;
Differences
When targeting PIC devices, the MPLAB XC8 compiler has allowed use of the persistent specifier
to indicate that variables should not be cleared at startup. When targeting AVR devices, this compiler
has allowed the use of the persistent attribute with variables to indicate they were not to be
cleared.
The MPLAB XC16, XC-DSC and XC32 compilers have also used the persistent attribute for this
purpose.
Migration to the CCI
When building with the MPLAB XC8 compiler for PIC MCUs, change any occurrence of the
persistent qualifier to __persistent, for example, from:
persistent char template[20];
to:
__persistent char template[20];
When building with MPLAB XC16, XC-DSC or XC32 compilers, or with the MPLAB XC8 compiler for
AVR MCUs, change any occurrence of the persistent attribute to the __persistent specifier, for
example, from:
int tblIdx __attribute__ ((persistent));
to
int __persistent tblIdx;
Caveats
None.

25.4.6 X and Y Data Objects
The __xdata and __ydata qualifiers can be used to indicate that variables are located in special
memory regions. Exactly what constitutes X and Y memory is dependent on the target device, but it
is typically memory that can be accessed independently on separate buses. Such memory is often
required for some DSP instructions.
Use the native keywords discussed in the Differences section to look up information on the
semantics of these qualifiers.
Some devices may not have such memory implemented; in which case, use of these qualifiers is
ignored.
Example
The following shows a variable qualified using __xdata, as well as another variable qualified with
__ydata.
__xdata char data[16];
__ydata char coeffs[4];
Differences

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 247

XC32 Compiler for PIC32M
Common C Interface

The MPLAB XC16 and XC-DSC compilers have used the xmemory and ymemory space attribute with
variables.
Equivalent specifiers have never been defined for any other compiler.
Migration to the CCI
For MPLAB XC16 and XC-DSC compilers, change any occurrence of the space attributes xmemory or
ymemory to __xdata, or __ydata respectively, for example, from:
char __attribute__((space(xmemory)))template[20];
to:
__xdata char template[20];
Caveats
None.

25.4.7 Banked Data Objects
The __bank(num) qualifier can be used to indicate that variables are located in a particular data
memory bank. The number, num, represents the bank number. Exactly what constitutes banked
memory is dependent on the target device, but it is typically a subdivision of data memory to allow
for assembly instructions with a limited address width field.
Use the native keywords discussed in the Differences section to look up information on the
semantics of these qualifiers.
Some devices may not have banked data memory implemented, in which case, use of this qualifier
is ignored. The number of data banks implemented will vary from one device to another.
Example
The following shows a variable qualified using __bank().
__bank(0) char start;
__bank(3) char stop;
Differences
When targeting PIC devices, the MPLAB XC8 compiler has used the four qualifiers bank0, bank1,
bank2 and bank3 to indicate memory placement in a specific data bank.
Equivalent specifiers have never been defined for any other compiler.
Migration to the CCI
When building for PIC devices using MPLAB XC8, change any occurrence of the banknum qualifiers to
__bank(num), for example, from:
bank2 int logEntry;
to:
__bank(2) int logEntry;
Caveats
Only banks 0 through 3 are currently supported.

25.4.8 Alignment of Objects
The __align(alignment) specifier can be used to indicate that variables must be aligned on a
memory address that is a multiple of the alignment specified. The alignment term must be a power
of 2. Positive values request that the object’s start address be aligned.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 248

XC32 Compiler for PIC32M
Common C Interface

Use the native keywords discussed in the Differences section to look up information on the
semantics of this specifier.
Example
The following shows variables qualified using __align() to ensure they end on an address that is a
multiple of 8, and start on an address that is a multiple of 2, respectively.
__align(-8) int spacer;
__align(2) char coeffs[6];

Differences
The MPLAB XC16, XC-DSC and XC32 compilers have used the aligned attribute with variables. This
has also been true when targeting AVR MCUs with MPLAB XC8 An alignment feature has never been
available for PIC devices when using the MPLAB XC8 compiler.
Migration to the CCI
When building for AVR MCUs with the MPLAB XC8 compiler or when using any other compiler,
change any occurrence of the aligned attribute to the __align specifier, for example, from:
char __attribute__((aligned(4)))mode;
to:
__align(4) char mode;
Caveats
This feature is not needed nor implemented when targeting PIC devices using MPLAB XC8.
When targeting PIC32C/SAM devices with MPLAB XC32 only positive alignment values are supported.

25.4.9 EEPROM Objects
The __eeprom qualifier can be used to indicate that variables should be positioned in EEPROM.
Use the native keywords discussed in the Differences section to look up information on the
semantics of this qualifier.
Some devices may not implement EEPROM. Use of this qualifier for such devices generates a
warning. Stack-based (auto and parameter) variables cannot use the __eeprom specifier.
Example
The following shows a variable qualified using __eeprom.
__eeprom int serialNos[4];
Differences
When targeting PIC devices, the MPLAB XC8 compiler has used the eeprom qualifier to indicate that
objects should be placed in EEPROM.
The MPLAB XC16 and XC-DSC compilers have used the space attribute to allocate variables to the
memory space used for EEPROM.
Migration to the CCI
When using MPLAB XC8 to build for PIC devices, change any occurrence of the eeprom qualifier to
__eeprom, for example, from:
eeprom char title[20];
to:
__eeprom char title[20];

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 249

XC32 Compiler for PIC32M
Common C Interface

When using MPLAB XC16 or XC-DSC compilers, change any occurrence of the eedata space
attribute to the __eeprom specifier, for example, from:
int mainSw __attribute__ ((space(eedata)));
to:
int __eeprom mainSw;
Caveats
The MPLAB XC8 compiler only permits the __eeprom specifier for those Baseline and Mid-range
devices that support this memory. It is not permitted for other 8-bit devices.

25.4.10 Interrupt Functions

The __interrupt(type) specifier can be used to indicate that a function is to act as an interrupt
service routine. The type is a comma-separated list of keywords that indicate information about the
interrupt function.
The current interrupt types are shown in the following table.
Interrupt type

Description

<empty>

Implement the default interrupt function.

Compiler

low_priority

The interrupt function corresponds to the low priority interrupt
source.

MPLAB XC8 - PIC18 only

high_priority

The interrupt function corresponds to the high priority interrupt
source.

MPLAB XC8

save(symbol-list) Save on entry and restore on exit the listed symbols.

MPLAB XC16, MPLAB XC-DSC

irq(irqid)

Specify the interrupt vector associated with this interrupt.

MPLAB XC8, MPLAB XC16, MPLAB
XC-DSC

altirq(altirqid)

Specify the alternate interrupt vector associated with this
interrupt.

MPLAB XC16, MPLAB XC-DSC

preprologue(asm)

Specify assembly code to be executed before any compilergenerated interrupt code.

MPLAB XC16, MPLAB XC-DSC

shadow

Allow the ISR to utilize the shadow registers for context
switching.

MPLAB XC16, MPLAB XC-DSC

auto_psv

The ISR will set the PSVPAG register and restore it on exit.

MPLAB XC16, MPLAB XC-DSC

no_auto_psv

The ISR will not set the PSVPAG register.

MPLAB XC16, MPLAB XC-DSC

Use the native keywords discussed in the Differences section to look up information on the
semantics of this specifier.
Some devices may not implement interrupts. Use of this qualifier for such devices generates a
warning. If the argument to the __interrupt() specifier does not make sense for the target
device, a warning or error is issued by the compiler.
Example
The following shows a function qualified using __interrupt for an 8-bit PIC device.
__interrupt(low_priority) void getData(void) {
if (TMR0IE && TMR0IF) {
TMR0IF=0;
++tick_count;
}
}

Differences
The legacy interrupt function syntax used by MPLAB XC8 when targeting PIC MCUs has been the
interrupt specifier and optionally the low_priority specifier. When targeting AVR devices, the
MPLAB XC8 compiler has used the ISR() macro to define interrupt functions.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 250

XC32 Compiler for PIC32M
Common C Interface

The MPLAB XC16, XC-DSC, and XC32 compilers have used the interrupt attribute to define
interrupt functions.
Migration to the CCI
When building with the MPLAB XC8 compiler for PIC MCUs, change any instance of the interrupt
specifier to __interrupt, for example, from:
void interrupt low_priority tckI(void)

to:
void __interrupt(low_priority) tckI(void)

When building with the MPLAB XC8 compiler for AVR MCUs, change any instance of the ISR()
macro, for example, from:
ISR(TIMER1_OVF_vect)

to:
void __interrupt(TIMER1_OVF_vect_num) spi_Isr(void)

When building with XC16 or XC-DSC compilers, change any occurrence of the interrupt attribute,
for example, from:
void _attribute_((interrupt(auto_psv,irq(52)))) _T1Interrupt(void);

to:
void __interrupt(auto_psv,irq(52))) _T1Interrupt(void);

For MPLAB XC32, the __interrupt() keyword takes two parameters, the vector number and the
(optional) IPL value. Change code that uses the interrupt attribute, similar to these examples:
void __attribute__((vector(0), interrupt(IPL7AUTO), nomips16)) myisr0_7A(void) {}
void __attribute__((vector(1), interrupt(IPL6SRS), nomips16)) myisr1_6SRS(void) {}
/* Determine IPL and context-saving mode at runtime */
void __attribute__((vector(2), interrupt(), nomips16)) myisr2_RUNTIME(void) {}

to:
void __interrupt(0,IPL7AUTO) myisr0_7A(void) {}
void __interrupt(1,IPL6SRS) myisr1_6SRS(void) {}
/* Determine IPL and context-saving mode at runtime */
void __interrupt(2) myisr2_RUNTIME(void) {}

Caveats
None.

25.4.11 Packing Objects
The __pack specifier can be used to indicate that structures should not use memory gaps to align
structure members, or that individual structure members should not be aligned.
Use the native keywords discussed in the Differences section to look up information on the
semantics of this specifier.
Some compilers cannot pad structures with alignment gaps for some devices, and use of this
specifier for such devices is ignored.
Example

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 251

XC32 Compiler for PIC32M
Common C Interface

The following shows a structure qualified using __pack, as well as a structure where one member
has been explicitly packed.
struct DATAPOINT {
unsigned char type;
int value;
} __pack x_point;
struct LINETYPE {
unsigned char type;
__pack int start;
long total;
} line;

Differences
The __pack specifier is a new CCI specifier that can be used with PIC devices and MPLAB XC8. This
specifier has no observable effect since the device memory is byte addressable for all data objects.
When targeting AVR devices, the MPLAB XC8 compiler has used the packed attribute.
The MPLAB XC16, XC-DSC, and XC32 compilers have used the packed attribute to indicate that a
structure member was not aligned with a memory gap.
Migration to the CCI
No migration is required for the MPLAB XC8 compiler when building for PIC MCUs. When building
for AVR MCUs or when building with any other compiler, change any occurrence of the packed
attribute to the __packed specifier, for example, from:
struct DOT
{
char a;
int x[2] __attribute__ ((packed));
};

to
struct DOT
{
char a;
__pack int x[2];
};

Alternatively, you can pack the entire structure, if required.
Caveats
None.

25.4.12 Indicating Antiquated Objects
The __deprecate specifier can be used to indicate that an object has limited longevity and should
not be used in new designs. It is commonly used by the compiler vendor to indicate that compiler
extensions or features can become obsolete, or that better features have been developed and
should be used in preference.
Use the native keywords discussed in the Differences section to look up information on the
semantics of this specifier.
Example
The following shows a function that uses the __deprecate keyword.
void __deprecate getValue(int mode)
{
//...
}

Differences

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 252

XC32 Compiler for PIC32M
Common C Interface

When targeting AVR MCUs using the MPLAB XC8 compiler or when using the other compilers, the
deprecated attribute (note the different spelling to the CCI specifier) has been used to indicate that
use of certain objects should be avoided, if possible.
Migration to the CCI
When building with MPLAB XC16, XC-DSC or XC32 compilers, or with the MPLAB XC8 compiler for
AVR MCUs, change any occurrence of the deprecated attribute to __deprecate, for example,
from:
int __attribute__(deprecated) intMask;
to:
int __deprecate intMask;
Caveats
None.

25.4.13 Assigning Objects to Sections
The __section() specifier can be used to indicate that an object should be located in the named
section. This is typically used when the object has special and unique linking requirements that
cannot be addressed by existing compiler features.
Use the native keywords discussed in the Differences section to look up information on the
semantics of this specifier.
Example
The following shows a variable which uses the __section keyword.
int __section("comSec") commonFlag;
Differences
When targeting AVR MCUs using the MPLAB XC8 compiler or when using the other compilers,
the section attribute has been used to indicate a different destination section name. The
__section() specifier works in a similar way to the attribute.
Migration to the CCI
When building with MPLAB XC16, XC-DSC or XC32 compilers, or with the MPLAB XC8 compiler for
AVR MCUs, change any occurrence of the section attribute, for example, from:
int __attribute__((section("myVars"))) intMask;

to:
int __section("myVars") intMask;

Caveats
None.

25.4.14 Specifying Configuration Bits
The #pragma config directive can be used to program the Configuration bits for a device. The
pragma has the form:
#pragma config setting = state|value
where setting is a configuration setting descriptor (for example, WDT), state is a descriptive value
(for example, ON) and value is a numerical value.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 253

XC32 Compiler for PIC32M
Common C Interface

Use the native keywords discussed in the Differences section to look up information on the
semantics of this directive.
Example
The following shows Configuration bits being specified using this pragma.
#pragma config WDT=ON, WDTPS = 0x1A
Differences
When targeting PIC MCUs, MPLAB XC8 has provided a legacy __CONFIG() macro, but more recently
has accepted #pragma config. When targeting AVR devices, it has used a predefined FUSES
structure to allow the configuration bits to be specified.
The MPLAB XC16 and XC-DSC compilers have used a number of macros to specify the configuration
settings.
The MPLAB XC32 compiler has supported the use of #pragma config.
Migration to the CCI
When building for PIC MCUs with MPLAB XC8, change any occurrence of the __CONFIG() macro, for
example,
__CONFIG(WDTEN & XT & DPROT)
to the #pragma config directive, for example:
#pragma config WDTE=ON, FOSC=XT, CPD=ON
When building for AVR MCUs with MPLAB XC8, change any occurrence of the FUSES structure, for
example:
#include <avr/io.h>
FUSES = {
.high = (FUSE_SPIEN)
};

to:
#pragma config SPIEN=SET

For the MPLAB XC16 and XC-DSC compilers, change any occurrence of the _FOSC() or _FBORPOR()
macros attribute, for example, from:
_FOSC(CSW_FSCM_ON & EC_PLL16);
to:
#pragma config FCKSMEM = CSW_ON_FSCM_ON, FPR = ECIO_PLL16
No migration is required for 32-bit code.
Caveats
None.

25.4.15 Manifest Macros
The CCI defines the general form for macros that manifest the compiler and target device
characteristics. These macros can be used to conditionally compile alternate source code based
on the compiler or the target device.
The macros and macro families are details in the following table.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 254

XC32 Compiler for PIC32M
Common C Interface

Table 25-1. Manifest Macros Defined by the CCI
Name

Meaning if defined

Example

__XC__

Compiled with an MPLAB XC compiler

__XC__

__CCI__

Compiler is CCI compliant and CCI enforcement is
enabled

__CCI__

__XC#__

The specific XC compiler used (# can be 8, 16, _DSC
or 32)

__XC32__

__DEVICEFAMILY__

The family of the selected target device

__dsPIC30F__

__DEVICENAME__

The selected target device name

__33ck256mp508__

Example
The following shows code that is conditionally compiled dependent on the device having EEPROM
memory.
#ifdef __XC_DSC__
void __interrupt(__auto_psv__) myIsr(void)
#else
void __interrupt(low_priority) myIsr(void)
#endif

Differences
Some of these CCI macros are new (for example, __CCI__), and others have different
names to previous symbols with identical meaning (for example, __33ck256mp508 is now
__33ck256mp508__).
Migration to the CCI
Any code that uses compiler-defined macros needs review. Old macros continue to work as
expected, but they are not compliant with the CCI.
Caveats
None.

25.4.16 In-Line Assembly
The asm() statement can be used to insert assembly code in-line with C code. The argument is a C
string literal that represents a single assembly instruction. Obviously, the instructions contained in
the argument are device specific.
Use the native keywords discussed in the Differences section to look up information on the
semantics of this statement.
Example
The following shows a MOVLW 8-bit PIC MCU instruction being inserted in-line.
asm("MOVLW _foobar");

Differences
When targeting PIC devices with MPLAB XC8, the asm() or #asm ... #endasm constructs have
been used to insert in-line assembly code.
The MPLAB XC16, XC-DSC and XC32 compilers, as well as the MPLAB XC8 compiler for AVR MCUs use
the same syntax as the CCI.
Migration to the CCI

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 255

XC32 Compiler for PIC32M
Common C Interface

When building with the MPLAB XC8 compiler for PIC MCUs, change any instance of #asm ...
#endasm so that each instruction in this #asm block is placed in its own asm() statement, for
example, from:
#asm

MOVLW
MOVWF _i
CLRF
#endasm

20
Ii+1

to:
asm("MOVLW
20");
asm("MOVWF _i");
asm("CLRF
Ii+1");

No migration is required for MPLAB XC8 when targeting AVR MCUs or when using the other
compilers.
Caveats
None.

25.5

Compiler Features
The following item details the compiler options used to control the CCI.

25.5.1 Enabling the CCI
It is assumed that you are using the MPLAB X IDE to build projects that use the CCI. The location of
the widget in the Project Properties window to enable CCI conformance is shown in the table below.
Table 25-2. Project Property Path to Enable CCI
Compiler

Category

Category Option

MPLAB XC8

XC8 Compiler

Preprocessing and messages > Use CCI
Syntax

MPLAB XC16

xc16-gcc

Preprocessing and messages > Use CCI
Syntax

MPLAB XC-DSC

xc-dsc-gcc

Preprocessing and messages > Use CCI
Syntax

MPLAB XC32

xc32-gcc, xc32-g++

Preprocessing and messages > Use CCI
Syntax

If you are not using this IDE, use the command-line option -mext=cci. For MPLAB XC16, MPLAB
XC-DSC and MPLAB XC32, you may also use the option -mcci.
Differences
This option has never been implemented previously.
Migration to the CCI
Enable the option.
Caveats
None.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 256

XC32 Compiler for PIC32M
C Implementation-Defined Behavior

26.

C Implementation-Defined Behavior
This section discusses the choices for implementation-defined behavior when using the C compiler.

26.1

Overview
ISO C requires a conforming implementation to document the choices for behaviors defined in the
standard as “implementation-defined.” The following sections list all such areas, the choices made
for the compiler, and the corresponding section number from the ISO/IEC 9899:1999 standard.

26.2

26.3

26.4

Translation
ISO Standard:

“How a diagnostic is identified (3.10, 5.1.1.3).”

Implementation:

All output to stderr is a diagnostic.

ISO Standard:

“Whether each nonempty sequence of white-space characters other than new-line is
retained or replaced by one space character in translation phase 3 (5.1.1.2).”

Implementation:

Each sequence of whitespace is replaced by a single character.

Environment
ISO Standard:

“The name and type of the function called at program start-up in a freestanding
environment (5.1.2.1).”

Implementation:

int main (void);

ISO Standard:

“The effect of program termination in a freestanding environment (5.1.2.1).”

Implementation:

An infinite loop (branch to self) instruction will be executed.

ISO Standard:

“An alternative manner in which the main function may be defined (5.1.2.2.1).”

Implementation:

int main (void);

ISO Standard:

“The values given to the strings pointed to by the argv argument to main (5.1.2.2.1).”

Implementation:

No arguments are passed to main. Reference to argc or argv is undefined.

ISO Standard:

“What constitutes an interactive device (5.1.2.3).”

Implementation:

Application defined.

ISO Standard:

“Signals for which the equivalent of signal(sig, SIG_IGN); is executed at
program start-up (7.14.1.1).”

Implementation:

Signals are application defined.

ISO Standard:

“The form of the status returned to the host environment to indicate unsuccessful
termination when the SIGABRT signal is raised and not caught (7.20.4.1).”

Implementation:

The host environment is application defined.

ISO Standard:

“The forms of the status returned to the host environment by the exit function to
report successful and unsuccessful termination (7.20.4.3).”

Implementation:

The host environment is application defined.

ISO Standard:

“The status returned to the host environment by the exit function if the value of its
argument is other than zero, EXIT_SUCCESS, or EXIT_FAILURE (7.20.4.3).”

Implementation:

The host environment is application defined.

ISO Standard:

“The set of environment names and the method for altering the environment list
used by the getenv function (7.20.4.4).”

Implementation:

The host environment is application defined.

ISO Standard:

“The manner of execution of the string by the system function (7.20.4.5).”

Implementation:

The host environment is application defined.

Identifiers
ISO Standard:

“Which additional multibyte characters may appear in identifiers and their
correspondence to universal character names (6.4.2).”

Implementation:

No.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 257

XC32 Compiler for PIC32M
C Implementation-Defined Behavior

26.5

26.6

ISO Standard:

“The number of significant initial characters in an identifier (5.2.4.1, 6.4.2).”

Implementation:

All characters are significant.

Characters
ISO Standard:

“The number of bits in a byte (C90 3.4, C99 3.6).”

Implementation:

8.

ISO Standard:

“The values of the members of the execution character set (C90 and C99 5.2.1).”

ISO Standard:

“The unique value of the member of the execution character set produced for each
of the standard alphabetic escape sequences (C90 and C99 5.2.2).”

Implementation:

The execution character set is ASCII.

ISO Standard:

“The value of a char object into which has been stored any character other than a
member of the basic execution character set (C90 6.1.2.5, C99 6.2.5).”

Implementation:

The value of the char object is the 8-bit binary representation of the character in the
source character set. That is, no translation is done.

ISO Standard:

“Which of signed char or unsigned char has the same range, representation, and
behavior as “plain” char (C90 6.1.2.5, C90 6.2.1.1, C99 6.2.5, C99 6.3.1.1).”

Implementation:

By default on PIC32M, signed char is functionally equivalent to plain char.

ISO Standard:

“The mapping of members of the source character set (in character constants and
string literals) to members of the execution character set (C90 6.1.3.4, C99 6.4.4.4,
C90 and C99 5.1.1.2).”

Implementation:

The binary representation of the source character set is preserved to the execution
character set.

ISO Standard:

“The value of an integer character constant containing more than one character
or containing a character or escape sequence that does not map to a single-byte
execution character (C90 6.1.3.4, C99 6.4.4.4).”

Implementation:

The compiler determines the value for a multi-character character constant one
character at a time. The previous value is shifted left by eight, and the bit pattern of
the next character is masked in. The final result is of type int. If the result is larger
than can be represented by an int, a warning diagnostic is issued and the value
truncated to int size.

ISO Standard:

“The value of a wide character constant containing more than one multibyte
character, or containing a multibyte character or escape sequence not represented
in the extended execution character set (C90 6.1.3.4, C99 6.4.4.4).”

Implementation:

See previous.

ISO Standard:

“The current locale used to convert a wide character constant consisting of a single
multibyte character that maps to a member of the extended execution character set
into a corresponding wide character code (C90 6.1.3.4, C99 6.4.4.4).”

Implementation:

LC_ALL

ISO Standard:

“The current locale used to convert a wide string literal into corresponding wide
character codes (C90 6.1.4, C99 6.4.5).”

Implementation:

LC_ALL

ISO Standard:

“The value of a string literal containing a multibyte character or escape sequence not
represented in the execution character set (C90 6.1.4, C99 6.4.5).”

Implementation:

The binary representation of the characters is preserved from the source character
set.

Integers
ISO Standard:

“Any extended integer types that exist in the implementation (C99 6.2.5).”

Implementation:

There are no extended integer types.

ISO Standard:

“Whether signed integer types are represented using sign and magnitude, two’s
complement, or one’s complement and whether the extraordinary value is a trap
representation or an ordinary value (C99 6.2.6.2).”

Implementation:

All integer types are represented as two’s complement, and all bit patterns are
ordinary values.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 258

XC32 Compiler for PIC32M
C Implementation-Defined Behavior

26.7

26.8

Floating-Point
ISO Standard:

“The accuracy of the floating-point operations and of the library functions in
<math.h> and <complex.h> that return floating-point results (C90 and C99 5.2.4.2.2).”

Implementation:

The accuracy is unknown.

ISO Standard:

“The accuracy of the conversions between floating-point internal representations and
string representations performed by the library functions in <stdio.h>, <stdlib.h>,
and <wchar.h> (C90 and C99 5.2.4.2.2).”

Implementation:

The accuracy is unknown.

ISO Standard:

“The rounding behaviors characterized by non-standard values of FLT_ROUNDS (C90
and C99 5.2.4.2.2).”

Implementation:

No such values are used.

ISO Standard:

“The evaluation methods characterized by non-standard negative values of
FLT_EVAL_METHOD (C90 and C99 5.2.4.2.2).”

Implementation:

No such values are used.

ISO Standard:

“The direction of rounding when an integer is converted to a floating-point number
that cannot exactly represent the original value (C90 6.2.1.3, C99 6.3.1.4).”

Implementation:

C99 Annex F is followed.

ISO Standard:

“The direction of rounding when a floating-point number is converted to a narrower
floating-point number (C90 6.2.1.4, 6.3.1.5).”

Implementation:

C99 Annex F is followed.

ISO Standard:

“How the nearest representable value or the larger or smaller representable value
immediately adjacent to the nearest representable value is chosen for certain
floating constants (C90 6.1.3.1, C99 6.4.4.2).”

Implementation:

C99 Annex F is followed.

ISO Standard:

“Whether and how floating expressions are contracted when not disallowed by the
FP_CONTRACT pragma (C99 6.5).”

Implementation:

The pragma is not implemented.

ISO Standard:

“The default state for the FENV_ACCESS pragma (C99 7.6.1).”

Implementation:

This pragma is not implemented.

ISO Standard:

“Additional floating-point exceptions, rounding modes, environments, and
classifications, and their macro names (C99 7.6, 7.12).”

Implementation:

None supported.

ISO Standard:

“The default state for the FP_CONTRACT pragma (C99 7.12.2).”

Implementation:

This pragma is not implemented.

ISO Standard:

“Whether the “inexact” floating-point exception can be raised when the rounded
result actually does equal the mathematical result in an IEC 60559 conformant
implementation (C99 F.9).”

Implementation:

Unknown.

ISO Standard:

“Whether the “underflow” (and “inexact”) floating-point exception can be raised when
a result is tiny but not inexact in an IEC 60559 conformant implementation (C99 F.9).”

Implementation:

Unknown.

Arrays and Pointers
ISO Standard:

“The result of converting a pointer to an integer or vice versa (C90 6.3.4, C99 6.3.2.3).”

Implementation:

A cast from an integer to a pointer or vice versa results uses the binary representation
of the source type, reinterpreted as appropriate for the destination type. If the source
type is larger than the destination type, the Most Significant bits are discarded. When
casting from a pointer to an integer, if the source type is smaller than the destination
type, the result is sign extended. When casting from an integer to a pointer, if the
source type is smaller than the destination type, the result is extended based on the
signedness of the source type.

ISO Standard:

“The size of the result of subtracting two pointers to elements of the same array (C90
6.3.6, C99 6.5.6).”

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 259

XC32 Compiler for PIC32M
C Implementation-Defined Behavior
Implementation:

26.9

32-bit signed integer.

Hints
ISO Standard:

“The extent to which suggestions made by using the register storage-class specifier are
effective (C90 6.5.1, C99 6.7.1).”

Implementation:

The register storage class specifier generally has no effect.

ISO Standard:

“The extent to which suggestions made by using the inline function specifier are
effective (C99 6.7.4).”

Implementation:

If -fno-inline or -O0 are specified, no functions will be inlined, even if specified with
the inline specifier. Otherwise, the function may or may not be inlined dependent on
the optimization heuristics of the compiler.

26.10 Structures, Unions, Enumerations, and Bit Fields
ISO Standard:

“A member of a union object is accessed using a member of a different type (C90
6.3.2.3).”

Implementation:

The corresponding bytes of the union object are interpreted as an object of the type
of the member being accessed without regard for alignment or other possible invalid
conditions.

ISO Standard:

“Whether a “plain” int bit field is treated as a signed int bit field or as an
unsigned int bit field (C90 6.5.2, C90 6.5.2.1, C99 6.7.2, C99 6.7.2.1).”

Implementation:

By default on PIC32M, a plain int bit field is treated as a signed integer. This
behavior can be altered by use of the -funsigned-bitfields command line
option.

ISO Standard:

“Allowable bit field types other than _Bool, signed int, and unsigned int (C99
6.7.2.1).”

Implementation:

No other types are supported.

ISO Standard:

“Whether a bit field can straddle a storage unit boundary (C90 6.5.2.1, C99 6.7.2.1).”

Implementation:

No.

ISO Standard:

“The order of allocation of bit fields within a unit (C90 6.5.2.1, C99 6.7.2.1).”

Implementation:

Bit fields are allocated left to right.

ISO Standard:

“The alignment of non-bit field members of structures (C90 6.5.2.1, C99 6.7.2.1).”

Implementation:

Each member is located to the lowest available offset allowable according to the
alignment restrictions of the member type.

ISO Standard:

“The integer type compatible with each enumerated type (C90 6.5.2.2, C99 6.7.2.2).”

Implementation:

If the enumeration values are all non-negative, the type is unsigned int, else it is
int. The -fshort-enums command line option can change this.

26.11 Qualifiers
ISO Standard:

“What constitutes an access to an object that has volatile-qualified type (C90 6.5.3,
C99 6.7.3).”

Implementation:

Any expression which uses the value of or stores a value to a volatile object is
considered an access to that object. There is no guarantee that such an access is
atomic.If an expression contains a reference to a volatile object but neither uses the
value nor stores to the object, the expression is considered an access to the volatile
object or not depending on the type of the object. If the object is of scalar type,
an aggregate type with a single member of scalar type, or a union with members
of (only) scalar type, the expression is considered an access to the volatile object.
Otherwise, the expression is evaluated for its side effects but is not considered an
access to the volatile object. For example:
volatile int a;
a; /* access to ‘a’ since ‘a’ is scalar */

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 260

XC32 Compiler for PIC32M
C Implementation-Defined Behavior

26.12 Declarators
ISO Standard:

“The maximum number of declarators that may modify an arithmetic, structure or
union type (C90 6.5.4).”

Implementation:

No limit.

26.13 Statements
ISO Standard:

“The maximum number of case values in a switch statement (C90 6.6.4.2).”

Implementation:

No limit.

26.14 Pre-Processing Directives
ISO Standard:

“How sequences in both forms of header names are mapped to headers or external
source file names (C90 6.1.7, C99 6.4.7).”

Implementation:

The character sequence between the delimiters is considered to be a string which is
a file name for the host environment.

ISO Standard:

“Whether the value of a character constant in a constant expression that controls
conditional inclusion matches the value of the same character constant in the
execution character set (C90 6.8.1, C99 6.10.1).”

Implementation:

Yes.

ISO Standard:

“Whether the value of a single-character character constant in a constant
expression that controls conditional inclusion may have a negative value (C90 6.8.1,
C99 6.10.1).”

Implementation:

Yes.

ISO Standard:

“The places that are searched for an included < > delimited header, and how the
places are specified or the header is identified (C90 6.8.2, C99 6.10.2).”

Implementation:

<install directory>/lib/gcc/pic32mx/3.4.4/include<install
directory>/pic32mx/include

ISO Standard:

“How the named source file is searched for in an included "" delimited header (C90
6.8.2, C99 6.10.2).”

Implementation:

The compiler first searches for the named file in the directory containing the
including file, the directories specified by the -iquote command line option (if any),
then the directories which are searched for a < > delimited header.

ISO Standard:

“The method by which preprocessing tokens are combined into a header name (C90
6.8.2, C99 6.10.2).”

Implementation:

All tokens, including whitespace, are considered part of the header file name. Macro
expansion is not performed on tokens inside the delimiters.

ISO Standard:

“The nesting limit for #include processing (C90 6.8.2, C99 6.10.2).”

Implementation:

No limit.

ISO Standard:

“The behavior on each recognized non-STDC #pragma directive (C90 6.8.6, C99
6.10.6).”

Implementation:

See 9.11. Variable Attributes.

ISO Standard:

“The definitions for __DATE_ _ and __TIME_ _ when respectively, the date and time
of translation are not available (C90 6.8.8, C99 6.10.8).”

Implementation:

The date and time of translation are always available.

26.15 Library Functions
ISO Standard:

“The Null Pointer constant to which the macro NULL expands (C90 7.1.6, C99 7.17).”

Implementation:

(void *)0

ISO Standard:

“Any library facilities available to a freestanding program, other than the minimal set
required by clause 4 (5.1.2.1).”

Implementation:

See the 32-Bit Language Tools Libraries (DS51685).

ISO Standard:

“The format of the diagnostic printed by the assert macro (7.2.1.1).”

Implementation:

“Failed assertion ‘message’ at line line of ‘filename’.\n”

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 261

XC32 Compiler for PIC32M
C Implementation-Defined Behavior
ISO Standard:

“The default state for the FENV_ACCESS pragma (7.6.1).”

Implementation:

Unimplemented.

ISO Standard:

“The representation of floating-point exception flags stored by the
fegetexceptflag function (7.6.2.2).”

Implementation:

Unimplemented.

ISO Standard:

“Whether the feraiseexcept function raises the inexact exception in addition to
the overflow or underflow exception (7.6.2.3).”

Implementation:

Unimplemented.

ISO Standard:

“Floating environment macros other than FE_DFL_ENV that can be used as the
argument to the fesetenv or feupdateenv function (7.6.4.3, 7.6.4.4).”

Implementation:

Unimplemented.

ISO Standard:

“Strings other than "C" and "" that may be passed as the second argument to the
setlocale function (7.11.1.1).”

Implementation:

None.

ISO Standard:

“The types defined for float_t and double_t when the value of the
FLT_EVAL_METHOD macro is less than 0 or greater than 2 (7.12).”

Implementation:

Unimplemented.

ISO Standard:

“The infinity to which the INFINITY macro expands, if any (7.12).”

Implementation:

Unimplemented.

ISO Standard:

“The quiet NaN to which the NAN macro expands, when it is defined (7.12).”

Implementation:

Unimplemented.

ISO Standard:

“Domain errors for the mathematics functions, other than those required by this
International Standard (7.12.1).”

Implementation:

None.

ISO Standard:

“The values returned by the mathematics functions, and whether errno is set to the
value of the macro EDOM, on domain errors (7.12.1).”

Implementation:

errno is set to EDOM on domain errors.

ISO Standard:

“Whether the mathematics functions set errno to the value of the macro ERANGE on
overflow and/or underflow range errors (7.12.1).”

Implementation:

Yes.

ISO Standard:

“The default state for the FP_CONTRACT pragma (7.12.2)

Implementation:

Unimplemented.

ISO Standard:

“Whether a domain error occurs or zero is returned when the fmod function has a
second argument of zero (7.12.10.1).”

Implementation:

NaN is returned.

ISO Standard:

“The base-2 logarithm of the modulus used by the remquo function in reducing the
quotient (7.12.10.3).”

Implementation:

Unimplemented.

ISO Standard:

“The set of signals, their semantics, and their default handling (7.14).”

Implementation:

The default handling of signals is to always return failure. Actual signal handling is
application defined.

ISO Standard:

“If the equivalent of signal(sig, SIG_DFL); is not executed prior to the call of a
signal handler, the blocking of the signal that is performed (7.14.1.1).”

Implementation:

Application defined.

ISO Standard:

“Whether the equivalent of signal(sig, SIG_DFL); is executed prior to the call of
a signal handler for the signal SIGILL (7.14.1.1).”

Implementation:

Application defined.

ISO Standard:

“Signal values other than SIGFPE, SIGILL, and SIGSEGV that correspond to a
computational exception (7.14.1.1).”

Implementation:

Application defined.

ISO Standard:

“Whether the last line of a text stream requires a terminating new-line character
(7.19.2).”

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 262

XC32 Compiler for PIC32M
C Implementation-Defined Behavior
Implementation:

Yes.

ISO Standard:

“Whether space characters that are written out to a text stream immediately before a
new-line character appear when read in (7.19.2).”

Implementation:

Yes.

ISO Standard:

“The number of null characters that may be appended to data written to a binary
stream (7.19.2).”

Implementation:

No null characters are appended to a binary stream.

ISO Standard:

“Whether the file position indicator of an append-mode stream is initially positioned
at the beginning or end of the file (7.19.3).”

Implementation:

Application defined. The system level function open is called with the O_APPEND flag.

ISO Standard:

“Whether a write on a text stream causes the associated file to be truncated beyond
that point (7.19.3).”

Implementation:

Application defined.

ISO Standard:

“The characteristics of file buffering (7.19.3).”

ISO Standard:

“Whether a zero-length file actually exists (7.19.3).”

Implementation:

Application defined.

ISO Standard:

“The rules for composing valid file names (7.19.3).”

Implementation:

Application defined.

ISO Standard:

“Whether the same file can be open multiple times (7.19.3).”

Implementation:

Application defined.

ISO Standard:

“The nature and choice of encodings used for multibyte characters in files (7.19.3).”

Implementation:

Encodings are the same for each file.

ISO Standard:

“The effect of the remove function on an open file (7.19.4.1).”

Implementation:

Application defined. The system function unlink is called.

ISO Standard:

“The effect if a file with the new name exists prior to a call to the rename function
(7.19.4.2).”

Implementation:

Application defined. The system function link is called to create the new file name,
then unlink is called to remove the old file name. Typically, link will fail if the new
file name already exists.

ISO Standard:

“Whether an open temporary file is removed upon abnormal program termination
(7.19.4.3).”

Implementation:

No.

ISO Standard:

“What happens when the tmpnam function is called more than TMP_MAX times
(7.19.4.4).”

Implementation:

Temporary names will wrap around and be reused.

ISO Standard:

“Which changes of mode are permitted (if any), and under what circumstances
(7.19.5.4).”

Implementation:

The file is closed via the system level close function and re-opened with the
open function with the new mode. No additional restriction beyond those of the
application defined open and close functions are imposed.

ISO Standard:

“The style used to print an infinity or NaN, and the meaning of the n-char-sequence if
that style is printed for a NaN (7.19.6.1, 7.24.2.1).”

Implementation:

No char sequence is printed.NaN is printed as "NaN".Infinity is printed as "[-/+]Inf".

ISO Standard:

“The output for %p conversion in the fprintf or fwprintf function (7.19.6.1,
7.24.2.1).”

Implementation:

Functionally equivalent to %x.

ISO Standard:

“The interpretation of a - character that is neither the first nor the last character, nor
the second where a ^ character is the first, in the scanlist for %[ conversion in the
fscanf or fwscanf function (7.19.6.2, 7.24.2.1).”

Implementation:

Unknown

ISO Standard:

“The set of sequences matched by the %p conversion in the fscanf or fwscanf
function (7.19.6.2, 7.24.2.2).”

Implementation:

The same set of sequences matched by %x.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 263

XC32 Compiler for PIC32M
C Implementation-Defined Behavior
ISO Standard:

“The interpretation of the input item corresponding to a %p conversion in the fscanf
or fwscanf function (7.19.6.2, 7.24.2.2).”

Implementation:

If the result is not a valid pointer, the behavior is undefined.

ISO Standard:

“The value to which the macro errno is set by the fgetpos, fsetpos, or ftell
functions on failure (7.19.9.1, 7.19.9.3, 7.19.9.4).”

Implementation:

If the result exceeds LONG_MAX, errno is set to ERANGE.Other errors are application
defined according to the application definition of the lseek function.

ISO Standard:

“The meaning of the n-char-sequence in a string converted by the strtod, strtof,
strtold, wcstod, wcstof, or wcstold function (7.20.1.3, 7.24.4.1.1).”

Implementation:

No meaning is attached to the sequence.

ISO Standard:

“Whether or not the strtod, strtof, strtold, wcstod, wcstof, or wcstold
function sets errno to ERANGE when underflow occurs (7.20.1.3, 7.24.4.1.1).”

Implementation:

Yes.

ISO Standard:

“Whether the calloc, malloc, and realloc functions return a Null Pointer or a
pointer to an allocated object when the size requested is zero (7.20.3).”

Implementation:

A pointer to a statically allocated object is returned.

ISO Standard:

“Whether open output streams are flushed, open streams are closed, or temporary
files are removed when the abort function is called (7.20.4.1).”

Implementation:

No.

ISO Standard:

“The termination status returned to the host environment by the abort function
(7.20.4.1).”

Implementation:

By default, there is no host environment.

ISO Standard:

“The value returned by the system function when its argument is not a Null Pointer
(7.20.4.5).”

Implementation:

Application defined.

ISO Standard:

“The local time zone and Daylight Saving Time (7.23.1).”

Implementation:

Application defined.

ISO Standard:

“The era for the clock function (7.23.2.1).”

Implementation:

Application defined.

ISO Standard:

“The positive value for tm_isdst in a normalized tmx structure (7.23.2.6).”

Implementation:

1

ISO Standard:

“The replacement string for the %Z specifier to the strftime, strfxtime,
wcsftime, and wcsfxtime functions in the “C” locale (7.23.3.5, 7.23.3.6, 7.24.5.1,
7.24.5.2).”

Implementation:

Unimplemented.

ISO Standard:

“Whether or when the trigonometric, hyperbolic, base-e exponential, base-e
logarithmic, error, and log gamma functions raise the inexact exception in an IEC
60559 conformant implementation (F.9).”

Implementation:

No.

ISO Standard:

“Whether the inexact exception may be raised when the rounded result actually does
equal the mathematical result in an IEC 60559 conformant implementation (F.9).”

Implementation:

No.

ISO Standard:

“Whether the underflow (and inexact) exception may be raised when a result is tiny
but not inexact in an IEC 60559 conformant implementation (F.9).”

Implementation:

No.

ISO Standard:

“Whether the functions honor the Rounding Direction mode (F.9).”

Implementation:

The Rounding mode is not forced.

26.16 Architecture
ISO Standard:

“The values or expressions assigned to the macros specified in the headers
<float.h>, <limits.h>, and <stdint.h> (C90 and C99 5.2.4.2, C99 7.18.2,
7.18.3).”

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 264

XC32 Compiler for PIC32M
C Implementation-Defined Behavior
Implementation:

See 9.3.2. limits.h.

ISO Standard:

“The number, order, and encoding of bytes in any object (when not explicitly
specified in the standard) (C99 6.2.6.1).”

Implementation:

Little endian, populated from Least Significant Byte first. See 9.2. Data
Representation.

ISO Standard:

“The value of the result of the size of operator (C90 6.3.3.4, C99 6.5.3.4).”

Implementation:

See 9.2. Data Representation.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 265

XC32 Compiler for PIC32M
C++ Implementation-Defined Behavior

27.

C++ Implementation-Defined Behavior
The ISO C++ standard requires a conforming implementation to document the compiler's choices
for behaviors defined in the standard as “implementation-defined.” The following table lists all such
areas, the choices made for the compiler, and the corresponding section number from the ISO/IEC
14882:2014 C++ Standard.
Table 27-1. Implementation-Defined Behavior
ISO Standard

Implementation

Which of the compiler's output messages are diagnostic messages (1.3.6)
All output to stderr is a diagnostic.
The required libraries for a freestanding implementation (1.4)
See the response for The set of headers for a freestanding implementation (17.6.1.3)
The number of bits in a byte (1.7)
8 bits
What constitutes an interactive device (1.9)
If isatty() is true, then interactive stream support is implied.
The number of threads in a program under a freestanding implementation (1.10)
Threads are not directly supported
How physical source file characters are mapped to the basic source character set (2.2)
The locale settings determine the default source character set or UTF-8 if this cannot be
determined by the locale. The basic source character set is UTF-8.
Physical source file characters (2.2)
Defaults to the set locale, and if that doesn’t work, defaults to UTF-8. Can be any encoding
supported by the system’s iconv() library routine.
The execution character member chosen for a source character that does not map to an equivalent execution character.
(2.2)
ABI Defined
Whether source of translation units must be available to locate template definitions (2.2)
The source must be available.
The execution character-set and execution wide-character set (2.3)
The execution character set contains [a-zA-Z0-9_{}[]#()<>%:;.?*+-/^&|∼!=,\"’], space,
control characters representing horizontal tab, vertical tab, form feed, new-line, alert, backspace,
carriage return, and a null character. The execution wide-character set is the same, except instead
of a null character it has a null wide character. Encoding can be anything supported by the system’s
iconv() library routine, defaulting to UTF-8 (or UTF-32, for the wide-character set).
The mapping header name to header or external source file (2.9)
Same name as the header, in UTF-8.
The encoding of universal character name not in the execution character set (2.14.3)
\UNNNNNNNN or \uNNNN, where N is a hex-quad, corresponding to the character short name in
ISO/IEC 10646 NNNNNNNN or 0000NNNN, respectively.
The semantics of non-standard escape sequences (2.14.3)
As an extension, GCC supports the sequence '\e' to act as the ASCII ESC character.
The value of a character literal outside the range of the corresponding type (2.14.3)
The last byte of the series of bytes making up the literal.
The wide-character literal with single c-char that is not in execution wide-character set (2.14.3)
The last four bytes of the series of bytes making up the literal.
The choice of a larger or smaller value of floating literal when the value is not in the range of representable values for its
type (2.14.4)
As per Annex F of C99
The concatenation of string literals other than those fully specified by the standard (2.14.5)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 266

XC32 Compiler for PIC32M
C++ Implementation-Defined Behavior

...........continued
ISO Standard

Implementation
No extra concatenations are supported.

Whether all string literals are distinct (that is, are stored in nonoverlapping objects) (2.14.5)
String literals are not necessarily distinct.
The linkage of main() (3.6.1)
External linkage
The parameters to main (3.6.1)
int main(void)
or
int main(int argc, char** argv)
What constitutes start-up and termination in freestanding environment (3.6.1)
Determined by the device-specific startup code. The default code shipped in a DFP calls
constructors before main() for objects of namespace scope with static storage duration but does
not call destructors after return from main().
Whether defining main is required in a freestanding environment (3.6.1)
Yes - The device-specific startup code can be customized to not call main(), but some features
such as the stack-usage report require main().
Whether dynamic initialization of a non-local variable with static or thread storage duration is done before the first
statement of the initial function of the thread (3.6.2)
Threads are not directly supported
Whether dynamic initialization of a non-local variable with static storage duration is done before the first statement of
main() (3.6.2)
Determined by the device-specific startup code, but the default startup code provided in a DFP
does call the constructors.
Whether an implementation has relaxed or strict pointer safety (3.7.4.3)
Relaxed pointer safety
The extended signed integer types (3.9.1)
None
The representation of char (3.9.1)
One byte.
The signedness of a plain char (3.9.1)
A plain char is signed.
The value representation of floating-point types (3.9.1)
IEEE-754
The value representation of pointer types (3.9.2)
32 bits.
The number of bytes between successive addresses at which a given object can be allocated alignment (3.11)
Valid alignments are powers of 2 up to and including 228.
Whether any extended object alignments are supported and the contexts in which they are supported (3.11)
Extended alignments up to 228 are allowed, subject to the device memory layout.
The value of the result of unsigned to signed conversion (4.7)
For conversion to a type of width N, the value is reduced modulo 2N to be within range of the type.
The result of an inexact floating-point conversion (4.8)
Software emulation uses Round to Nearest but the mode can be changed when using a hardware
FPU.
The value of result of inexact integer to floating-point conversions (4.9)
As per C99 Annex F.
The rank of extended signed integer type (4.13)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 267

XC32 Compiler for PIC32M
C++ Implementation-Defined Behavior

...........continued
ISO Standard

Implementation
Extended signed integer types are not supported.

Passing an argument of class type through ellipsis (5.2.2)
Supported
The class publicly derived from std::type_info which can be returned by typeid (5.2.8)
No extra class is defined. The result is std::type_info.
The conversions between pointers and integers (5.2.10)
A cast from an integer to a pointer or vice versa uses the binary representation of the source type,
reinterpreted as appropriate for the destination type.
If the source type is larger than the destination type, the Most Significant bits are discarded. When
casting from a pointer to an integer, if the source type is smaller than the destination type, the
result is sign extended. When casting from an integer to a pointer, if the source type is smaller than
the destination type, the result is extended based on the signedness of the source type.
The meaning of converting a function pointer to an object pointer type or vice versa (5.2.10)
Conversion is supported. The binary representation is preserved.
The result of sizeof when applied to fundamental types other than char, signed char, and unsigned char (5.3.3)
See 9.3. Integer Data Types, noting that sizeof() returns a size in bytes
Whether over-aligned types are supported (5.3.4, 20.7.9.1, 20.7.11)
Yes.
The type of ptrdiff_t (5.7, 18.2)
int
The result of a right shift of negative values (5.8)
Bitwise operators act on the representation of the value including both the sign and value bits,
where the sign bit is considered immediately above the highest-value value bit.
The meaning of attribute declaration (7)
See 9.11. Variable Attributes and 16.2.1. Function Attributes.
The underlying type for enumeration (7.2)
If the enumeration values are all non-negative, the type is unsigned int, else it is int.
The meaning of the asm declaration (7.4)
See 20.2. Using Inline Assembly Language.
The semantics of linkage specifiers (7.5)
Only “C” and “C++” linkage are supported.
The behavior of non-standard attributes (7.6.1)
See 9.11. Variable Attributes and 16.2.1. Function Attributes.
The behavior of an attribute-scoped-token (7.6.1)
Attributes are available in the “gnu” namespace and are equivalent to __attribute__.
The string resulting from __func__ (8.4.1)
Treated as a constant expression and can be used in constexpr contexts. The string contains the
function name only.
The allocation of bit-fields within a class object (9.6)
Bit fields are allocated left to right.
The alignment of bit-fields within a class object (9.6)
Each member is located to the lowest available offset allowable according to the alignment
restrictions of the member type.
The semantics of linkage specification on templates (14)
Only "C" and "C++" linkage are supported.
Whether the stack is unwound before a call to std::terminate() (15.3, 15.5.1)
The stack is not unwound.
Whether the stack is unwound before calling std::terminate() when a noexcept specification is violated (15.5.1)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 268

XC32 Compiler for PIC32M
C++ Implementation-Defined Behavior

...........continued
ISO Standard

Implementation
The stack is not unwound.

The numeric values of character literals in #if directives (16.1)
Interpreted in the same manner as they would on the target.
Whether a single-character character literal may have a negative value (16.1)
Yes
The manner of search for included source files (16.2)
Sequential, through a defined list of search paths. The search ends on the first match.
The nesting limit for #include directives (16.2)
XC32 imposes a limit of 200 levels to avoid runaway recursion.
The search locations for headers included using "" (16.2)
The #include "file" directive is used for header files defined by your project. XC32 searches for
the file in the directory containing the current source file, then in the quote directories, and then in
the system directories. You can prepend directories using a command-line option.
The search locations for headers included using <> (16.2)
The #include <file> directive is used for system header files packaged with XC32. You can
prepend search directories using a command-line option. Directories are searched in the following
order:
pic32mx/include/c++/<gcc-ver>
pic32mx/include/c++/<gcc-ver>/pic32mx
pic32mx/include/c++/<gcc-ver>/backward
pic32mx/include
pic32mx/include/musl
lib/gcc/pic32mx/<gcc-ver>/include
pic32mx/include/pic32m-libs
The sequence of places searched for a header (16.2)
Quote form includes search the directory of the current file, then in the system directories. Anglebracket form includes only search the system directories.
The behavior of a #pragma directive (16.6)
See 22.3. Pragma Directives
The text equated to __DATE__ when date of translation is not available (16.8)
Expands to "??? ?? ????"
The text equated to __TIME__ when time of translation is not available (16.8)
Expands to "??? ?? ????"
Whether __STDC_VERSION__ is a predefined macro and what it means (16.8)
This macro is a long integer constant that has the format yyyymmL, where yyyy is the year and mm
is the month of the C Standard version with which the compiler is compatible. This shows the C
Standard version to which the compiler conforms.
Whether __STDC__ is a predefined macro and what it means (16.8)
In normal operation, this macro expands to the constant 1, to signify that this compiler conforms to
ISO Standard C.
The set of headers for a freestanding implementation (17.6.1.3)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 269

XC32 Compiler for PIC32M
C++ Implementation-Defined Behavior

...........continued
ISO Standard

Implementation
Every header required by the standard except <atomic>, those being:
<ciso646>
<cstddef>
<cfloat>
<limits>
<climits>
<cstdint>
<cstdlib>
<new>
<typeinfo>
<exception>
<initializer_list>
<cstdalign>
<cstdarg>
<cstdbool>
<type_traits>

Whether a name from the C standard library declared with external linkage has extern "C" or extern "C++" linkage
(17.6.2.3)
extern "C++"
The exceptions thrown by standard library functions that do not have an exception specification (17.6.5.12)
There are no implementation-defined exception classes.
The error_category for errors originating outside the operating system (17.6.5.14)
None.
The type of size_t (18.2)
unsigned int
The form of the exit status returned to the host environment (18.5)
Host environments are not supported.
The return value of bad_alloc::what (18.6.2.1)
The name of the class.
The return value of type_info::name() (18.7.1)
The mangled type name.
The return value of bad_cast::what (18.7.2)
The name of the class.
The return value of bad_typeid::what (18.7.3)
The name of the class.
The result of exception::what (18.8.1)
The name of the class.
The return value of bad_exception::what (18.8.2)
The name of the class.
The use of a non-POF (non-“plain old function”) as signal handler (18.10)
Signals are not supported.
The exception type when the shared_ptr constructor fails (20.8.2.2.1)
std::bad_alloc
Whether placeholder types are CopyAssignable (20.9.9.1.4)
Yes.
Whether extended alignment is supported (20.10.7.6)
Yes.
Whether values are rounded or truncated to the required precision when converting between time_t values and
time_point objects (20.12.7.1)
Values are truncated.
The type of streamoff (21.2.3.1)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 270

XC32 Compiler for PIC32M
C++ Implementation-Defined Behavior

...........continued
ISO Standard

Implementation
long long

The type of streampos (21.2.3.1)
Synonym for fpos<mbstate_t>
The return value of char_traits<char16_t>::eof (21.2.3.2)
int_type(-1)
The type of u16streampos (21.2.3.2)
Synonym for fpos<mbstate_t>
The return value of char_traits<char32_t>::eof (21.2.3.3)
int_type(-1)
The type of u32streampos (21.2.3.3)
Synonym for fpos<mbstate_t>
The type of wstreampos (21.2.3.4)
Synonym for fpos<mbstate_t>
Whether locale object is global or per-thread (22.3.1)
Locale object is global.
The effect on C locale of calling locale::global (22.3.1.5)
If the locale has a name, same as setlocale().
The value of ctype<char>::table_size (22.4.1.3)
SCHAR_MAX + 1
The additional formats accepted for time_get::do_get_date (22.4.5.1.2)
None
Whether time_get::do_get_year accepts two-digit year numbers (22.4.5.1.2)
Two-digit year numbers are accepted.
The formatted character sequence generated by time_put::do_put in the C locale (22.4.5.3.2)
Same as strftime()
The type of array::const_iterator (23.3.2.1)
const T*
The type of array::iterator (23.3.2.1)
T*
The default number of buckets in unordered_map when this is not specified with the constructor (23.5.4.2)
0
The default number of buckets in unordered_multimap when this is not specified with the constructor (23.5.5.2)
0
The default number of buckets in unordered_set when this is not specified with the constructor (23.5.6.2)
0
The default number of buckets in unordered_multiset when this is not specified with the constructor (23.5.7.2)
0
The underlying source of random numbers for random_shuffle (25.3.12)
It uses rand() as the source of randomness.
The effect of calling ios_base::sync_with_stdio after any input or output operation on standard streams (27.5.3.4)
The synchronization referred to is only that between the standard C facilities and the standard C++
objects. User-declared streams are unaffected.
The argument values used to construct the fail object of basic_ios::failure thrown by basic_ios flags functions
(27.5.5.4)
const char&
Whether sequence pointers are copied by basic_stringbuf move constructor (27.8.2.1)
Sequence pointers are copied.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 271

XC32 Compiler for PIC32M
C++ Implementation-Defined Behavior

...........continued
ISO Standard

Implementation

The effect of calling basic_streambuf::setbuf with non-zero arguments (27.8.2.4)
If no buffer has already been created and both arguments are non-zero, then the first argument is
used as a buffer.
Whether sequence pointers are copied by basic_filebuf move constructor (27.9.1.2)
Sequence pointers are copied.
The effect of calling basic_filebuf::setbuf with non-zero arguments (27.9.1.5)
The first argument is used as a buffer.
The effect of calling basic_filebuf::sync when a get area exists (27.9.1.5)
No effect.
The type of regex_constants::error_type (28.5.3)
Unscoped enumeration types.
The values of various ATOMIC_..._LOCK_FREE macros (29.4)
Not supported.
Whether get_pointer_safety returns pointer_safety::relaxed or pointer_safety::preferred if the
implementation has relaxed pointer safety (29.4)
Relaxed pointer safety.
The presence and meaning of native_handle_type and native_handle (30.2.3)
Native handles are not supported.
The type of ios_base::streamoff (D.6)
long long int
The type of ios_base::streampos (D.6)
Typedef fpos<mbstate_t>

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 272

XC32 Compiler for PIC32M
Deprecated Features

28.

Deprecated Features
The features described below are considered to be obsolete and have been replaced with more
advanced functionality. Projects which depend on deprecated features will work properly with
versions of the language tools cited. The use of a deprecated feature will result in a warning;
programmers are encouraged to revise their projects in order to eliminate any dependency on
deprecated features. Support for these features may be removed entirely in future versions of the
language tools.

28.1

Variables in Specified Registers
The compiler allows you to put a few global variables into specified hardware registers.
Note: Using too many registers may impair the ability of the 32-bit compiler to compile. It is not
recommended that registers be placed into fixed registers.
You can also specify the register in which an ordinary register variable should be allocate.
•

Global register variables reserve registers throughout the program. This may be useful in
programs such as programming language interpreters which have a couple of global variables
that are accessed very often.

•

Local register variables in specific registers do not reserve the registers. The compiler’s data flow
analysis is capable of determining where the specified registers contain live values, and where
they are available for other uses. Stores into local register variables may be deleted when they
appear to be unused. References to local register variables may be deleted, moved or simplified.

These local variables are sometimes convenient for use with the extended inline assembly (see
20. Mixing C/C++ and Assembly Language), if you want to write one output of the assembler
instruction directly into a particular register. (This will work provided the register you specify fits the
constraints specified for that operand in the inline assembly statement).

28.2

Defining Global Register Variables
You can define a global register variable like this:
register int *foo asm ("t0");
Here t0 is the name of the register which should be used. Choose a register that is normally saved
and restored by function calls, so that library routines will not clobber it.
Defining a global register variable in a certain register reserves that register entirely for this use, at
least within the current compilation. The register will not be allocated for any other purpose in the
functions in the current compilation. The register will not be saved and restored by these functions.
Stores into this register are never deleted even if they would appear to be dead, but references may
be deleted, moved or simplified.
It is not safe to access the global register variables from signal handlers, or from more than one
thread of control, because the system library routines may temporarily use the register for other
things (unless you recompile them especially for the task at hand).
It is not safe for one function that uses a global register variable to call another such function foo
by way of a third function lose that was compiled without knowledge of this variable (that is, in a
source file in which the variable wasn’t declared). This is because lose might save the register and
put some other value there. For example, you can’t expect a global register variable to be available
in the comparison-function that you pass to qsort, since qsort might have put something else
in that register. This problem can be avoided by recompiling qsort with the same global register
variable definition.
If you want to recompile qsort or other source files that do not actually use your global register
variable, so that they will not use that register for any other purpose, then it suffices to specify

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 273

XC32 Compiler for PIC32M
Deprecated Features

the compiler command-line option -ffixed-reg. You need not actually add a global register
declaration to their source code.
A function that can alter the value of a global register variable cannot safely be called from a
function compiled without this variable, because it could clobber the value the caller expects to find
there on return. Therefore, the function that is the entry point into the part of the program that uses
the global register variable must explicitly save and restore the value that belongs to its caller.
The library function longjmp will restore to each global register variable the value it had at the time
of the setjmp.
All global register variable declarations must precede all function definitions. If such a declaration
appears after function definitions, the register may be used for other purposes in the preceding
functions.
Global register variables may not have initial values because an executable file has no means to
supply initial contents for a register.

28.3

Specifying Registers for Local Variables
You can define a local register variable with a specified register like this:
register int *foo asm ("t0");
Here t0 is the name of the register that should be used. Note that this is the same syntax used for
defining global register variables, but for a local variable it would appear within a function.
Defining such a register variable does not reserve the register; it remains available for other uses
in places where flow control determines the variable’s value is not live. Using this feature may leave
the compiler too few available registers to compile certain functions.
This option does not ensure that the compiler will generate code that has this variable in the
register you specify at all times. You may not code an explicit reference to this register in an asm
statement and assume it will always refer to this variable.
Assignments to local register variables may be deleted when they appear to be unused. References
to local register variables may be deleted, moved or simplified.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 274

XC32 Compiler for PIC32M
Built-In Functions

29.

Built-In Functions
This appendix lists the built-in functions that are specific to MPLAB XC32 C/C++ Compiler.
Built-in functions give the C programmer access to assembler operators or machine instructions
that are currently only accessible using inline assembly, but are sufficiently useful that they are
applicable to a broad range of applications. Built-in functions are coded in C source files syntactically
like function calls, but they are compiled to assembly code that directly implements the function,
and do not involve function calls or library routines.
There are a number of reasons why providing built-in functions is preferable to requiring
programmers to use inline assembly. They include the following:
Providing built-in functions for specific purposes simplifies coding.
Certain optimizations are disabled when inline assembly is used. This is not the case for built-in
functions.
For machine instructions that use dedicated registers, coding inline assembly while avoiding register
allocation errors can require considerable care. The built-in functions make this process simpler
as you do not need to be concerned with the particular register requirements for each individual
machine instruction.

29.1

Built-In Function Descriptions
This section describes the programmer interface to the compiler built-in functions. Since the
functions are “built in,” there are no header files associated with them. Similarly, there are no
command-line switches associated with the built-in functions – they are always available. The built-in
function names are chosen such that they belong to the compiler’s namespace (they all have the
prefix __builtin_ with a leading double underscore), so they will not conflict with function or
variable names in the programmer’s namespace.
Built-In Function List
•

__builtin_bcc0

•

__builtin_bsc0

•

__builtin_bcsc0

•

__builtin_clz

•

__builtin_ctz

•

__builtin_mfc0

•

__builtin_mips_cache

•

__builtin_mtc0

•

__builtin_mxc0

•

__builtin_set_isr_state

•

__builtin_software_breakpoint

•

__builtin_section_begin

•

__builtin_section_end

•

__builtin_section_size

•

__builtin_get_isr_state

29.1.1 __builtin_bcc0 Built-in Function
Description

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 275

XC32 Compiler for PIC32M
Built-In Functions

Clear the non-zero bits present in the clr mask from the coprocessor 0 register specified by rn
(register number) and sel (register bank).
Prototype
unsigned int __builtin_bcc0(rn, sel, clr);
Argument
rn : cp0 register number
sel : cp0 select (bank) number
clr : 32-bit mask to clear

Return Value
unsigned int : the original CP register value
Assembler Operator/Machine Instruction
mfc0 t, cs
nor d, s, t
and d, s, j
mtc0 s, cd

Error Messages
None.

29.1.2 __builtin_bsc0 Built-in Function
Description

Set the non-zero bits present in the set mask from the coprocessor 0 register specified by rn
(register number) and sel (register bank).
Prototype
unsigned int __builtin_bsc0(rn, sel, set);
Argument
rn : cp0 register number
sel : cp0 select (bank) number
set : 32-bit mask to set

Return Value
unsigned int: the original CP register value
Assembler Operator/ Machine Instruction
mfc0 t, cs
or d, s, t
mtc0 s, cd

Error Messages
None.

29.1.3 __builtin_bcsc0 Built-in Function
Description

Clear the non-zero bits present in the clr mask as well as set the non-zero bits present in the set
mask from the coprocessor 0 register specified by rn (register number) and sel (register bank).
Prototype
unsigned int __builtin_bcsc0(rn, sel, clr, set);

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 276

XC32 Compiler for PIC32M
Built-In Functions

Argument
rn : cp0 register number
sel : cp0 select (bank) number
clr : 32-bit mask to clear
set : 32-bit mask to set

Return Value
unsigned int: the original CP register value
Assembler Operator/ Machine Instruction
mfc0 t, cs
nor d, s, t
and d, s, j
or d, s, t
mtc0 s, cd

Error Messages
None.

29.1.4 __builtin_clz Built-in Function
Description
Count leading (high-order) zero bits in x, considered to be a 32-bit word.
Prototype
unsigned int __builtin_clz(x);
Argument
x : 32-bit word to analyse
Return Value
unsigned int : number of leading zero bits
Assembler Operator/ Machine Instruction
clz d, s
Error Messages
None.

29.1.5 __builtin_ctz Built-in Function
Description
Count trailing (low-order) zero bits in x, considered to be a 32-bit word.
Prototype
unsigned int __builtin_ctz(x);
Argument
x : 32-bit word to analyse
Return Value
unsigned int : number of trailing zero bits
Assembler Operator/ Machine Instruction
subu d, s, t
and d, s, t

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 277

XC32 Compiler for PIC32M
Built-In Functions
clz d, s
li d, j
subu d, s, j

Error Messages
None.

29.1.6 __builtin_disable_interrupts Built-in Function
Description
This built-in returns the value of the Status register, then disables interrupts by clearing the
Interrupt Enable (IE) bit in the Status register.
Prototype
void __builtin_disable_interrupts(void);
Argument
None.
Return Value
None.
Assembler Operator/Machine Instruction
di

$2

Error Messages
None.

29.1.7 __builtin_enable_interrupts Built-in Function
Description
This built-in returns the value of the Status register, then enables interrupts by setting the Interrupt
Enable (IE) bit in the Status register.
Prototype
void __builtin_enable_interrupts(void);
Argument
None.
Return Value
None.
Assembler Operator/Machine Instruction
ei

$2

Error Messages
None.

29.1.8 __builtin_get_isr_state Built-in Function
Remember: This built-in function inspects or manipulates the current CPU
interrupt state.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 278

XC32 Compiler for PIC32M
Built-In Functions

Description
Get the current Interrupt Priority Level and Interrupt Enable bits.
Prototype
unsigned int __builtin_get_isr_state(void);
Argument
None.
Return Value
The current IPL and interrupt enable bits in a packed format. This value is to be used with the
__builtin_set_isr_state() function.
Assembler Operator/ Machine Instruction
mfc0
srl
ins
andi
sw

$3, $12, 0
$2,$3,10
$2,$3,3,1
$2,$2,0xf
$2,0($fp)

Error Messages
None.

29.1.9 __builtin_mfc0 Built-in Function
Description
Return the value in a coprocessor 0 register specified by rn (register number) and sel (register
bank). The sel argument must be zero if the coprocessor 0 does not implement register banks
other than 0.
Prototype
unsigned int __builtin_mfc0(rn, sel);
Argument
rn : cp0 register number
sel : cp0 select (bank) number

Return Value
unsigned int : the coprocessor register value
Assembler Operator/Machine Instruction
MFC0 rtemp, rd, sel

where rtemp is a temporary register allocated by the compiler, holding the value read from the
coprocessor
Error Messages
None.

29.1.10 __builtin_mips_cache Built-in Function
Description
Perform an operation on a cache line indicated by address. See the PIC32 Family Reference Manual
for valid operation values.
Prototype

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 279

XC32 Compiler for PIC32M
Built-In Functions

void __builtin_mips_cache(op, addr);
Argument
op : the cache operation
addr :
int32_t, const volatile void *

Return Value
None.
Assembler Operator/ Machine Instruction
cache op, addr
Error Message
None.

29.1.11 __builtin_mtc0 Built-in Function
Description
Moves the value v to the coprocessor 0 register specified by rn (register number) and sel (register
bank).
Prototype
void __builtin_mtc0(rn, sel, v)
Argument
rn : cp0 register number
sel : cp0 select (bank) number
v : the value to write

Return Value
None
Assembler Operator/ Machine Instruction
MTC0 rtemp, rd, sel

where rtemp is a temporary register allocated by the compiler, preloaded with the value v.
Error Messages
None.

29.1.12 __builtin_mxc0 Built-in Function
Description
Write val to the coprocessor 0 register specified by rn (register number) and sel (register bank),
returning the original value of the coprocessor register.
Prototype
unsigned int __builtin_mxc0(rn, sel, val);
Argument
rn : cp0 register number
sel : cp0 select (bank) number
val : 32-bit value to move to the register

Return Value

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 280

XC32 Compiler for PIC32M
Built-In Functions

unsigned int : previous value in specified CP0 register
Assembler Operator/ Machine Instruction
mfc0 t, cs
mtc0 s, cd

Error Messages
None.

29.1.13 void __builtin_nop(void)
Emit a no-operation instruction.
Prototype
void __builtin_nop(void);
Argument
None.
Return Value
None.
Assembler Operator/ Machine Instruction
nop
Error Messages
None.

29.1.14 __builtin_set_isr_state Built-in Function
Description
Set the Interrupt Priority Level and Interrupt Enable bits using a value obtained from
__builtin_get_isr_state().
Prototype
void __builtin_set_isr_state(unsigned int);
Argument
An unsigned integer value obtained from __builtin_get_isr_state().
Return Value
None.
Assembler Operator/ Machine Instruction
di
ehb
mfc0
ins
srl
ins
mtc0
ehb

$2, $12, 0
$2,$3,10,3
$3,$3,3
$2,$3,0,1
$2, $12, 0

Error Messages
None.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 281

XC32 Compiler for PIC32M
Built-In Functions

29.1.15 __builtin_software_breakpoint Built-in Function
Insert a software breakpoint.
Note that the __conditional_software_breakpoint() macro defined in <assert.h> provides
a lightweight variant of assert(exp) that causes only a software breakpoint when the assertion
fails rather than printing a message. This macro is disabled if, at the moment of including
<assert.h>, a macro with the name NDEBUG has already been defined of if a macro with the
name __DEBUG has not been defined. For example:
__conditional_software_breakpoint(myPtr!=NULL);
Prototype
void __builtin_software_breakpoint(void)
Argument
None.
Return Value
None.
Assembler Operator/ Machine Instruction
sdbbp 0
Error Messages
None.

29.1.16 __builtin_section_begin Built-in Function
Remember: This built-in function gets run-time information about section
addresses and sizes.
Description
Return the beginning address of the quoted section name.
Prototype
unsigned long __builtin_section_begin(quoted-section-name);
Argument
quoted-section-name The name of the section.
Return Value
The address of the section.
Assembler Operator/ Machine Instruction
.startof.
Error Messages
An “undefined reference” error message will be displayed if the quoted section name does not exist
in the link.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 282

XC32 Compiler for PIC32M
Built-In Functions

29.1.17 __builtin_section_end Built-in Function
Remember: This built-in function gets run-time information about section
addresses and sizes.
Description
Return the end address of the quoted section name + 1.
Prototype
unsigned long __builtin_section_end(quoted-section-name);
Argument
quoted-section-name The name of the section.
Return Value
The end address of the section + 1.
Assembler Operator/ Machine Instruction
.endof.
Error Messages
An “undefined reference” error message will be displayed if the quoted section name does not exist
in the link.

29.1.18 __builtin_section_size Built-in Function
Remember: This built-in function gets run-time information about section
addresses and sizes.
Description
Return the size in bytes of the named quoted section.
Prototype
unsigned long __builtin_section_size(quoted-section-name);
Argument
quoted-section-name The name of the section.
Return Value
The size in bytes of the named section.
Assembler Operator/ Machine Instruction
.sizeof.
Error Messages
An “undefined reference” error message will be displayed if the quoted section name does not exist
in the link.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 283

XC32 Compiler for PIC32M
Built-In DSP Functions

30.

Built-In DSP Functions
Many PIC32 MCUs support a DSP engine, including instructions that are designed to improve the
performance of DSP and media applications. The DSPr2 engine provides instructions that operate
on packed 8-bit/16-bit integer data, Q7, Q15 and Q31 fractional data.
The XC32 C compiler supports these DSP operations using both the generic vector extensions and
a collection of built-in functions. Both kinds of support are enabled automatically when you select a
DSP device with the -mprocessor option.
The SCOUNT and POS bits of the DSP control register are global. The WRDSP, EXTPDP, EXTPDPV and
MTHLIP instructions modify the SCOUNT and POS bits. During optimization, the compiler will not
delete these instructions and it will not delete calls to functions containing these instructions.
At present, the XC32 C compiler provides support for only operations on 32-bit vectors. The vector
type associated with 8-bit integer data is usually called v4i8, the vector type associated with Q7 is
usually called v4q7, the vector type associated with 16-bit integer data is usually called v2i16, and
the vector type associated with Q15 is usually called v2q15. They can be defined in C as follows:
typedef signed char v4i8 __attribute__ ((vector_size(4)));
typedef signed char v4q7 __attribute__ ((vector_size(4)));
typedef short v2i16 __attribute__ ((vector_size(4)));
typedef short v2q15 __attribute__ ((vector_size(4)));

The v4i8, v4q7, v2i16 and v2q15 values are initialized in the same way as aggregates. For example:
v4i8 a = {1, 2, 3, 4};
v4i8 b;
b = (v4i8) {5, 6, 7, 8};
v2q15 c = {0x0fcb, 0x3a75};
v2q15 d;
d = (v2q15) {0.1234 * 0x1.0p15, 0.4567 * 0x1.0p15};

Notes:
1. The first value is the least significant and the last value is the most significant. The code above
will set the lowest byte of a to 1.
2. Q7, Q15 and Q31 values must be initialized with their integer representation. As shown in this
example, the integer representation of a Q7 value can be obtained by multiplying the fractional
value by 0x1.0p7. The equivalent for Q15 values is to multiply by 0x1.0p15. The equivalent for
Q31 values is to multiply by 0x1.0p31.
The table below lists the v4i8 and v2q15 operations for which hardware support exists. The a and b
are v4i8 values, and c and d are v2q15 values.
C Code

Instruction

a + b

addu.qb

c + d

addq.ph

a - b

subu.qb

c - d

subq.ph

The table below lists the v2i16 operation for which hardware support exists. The e and f are v2i16
values.
C Code

Instruction

e * f

mul.ph

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 284

XC32 Compiler for PIC32M
Built-In DSP Functions

It is easier to describe the DSP built-in functions if the types are defined beforehand.
typedef int q31;
typedef int i32;
typedef unsigned int ui32;
typedef long long a64;

The q31 and i32 operations are actually the same as int, but q31 is used to indicate a Q31 fractional
value and i32 to indicate a 32-bit integer value. Similarly, a64 is the same as long long, but a64 is
used to indicate values that will be placed in one of the four DSP accumulators ($ac0, $ac1, $ac2 or
$ac3).
Also, some built-in functions prefer or require immediate numbers as parameters, because the
corresponding DSP instructions accept both immediate numbers and register operands, or accept
immediate numbers only. The immediate parameters are listed as follows.
imm0_3: 0 to 3.
imm0_7: 0 to 7.
imm0_15: 0 to 15.
imm0_31: 0 to 31.
imm0_63: 0 to 63.
imm0_255: 0 to 255.
imm_n32_31: -32 to 31.
imm_n512_511: -512 to 511.

The following built-in functions map directly to a particular DSP instruction. Please refer to the
PIC32 DSP documentation for details on what each instruction does. In the table below, the
function provides a way to generate the DSP instruction in your code. For example, in v2q15
__builtin_mips_addq_ph (v2q15, v2q15), the addq_ph is the actual DSP instruction.
Table 30-1. Map Directly to DSP Instruction
v2q15 __builtin_mips_absq_s_ph (v2q15)
q31 __builtin_mips_absq_s_w (q31)
v2q15 __builtin_mips_addq_ph (v2q15, v2q15)
v2q15 __builtin_mips_addq_s_ph (v2q15, v2q15)
q31 __builtin_mips_addq_s_w (q31, q31)
i32 __builtin_mips_addsc (i32, i32)
v4i8 __builtin_mips_addu_qb (v4i8, v4i8)
v4i8 __builtin_mips_addu_s_qb (v4i8, v4i8)
i32 __builtin_mips_addwc (i32, i32)
i32 __builtin_mips_bitrev (i32)
i32 __builtin_mips_bposge32 (void)
void __builtin_mips_cmp_eq_ph (v2q15, v2q15)
void __builtin_mips_cmp_le_ph (v2q15, v2q15)
void __builtin_mips_cmp_lt_ph (v2q15, v2q15)
i32 __builtin_mips_cmpgu_eq_qb (v4i8, v4i8)
i32 __builtin_mips_cmpgu_le_qb (v4i8, v4i8)
i32 __builtin_mips_cmpgu_lt_qb (v4i8, v4i8)
void __builtin_mips_cmpu_eq_qb (v4i8, v4i8)
void __builtin_mips_cmpu_le_qb (v4i8, v4i8)
void __builtin_mips_cmpu_lt_qb (v4i8, v4i8)
a64 __builtin_mips_dpaq_s_w_ph (a64, v2q15, v2q15)
a64 __builtin_mips_dpaq_sa_l_w (a64, q31, q31)
a64 __builtin_mips_dpau_h_qbl (a64, v4i8, v4i8)
a64 __builtin_mips_dpau_h_qbr (a64, v4i8, v4i8)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 285

XC32 Compiler for PIC32M
Built-In DSP Functions
a64 __builtin_mips_dpsq_s_w_ph (a64, v2q15, v2q15)
a64 __builtin_mips_dpsq_sa_l_w (a64, q31, q31)
a64 __builtin_mips_dpsu_h_qbl (a64, v4i8, v4i8)
a64 __builtin_mips_dpsu_h_qbr (a64, v4i8, v4i8)
i32 __builtin_mips_extp (a64, i32)
i32 __builtin_mips_extp (a64, imm0_31)
i32 __builtin_mips_extpdp (a64, i32)
i32 __builtin_mips_extpdp (a64, imm0_31)
i32 __builtin_mips_extr_r_w (a64, i32)
i32 __builtin_mips_extr_r_w (a64, imm0_31)
i32 __builtin_mips_extr_rs_w (a64, i32)
i32 __builtin_mips_extr_rs_w (a64, imm0_31)
i32 __builtin_mips_extr_s_h (a64, i32)
i32 __builtin_mips_extr_s_h (a64, imm0_31)
i32 __builtin_mips_extr_w (a64, i32)
i32 __builtin_mips_extr_w (a64, imm0_31)
i32 __builtin_mips_insv (i32, i32)
i32 __builtin_mips_lbux (void *, i32)
i32 __builtin_mips_lhx (void *, i32)
i32 __builtin_mips_lwx (void *, i32)
a64 __builtin_mips_maq_s_w_phl (a64, v2q15, v2q15)
a64 __builtin_mips_maq_s_w_phr (a64, v2q15, v2q15)
a64 __builtin_mips_maq_sa_w_phl (a64, v2q15, v2q15)
a64 __builtin_mips_maq_sa_w_phr (a64, v2q15, v2q15)
i32 __builtin_mips_modsub (i32, i32)
a64 __builtin_mips_mthlip (a64, i32)
q31 __builtin_mips_muleq_s_w_phl (v2q15, v2q15)
q31 __builtin_mips_muleq_s_w_phr (v2q15, v2q15)
v2q15 __builtin_mips_muleu_s_ph_qbl (v4i8, v2q15)
v2q15 __builtin_mips_muleu_s_ph_qbr (v4i8, v2q15)
v2q15 __builtin_mips_mulq_rs_ph (v2q15, v2q15)
a64 __builtin_mips_mulsaq_s_w_ph (a64, v2q15, v2q15)
v2q15 __builtin_mips_packrl_ph (v2q15, v2q15)
v2q15 __builtin_mips_pick_ph (v2q15, v2q15)
v4i8 __builtin_mips_pick_qb (v4i8, v4i8)
q31 __builtin_mips_preceq_w_phl (v2q15)
q31 __builtin_mips_preceq_w_phr (v2q15)
v2q15 __builtin_mips_precequ_ph_qbl (v4i8)
v2q15 __builtin_mips_precequ_ph_qbla (v4i8)
v2q15 __builtin_mips_precequ_ph_qbr (v4i8)
v2q15 __builtin_mips_precequ_ph_qbra (v4i8)
v2q15 __builtin_mips_preceu_ph_qbl (v4i8)
v2q15 __builtin_mips_preceu_ph_qbla (v4i8)
v2q15 __builtin_mips_preceu_ph_qbr (v4i8)
v2q15 __builtin_mips_preceu_ph_qbra (v4i8)
v2q15 __builtin_mips_precrq_ph_w (q31, q31)
v4i8 __builtin_mips_precrq_qb_ph (v2q15, v2q15)

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 286

XC32 Compiler for PIC32M
Built-In DSP Functions
v2q15 __builtin_mips_precrq_rs_ph_w (q31, q31)
v4i8 __builtin_mips_precrqu_s_qb_ph (v2q15, v2q15)
i32 __builtin_mips_raddu_w_qb (v4i8)
i32 __builtin_mips_rddsp (imm0_63)
v2q15 __builtin_mips_repl_ph (i32)
v2q15 __builtin_mips_repl_ph (imm_n512_511)
v4i8 __builtin_mips_repl_qb (i32)
v4i8 __builtin_mips_repl_qb (imm0_255)
a64 __builtin_mips_shilo (a64, i32)
a64 __builtin_mips_shilo (a64, imm_n32_31)
v2q15 __builtin_mips_shll_ph (v2q15, i32)
v2q15 __builtin_mips_shll_ph (v2q15, imm0_15)
v4i8 __builtin_mips_shll_qb (v4i8, i32)
v4i8 __builtin_mips_shll_qb (v4i8, imm0_7)
v2q15 __builtin_mips_shll_s_ph (v2q15, i32)
v2q15 __builtin_mips_shll_s_ph (v2q15, imm0_15)
q31 __builtin_mips_shll_s_w (q31, i32)
q31 __builtin_mips_shll_s_w (q31, imm0_31)
v2q15 __builtin_mips_shra_ph (v2q15, i32)
v2q15 __builtin_mips_shra_ph (v2q15, imm0_15)
v2q15 __builtin_mips_shra_r_ph (v2q15, i32)
v2q15 __builtin_mips_shra_r_ph (v2q15, imm0_15)
q31 __builtin_mips_shra_r_w (q31, i32)
q31 __builtin_mips_shra_r_w (q31, imm0_31)
v4i8 __builtin_mips_shrl_qb (v4i8, i32)
v4i8 __builtin_mips_shrl_qb (v4i8, imm0_7)
v2q15 __builtin_mips_subq_ph (v2q15, v2q15)
v2q15 __builtin_mips_subq_s_ph (v2q15, v2q15)
q31 __builtin_mips_subq_s_w (q31, q31)
v4i8 __builtin_mips_subu_qb (v4i8, v4i8)
v4i8 __builtin_mips_subu_s_qb (v4i8, v4i8)
void __builtin_mips_wrdsp (i32, imm0_63)

The following built-in functions map directly to a particular MIPS DSP REV 2 instruction. Please refer
to the PIC32 DSP documentation for details on what each instruction does.
Table 30-2. Map Directly to MIPS DSP Instruction
v4q7 __builtin_mips_absq_s_qb (v4q7);
v2q15 __builtin_mips_addqh_ph (v2q15, v2q15);
v2q15 __builtin_mips_addqh_r_ph (v2q15, v2q15);
q31 __builtin_mips_addqh_r_w (q31, q31);
q31 __builtin_mips_addqh_w (q31, q31);
v2i16 __builtin_mips_addu_ph (v2i16, v2i16);
v2i16 __builtin_mips_addu_s_ph (v2i16, v2i16);
v4i8 __builtin_mips_adduh_qb (v4i8, v4i8);
v4i8 __builtin_mips_adduh_r_qb (v4i8, v4i8);
i32 __builtin_mips_append (i32, i32, imm0_31);
i32 __builtin_mips_balign (i32, i32, imm0_3);

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 287

XC32 Compiler for PIC32M
Built-In DSP Functions
i32 __builtin_mips_cmpgdu_eq_qb (v4i8, v4i8);
i32 __builtin_mips_cmpgdu_le_qb (v4i8, v4i8);
i32 __builtin_mips_cmpgdu_lt_qb (v4i8, v4i8);
a64 __builtin_mips_dpa_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_dpaqx_s_w_ph (a64, v2q15, v2q15);
a64 __builtin_mips_dpaqx_sa_w_ph (a64, v2q15, v2q15);
a64 __builtin_mips_dpax_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_dps_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_dpsqx_s_w_ph (a64, v2q15, v2q15);
a64 __builtin_mips_dpsqx_sa_w_ph (a64, v2q15, v2q15);
a64 __builtin_mips_dpsx_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_madd (a64, i32, i32);
a64 __builtin_mips_maddu (a64, ui32, ui32);
a64 __builtin_mips_msub (a64, i32, i32);
a64 __builtin_mips_msubu (a64, ui32, ui32);
v2i16 __builtin_mips_mul_ph (v2i16, v2i16);
v2i16 __builtin_mips_mul_s_ph (v2i16, v2i16);
q31 __builtin_mips_mulq_rs_w (q31, q31);
v2q15 __builtin_mips_mulq_s_ph (v2q15, v2q15);
q31 __builtin_mips_mulq_s_w (q31, q31);
a64 __builtin_mips_mulsa_w_ph (a64, v2i16, v2i16);
a64 __builtin_mips_mult (i32, i32);
a64 __builtin_mips_multu (ui32, ui32);
v4i8 __builtin_mips_precr_qb_ph (v2i16, v2i16);
v2i16 __builtin_mips_precr_sra_ph_w (i32, i32, imm0_31);
v2i16 __builtin_mips_precr_sra_r_ph_w (i32, i32, imm0_31);
i32 __builtin_mips_prepend (i32, i32, imm0_31);
v4i8 __builtin_mips_shra_qb (v4i8, i32);
v4i8 __builtin_mips_shra_qb (v4i8, imm0_7);
v4i8 __builtin_mips_shra_r_qb (v4i8, i32);
v4i8 __builtin_mips_shra_r_qb (v4i8, imm0_7);
v2i16 __builtin_mips_shrl_ph (v2i16, i32);
v2i16 __builtin_mips_shrl_ph (v2i16, imm0_15);
v2q15 __builtin_mips_subqh_ph (v2q15, v2q15);
v2q15 __builtin_mips_subqh_r_ph (v2q15, v2q15);
q31 __builtin_mips_subqh_r_w (q31, q31);
q31 __builtin_mips_subqh_w (q31, q31);
v2i16 __builtin_mips_subu_ph (v2i16, v2i16);
v2i16 __builtin_mips_subu_s_ph (v2i16, v2i16);
v4i8 __builtin_mips_subuh_qb (v4i8, v4i8);
v4i8 __builtin_mips_subuh_r_qb (v4i8, v4i8);

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 288

XC32 Compiler for PIC32M
PIC32 DSP Library

31.

PIC32 DSP Library

31.1

Overview
The PIC32 DSP library consists of a set of functions that are applicable to many multimedia
application areas. Most of the functions, like vector operations, filters, and transforms, are
commonly used in many DSP and multimedia applications.
Some functions are designed to be used in specific applications such as video decoding or voice
compression. It is beyond the scope of this manual to describe the operation of such applications.
Functions whose performance is considered critical are implemented in assembly and tuned where
appropriate for a particular processor pipeline implementation and instruction set features. When
a function is typically not considered to be performance critical, or the benefit from an assembly
implementation is not significant, it is implemented in C. Often such functions perform initialization
of data structures and are used only once during the lifetime of an application.
The following table lists all the functions currently available in the DSP Library, arranged by category,
with the available implementation versions. All general purpose functions work with data in 16-bit
fractional format, also known as Q15. Some of the functions also have a version that operates on
32-bit data in Q31 fractional format.
Table 31-1. General Purpose DSP Library Functions by Category
Category

Function Name

Description

Vector Math
Functions

mips_vec_abs16/32

Compute the absolute value of each Q15/Q31 vector element.

mips_vec_add16/32

Add the corresponding elements of two Q15/Q31 vectors.

mips_vec_addc16/32

Add a constant to all elements of a vector.

mips_vec_dotp16/32

Compute dot product of two Q15/Q31 vectors.

mips_vec_mul16/32

Multiply the corresponding elements of two Q15/Q31 vectors.
Can be used for applying windows.

mips_vec_mulc16/32

Multiply all elements of a vector by a constant.

mips_vec_sub16/32

Subtract the corresponding elements of two Q15/Q31 vectors.

mips_vec_sum_squares16/32

Calculate the sum of squares of elements of a vector in
Q15/Q31 format.

mips_fir16

Applies a block FIR filter to a Q15 vector.

mips_fir16_setup

Prepare the filter coefficients for the mips_fir16 function.

Filters

Transforms

Video

mips_iir16

Single-sample IIR filter.

mips_iir16_setup

Prepare the filter coefficients for the mips_iir16 function.

mips_lms16

Single-sample LMS filter

mips_fft16

Compute the complex FFT of a vector containing Q15 complex
samples, i.e., 16-bit fractional real and imaginary parts.

mips_fft16_setup
(deprecated)

Create a vector of twiddle factors used by the mips_fft16
function.

mips_fft32

Compute the complex FFT of a vector containing Q31 complex
samples, i.e., 32-bit fractional real and imaginary parts.

mips_fft32_setup
(deprecated)

Create a vector of twiddle factors used by the mips_fft32
function.

mips_h264_iqt

Inverse quantization and transform for H.264 decoding.

mips_h264_iqt_setup

Create inverse quantization matrix used by the mips_h264_iqt
function.

mips_h264_mc_luma

1/4-pixel motion compensation for luma pixels in H.264 video
decoding.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 289

XC32 Compiler for PIC32M
PIC32 DSP Library

31.2

Fixed-Point Types

Input and output data for most functions in this library is represented in 16-bit fractional numbers,
in Q15 format. This is the most commonly used data format for signal processing. Some function
may use other data formats internally for increased precision of the intermediate results. The Q15
data type used by the DSP functions is specified as a signed 16-bit integer, typedefed as int16 in
the <dsplib_def.h> header files supplied with the library.
Note that within C code care must be taken not to confuse fixed-point values with integers. To the C
compiler, objects used by these routines are integers, not fixed-point, and any arithmetic performed
on those objects in C will be done as integers. Fixed-point values have been declared as integer
types only because the standard C language does not include intrinsic support for fixed-point data
types.

31.3

Saturation, Scaling, and Overflow

In the majority of DSP applications, overflow or underflow during computation is not desirable.
It is best to design for appropriate scaling of the data path and avoid the possibility of overflow
and underflow. However, such scaling can significantly limit the usable data range. Hence, many
algorithm implementations relax the scaling and introduce saturation operations that clip the values
that would otherwise overflow to the maximum or minimum limit of the data range.
Some of the general purpose DSP library module functions accumulate a series of values before
producing the final result. Examples of these accumulations could include the vector dot product
calculation, the FIR filter, the sum of squared values and even the FFT transform. All of these
functions, with the exception of the FFT, include a parameter that controls the output scaling, i.e.,
additional amount of right shift applied when the result is converted to a Q15 value. The FFT results
are automatically scaled down by 2log2(N).

31.4

31.5

Array Alignment and Length Restrictions

For the sake of efficiency, most functions require that array pointer arguments are aligned on
4-byte boundaries. Arrays of the int16 data type declared in C will be correctly aligned. Furthermore,
there are often restrictions on the number of elements that a function can operate on. Typically
the number of elements must be a multiple of a small integer (e.g., four or eight), and must be
larger than, or equal to, a specified minimum. Note that to improve performance, the functions
do not verify the validity of their input parameters. Supplying incorrect parameters may lead to
unpredictable results.

Vector Math Functions

31.5.1 mips_vec_abs16
Description

Computes the absolute value of each element of indata and stores it to outdata. The number of
samples to be processed is given by the parameter N.
Mathematically,

outdata[n] = abs(indata[N])
Include
dsplib_dsp.h
Prototype
void
mips_vec_abs16
(
int16 *outdata,
int16 *indata,
int N
);

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 290

XC32 Compiler for PIC32M
PIC32 DSP Library

Argument

outdata: Output array of 16-bit fixed-point elements in Q15 format.
indata: Input array with 16-bit fixed-point elements in Q15 format.
N: Number of samples.
Return Value
None.
Remarks
•

The pointers outdata and indata must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.2 mips_vec_abs32
Description
Computes the absolute value of each element of indata and stores it to outdata. The number of
samples to be processed is given by the parameter N.
Mathematically,

outdata[n] = abs(indata[N])
Include
dsplib_dsp.h
Prototype
void
mips_vec_abs32
(
int32 *outdata,
int32 *indata,
int N
);

Argument

outdata: Output array of 32-bit fixed-point elements in Q31 format.
indata: Input array with 32-bit fixed-point elements in Q31 format.
N: Number of samples.
Return Value
None.
Remarks
•

The pointers outdata and indata must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.3 mips_vec_add16
Description
Adds each element of indata1 to the corresponding element of indata2. The number of samples to
be processed is given by the parameter N.
Mathematically,

outdata[n] = indata1[n]+indata2[n]

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 291

XC32 Compiler for PIC32M
PIC32 DSP Library

Include
dsplib_dsp.h
Prototype
void
mips_vec_add16
(
int16 *outdata,
int16 *indata1,
int16 *indata2,
int N
);

Argument

outdata: Output array of 16-bit fixed-point elements in Q15 format.
indata1: First input array with 16-bit fixed-point elements in Q15 format.
indata2: Second input array with 16-bit fixed-point elements in Q15 format.
N: Number of samples.
Return Value
None.
Remarks
•

The pointers outdata, indata1, and indata2 must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.4 mips_vec_add32
Description
Adds each element of indata1 to the corresponding element of indata2. The number of samples to
be processed is given by the parameter N.
Mathematically,

outdata[n] = indata1[n]+indata2[n]
Include
dsplib_dsp.h
Prototype
void
mips_vec_add32
(
int32 *outdata,
int32 *indata1,
int32 *indata2,
int N
);

Argument

outdata: Output array of 32-bit fixed-point elements in Q31 format.
indata1: First input array with 32-bit fixed-point elements in Q31 format.
indata2: Second input array with 32-bit fixed-point elements in Q31 format.
N: Number of samples.
Return Value

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 292

XC32 Compiler for PIC32M
PIC32 DSP Library

None.
Remarks
•

The pointers outdata, indata1, and indata2 must be aligned on 4-byte boundaries.

•

N must be larger than, or equal to, 4, and a multiple of 4.

31.5.5 mips_vec_addc16
Description
Adds the Q15 constant c to all elements of indata. The number of samples to be processed is given
by the parameter N.
Mathematically,

outdata[n] = indata[n]+c
Include
dsplib_dsp.h
Prototype
void
mips_vec_addc16
(
int16 *outdata,
int16 *indata,
int16 c,
int N
);

Argument

outdata: Output array of 16-bit fixed-point elements in Q15 format.
indata: Input array with 16-bit fixed-point elements in Q15 format.
c: Constant added to all elements of the vector.
N: Number of samples.
Return Value
None.
Remarks
•

The pointers outdata and indata must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.6 mips_vec_addc32
Description
Adds the Q31 constant c to all elements of indata. The number of samples to be processed is given
by the parameter N.
Mathematically,

outdata[n] = indata[n]+c
Include
dsplib_dsp.h

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 293

XC32 Compiler for PIC32M
PIC32 DSP Library

Prototype
void
mips_vec_addc32
(
int32 *outdata,
int32 *indata,
int32 c,
int N
);

Argument

outdata: Output array of 32-bit fixed-point elements in Q31 format.
indata: Input array with 32-bit fixed-point elements in Q31 format.
c: Constant added to all elements of the vector.
N: Number of samples.
Return Value
None.
Remarks
•

The pointers outdata and indata must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.7 mips_vec_dotp16
Description
Computes the dot product of the Q15 vectors indata1 and indata2. The number of samples to be
processed is given by the parameter N. The scale parameter specifies the amount of right shift
applied to the final result.
Mathematically,
result =

Include

1

2scale

N−1

n=0

indata1 n × indata2 n

dsplib_dsp.h
Prototype
int16
mips_vec_dotp16
(
int16 *indata1,
int16 *indata2,
int N,
int scale
);

Argument

indata1: First input array with 16-bit fixed point elements in Q15 format.
indata2: Second input array.
N: Number of samples.
scale: Scaling factor: divide the result by 2scale.
Return Value

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 294

XC32 Compiler for PIC32M
PIC32 DSP Library

Scaled result of the calculation in fractional Q15 format.
Remarks
•

The pointers outdata and indata must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.8 mips_vec_dotp32
Description
Computes the dot product of the Q31 vectors indata1 and indata2. The number of samples to be
processed is given by the parameter N. The scale parameter specifies the amount of right shift
applied to the final result.
Mathematically,
result =

Include

1

2scale

N−1

n=0

indata1 n × indata2 n

dsplib_dsp.h
Prototype
int32
mips_vec_dotp32
(
int32 *indata1,
int32 *indata2,
int N,
int scale
);

Argument

indata1: First input array with 32-bit fixed point elements in Q31 format.
indata2: Second input array.
N: Number of samples.
scale: Scaling factor: divide the result by 2scale.
Return Value
Scaled result of the calculation in fractional Q31 format.
Remarks
•

The pointers outdata and indata must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.9 mips_vec_mul16
Description
Multiplies each Q15 element of indata1 by the corresponding element of indata2 and stores the
results to outdata. The number of samples to be processed is given by the parameter N.
Mathematically,

outdata[n] = indata[n] x indata2[n]
Include
dsplib_dsp.h

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 295

XC32 Compiler for PIC32M
PIC32 DSP Library

Prototype
void
mips_vec_mul16
(
int16 *outdata,
int16 *indata1,
int16 *indata2,
int N
);

Argument

outdata: Output array of 16-bit fixed-point elements in Q15 format.
indata1: First input array with 16-bit fixed-point elements in Q15 format.
indata2: Second input array.
N: Number of samples.
Return Value
None.
Remarks
•

The pointers outdata, indata1, and indata2 must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.10 mips_vec_mul32
Description
Multiplies each Q31 element of indata1 by the corresponding element of indata2 and stores the
results to outdata. The number of samples to be processed is given by the parameter N.
Mathematically,

outdata[n] = indata1[n] x indata2[n]
Include
dsplib_dsp.h
Prototype
void
mips_vec_mul32
(
int32 *outdata,
int32 *indata1,
int32 *indata2,
int N
);

Argument

outdata: Output array of 32-bit fixed-point elements in Q31 format.
indata1: First input array with 32-bit fixed-point elements in Q31 format.
indata2: Second input array.
N: Number of samples.
Return Value
None.
Remarks

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 296

XC32 Compiler for PIC32M
PIC32 DSP Library

•

The pointers outdata, indata1, and indata2 must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.11 mips_vec_mulc16
Description
Multiplies each Q15 element of indata by the Q15 constant c and stores the results to outdata. The
number of samples to be processed is given by the parameter N.
Mathematically,

outdata[n] = indata1[n] x c
Include
dsplib_dsp.h
Prototype
void
mips_vec_mulc16
(
int16 *outdata,
int16 *indata,
int16 c,
int N
);

Argument

outdata: Output array of 16-bit fixed-point elements in Q15 format.
indata: Input array with 16-bit fixed-point elements in Q15 format.
c: 16-bit fixed-point constant.
N: Number of samples.
Return Value
None.
Remarks
•

The pointers outdata and indata must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.12 mips_vec_mulc32
Description
Multiplies each Q31 element of indata by the Q31 constant c and stores the results to outdata. The
number of samples to be processed is given by the parameter N.
Mathematically,

outdata[n] = indata1[n] x c
Include
dsplib_dsp.h
Prototype
void
mips_vec_mulc32
(
int32 *outdata,
int32 *indata,

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 297

XC32 Compiler for PIC32M
PIC32 DSP Library

);

int32 c,
int N

Argument

outdata: Output array of 32-bit fixed-point elements in Q31 format.
indata: Input array with 32-bit fixed-point elements in Q31 format.
c: 32-bit fixed-point constant.
N: Number of samples.
Return Value
None.
Remarks
•

The pointers outdata and indata must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.13 mips_vec_sub16
Description
Subtracts each element of indata2 from the corresponding element of indata1. The number of
samples to be processed is given by the parameter N.
Mathematically,

outdata[n] = indata1[n] – indata2[n]
Include
dsplib_dsp.h
Prototype
void
mips_vec_sub16
(
int16 *outdata,
int16 *indata1,
int16 *indata2,
int N
);

Argument

outdata: Output array of 16-bit fixed-point elements in Q15 format.
indata1: First input array with 16-bit fixed-point elements in Q15 format.
indata2: Second input array with 16-bit fixed-point elements in Q15 format.
N: Number of samples.
Return Value
None.
Remarks
•

The pointers outdata, indata1, and indata2 must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 298

XC32 Compiler for PIC32M
PIC32 DSP Library

31.5.14 mips_vec_sub32
Description
Subtracts each element of indata2 from the corresponding element of indata1. The number of
samples to be processed is given by the parameter N.
Mathematically,

outdata[n] = indata1[n] – indata2[n]
Include
dsplib_dsp.h
Prototype
void
mips_vec_sub32
(
int32 *outdata,
int32 *indata1,
int32 *indata2,
int N
);

Argument

outdata: Output array of 32-bit fixed-point elements in Q31 format.
indata1: First input array with 32-bit fixed-point elements in Q31 format.
indata2: Second input array with 32-bit fixed-point elements in Q31 format.
N: Number of samples.
Return Value
None.
Remarks
•

The pointers outdata, indata1, and indata2 must be aligned on 4-byte boundaries.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.15 mips_vec_sum_squares16
Description
Computes the sum of squared values of all elements of indata. The number of samples to be
processed is given by the parameter N. The scale parameter specifies the amount of right shift
applied to the final result.
Mathematically,
result =
Include

1

2scale

N−1

n=0

indata n

2

dsplib_dsp.h
Prototype
int16
mips_vec_sum_squares16
(
int16 *indata,
int N,

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 299

XC32 Compiler for PIC32M
PIC32 DSP Library
);

int scale

Argument

indata: Input array with 16-bit fixed-point elements in Q15 format
N: Number of samples
scale: Scaling factor: divide the result by 2scale.
Return Value
Scaled result of the calculation in fractional Q15 format.
Remarks
•

The pointer indata must be aligned on a 4-byte boundary.

•

N must be larger than or equal to 4 and a multiple of 4.

31.5.16 mips_vec_sum_squares32
Description

Computes the sum of squared values of all elements of indata. The number of samples to be
processed is given by the parameter N. The scale parameter specifies the amount of right shift
applied to the final result.
Mathematically,
result =
Include

1

scale

2

N−1

n=0

indata n

2

dsplib_dsp.h
Prototype
int32
mips_vec_sum_squares32
(
int32 *indata,
int N,
int scale
);

Argument

indata: Input array with 32-bit fixed-point elements in Q31 format.
N: Number of samples.
scale: Scaling factor: divide the result by 2scale.
Return Value
Scaled result of the calculation in fractional Q31 format.
Remarks

31.6

•

The pointer indata must be aligned on a 4-byte boundary.

•

N must be larger than or equal to 4 and a multiple of 4.

Filtering Functions

31.6.1 mips_fir16

Description

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 300

XC32 Compiler for PIC32M
PIC32 DSP Library

Computes a finite impulse response (FIR) filter with coefficients specified in coeffs2x over the input
data samples in indata. The function updates the delayline, which is used to initialize the filter the
next time mips_fir16() is called. The number of samples to be processed is given by the parameter N
and the number of filter coefficients is given by K. The scale parameter specifies the amount of right
shift applied to the final result.
Mathematically,
output n =

Include

1

2scale

K−1

k=0

indata n−k × coeffs k

dsplib_dsp.h
Prototype
void
mips_fir16
(
int16 *outdata,
int16 *indata,
int16 *coeffs2x,
int16 *delayline,
int N,
int K,
int scale
);

Argument

outdata: Output array with 16-bit fixed-point elements in Q15 format.
indata: Input array with 16-bit fixed-point elements in Q15 format.
coeffs2x: Array of 2K 16-bit fixed-point coefficients prepared by mips_fir16_setup().
delayline: Delay line array holding the last K input samples.
N: Number of samples.
K: Number of coefficients (filter taps).
scale: Scaling factor: divide the result by 2scale.
Return Value
None.
Remarks
•

The pointers outdata, indata, coeffs2x, and delayline must be aligned on a 4-byte boundary.

•

K must be larger than or equal to 4 and a multiple of 4.
Notes
The coeffs2x array is twice the size of the original coefficient array, coeffs. The function
mips_fir16_setup() takes the original coefficient array coeffs and rearranges the coefficients into
the coeffs2x array to enable more efficient processing. All elements of the delayline array must
be initialized to zero before the first call to mips_fir16(). Both delayline and coeffs2x have formats
that are implementation-dependent and their contents should not be changed directly.
Example
int i;
int K = 8;
int N = 32;
int16 coeffs[K];
int16 coeffs2x[2*K];
int16 delayline[K];

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 301

XC32 Compiler for PIC32M
PIC32 DSP Library
int16 indata[N];
int16 outdata[N];
for (i = 0; i < K; i++)
delayline[i] = 0;
// load coefficients into coeffs here
...
mips_fir16_setup(coeffs2x, coeffs, K);
while (true)
{
// load input data into indata
...
mips_fir16(outdata, indata, coeffs2x, delayline, N, K, 3);
// do something with outdata
...
}

31.6.2 mips_fir16_setup
Description
Rearranges the coefficients from the input array, coeffs, into the output array coeffs2x, which is
used by the mips_fir16() function. The number of coefficients to process is given by the parameter K.
Include
dsplib_dsp.h
Prototype
void
mips_fir16_setup
(
int16 *coeffs2x,
int16 *coeffs,
int K
);

Argument

coeffs2x: Output array holding 2K coefficients rearranged for mips_fir16().
coeffs: Input array holding K 16-bit fixed-point coefficients in Q15 format.
K: Number of coefficients.
Return Value
None.
Remarks
None.
Note
This function is implemented in C.

31.6.3 mips_iir16
Description
Computes a single-sample infinite impulse response (IIR) filter with coefficients specified in coeffs.
The number of biquad sections composing the filter is given by the parameter B. The scale
parameter specifies the amount of right shift applied to the input value of each biquad. Each biquad
section is specified by four coefficients – A1, A2, B1, and B2 – and has two state variables stored
inside delayline.°± The output of each biquad section becomes input to the next one. The output of
the final section is returned as result of the mips_iir16() function.
The operations performed for each biquad section are illustrated below:

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 302

XC32 Compiler for PIC32M
PIC32 DSP Library

Include
dsplib_dsp.h
Prototype
int16
mips_iir16
(
int16 in,
int16 *coeffs,
int16 *delayline,
int B,
int scale
);

Argument

in: Input value in Q15 format.
coeffs: Array of 4B 16-bit fixed-point coefficients prepared by mips_iir16_setup().
delayline: Delay line array holding 2B state 16-bit state variables.
B: Number of biquad sections.
scale: Scaling factor: divide the input to each biquad by 2scale.
Return Value
IIR filter output value in fractional Q15 format.
Remarks
•

The pointers coeffs and delayline must be aligned on a 4-byte boundary.

•

B must be larger than or equal to 2 and a multiple of 2.

Notes
The coeffs array contains four coefficients for each biquad. The coefficients are conveniently
specified in an array of biquad16 structures, which is converted to the appropriate internal
representation by the mips_iir16_setup() function. All elements of the delayline array must be
initialized to zero before the first call to mips_iir16(). Both delayline and coeffs have formats that
are implementation-dependent and their contents should not be changed directly.
Example
int i;
int B = 4;
biquad16 bq[B];
int16 coeffs[4*B];
int16 delayline[2*B];

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 303

XC32 Compiler for PIC32M
PIC32 DSP Library
int16 indata, outdata;
for (i = 0; i < 2*B; i++)
delayline[i] = 0;
// load coefficients into bq here
...
mips_iir16_setup(coeffs, bq, B);
while (true)
{
// get input data value into indata
...

}

outdata = mips_iir16(indata, coeffs, delayline, B, 2);
// do something with outdata
...

31.6.4 mips_iir16_setup
Description
Rearranges the coefficients from the input array, bq, into the output array coeffs, which is used by
the mips_iir16() function. The number of biquad sections to process is given by the parameter B.
Include
dsplib_dsp.h
Prototype
void
mips_iir16_setup
(
int16 *coeffs,
biquad16 *bq,
int B
);

Argument

coeffs: Output array holding 4B coefficients rearranged for mips_iir16().
bq: Input array holding Q15 coefficients for B biquad sections.
B: Number of biquad sections.
Return Value
None.
Remarks
None.
Notes
This function is implemented in C.

31.6.5 mips_lms16
Description
Computes a Least Mean Squares (LMS) adaptive filter and updates its coefficients. The new
coefficients are computed using the error between the last filter output and the reference signal
ref. The function takes one input sample in and computes one output sample. The parameter mu
controls the adaptation rate of the filter.
Include

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 304

XC32 Compiler for PIC32M
PIC32 DSP Library

dsplib_dsp.h
Prototype
int16
mips_lms16
(
int16 in,
int16 ref,
int16 *coeffs,
int16 *delayline,
int16 *error,
int16 K,
int mu
);

Argument

in: Input value in Q15 format.
ref: Desired (reference) value in Q15 format.
coeffs: Input/output array of 16-bit fixed-point coefficients.
delayline: Delay line array holding the last K input samples.
error: Input/output value indicating the difference between the filter output and the reference value.
K: Number of coefficients (filter taps).
mu: Adaptation rate in Q15 format.
Return Value
LMS filter output value in Q15 format.
Remarks
•

The pointers coeffs and delayline must be aligned on a 4-byte boundary.

•

K must be larger than or equal to 4 and a multiple of 2.

Notes
The order of the elements of the coeffs and delayline arrays is implementation dependent. The
delayline array must be initialized to zero before the first call to mips_lms16().

31.7

Frequency Domain Transform Functions

31.7.1 mips_fft16
Description
Computes the complex fast Fourier transform (FFT) of the input sequence din. The number of
samples to be processed is specified by the parameter log2N: N = 2log2N. The fftc array holds
complex coefficients needed by the FFT algorithm. The scratch hold intermediate data; its contents
are destroyed on each call to mips_fft16().
Mathematically,
output n =
Include

1

log2N

2

N−1

k=0

din n × e−j

2πkn
N

dsplib_dsp.h

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 305

XC32 Compiler for PIC32M
PIC32 DSP Library

Prototype
void
mips_fft16
(
int16c *dout,
int16c *din,
int16c *fftc,
int16c *scratch,
int log2N
);

Argument

dout: Output array with 16-bit complex fixed-point elements in Q15 format.
din: Input array with 16-bit complex fixed-point elements in Q15 format.
fftc: Input array with 16-bit complex fixed-point twiddle factors in Q15 format.
scratch: Intermediate results array holding 16-bit complex fixed-point data.
log2N: Logarithm base 2 of the number of samples: N = 2log2N.
Return Value
None.
Remarks
•

The pointers dout, din, fftc, and scratch must be aligned on 4-byte boundaries.

•

log2N must be larger than or equal to 3.

Notes
The scratch array must be large enough to hold N 16-bit complex data samples having 16-bit real
part and 16-bit imaginary part.
Copying fftc to RAM prior to calling this function can be used to improve performance.
Example
#include “fftc.h” // pre-computed coefficients
int log2N = 6; // log2(64) = 6
int N = 1 << log2N; // N = 2^6 = 64
int16c din[N];
int16c dout[N];
int16c scratch[N];
#define fftc fft16c64 // from fftc.h, for N = 64
while (true)
{
// load complex input data into din
...
mips_fft16(dout, din, fftc, scratch, log2N);
// do something with dout
...
}

31.7.2 mips_fft16_setup – Function Deprecated
Description
Calculates the twiddle factors need to compute an FFT of size N. The twiddle factors are used by the
mips_fft16() function. The number of samples to be processed is specified by the parameter log2N:
N = 2log2N.
Include
dsplib_dsp.h

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 306

XC32 Compiler for PIC32M
PIC32 DSP Library

Prototype
void
mips_fft16_setup
(
int16c *twiddles,
int log2N
);

Argument

twiddles: Output array containing N 16-bit complex twiddle factors.
log2N: Logarithm base 2 of the number of samples: N = 2log2N.
Return Value
None.
Remarks
This function requires floating-point support.
Notes
This function is implemented in C.

31.7.3 mips_fft32
Description
Computes the complex Fast Fourier Transform (FFT) of the input sequence din. The number of
samples to be processed is specified by the parameter log2N: N = 2log2N. The fftc array holds
complex coefficients needed by the FFT algorithm. The scratch hold intermediate data; its contents
are destroyed on each call to mips_fft32().
Mathematically,
output n =
Include

1

log2N

2

N−1

k=0

din n × e−j

2πkn
N

dsplib_dsp.h
Prototype
void
mips_fft32
(
int32c *dout,
int32c *din,
int32c *fftc,
int132 *scratch,
int log2N
);

Argument

dout: Output array with 32-bit complex fixed-point elements in Q31 format.
din: Input array with 32-bit complex fixed-point elements in Q31 format.
fftc: Input array with 32-bit complex fixed-point twiddle factors in Q31 format.
scratch: Intermediate results array holding 32-bit complex fixed-point data.
log2N: Logarithm base 2 of the number of samples: N = 2log2N.
Return Value

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 307

XC32 Compiler for PIC32M
PIC32 DSP Library

None.
Remarks
•

The pointers dout, din, fftc, and scratch must be aligned on 4-byte boundaries.

•

log2N must be larger than or equal to 3.

Notes
The scratch array must be large enough to hold N 32-bit complex data samples having 32-bit real
part and 32-bit imaginary part.
Copying fftc to RAM prior to calling this function can be used to improve performance.
Example
#include “fftc.h” // pre-computed coefficients
int log2N = 6; // log2(64) = 6
int N = 1 << log2N; // N = 2^6 = 64
int32c din[N];
int32c dout[N];
int32c scratch[N];
#define fftc fft32c64 // from fftc.h, for N = 64
while (true)
{
// load complex input data into din
...
mips_fft32(dout, din, fftc, scratch, log2N);
// do something with dout
...
}

31.7.4 mips_fft32_setup – Function Deprecated
Description
Calculates the twiddle factors need to compute an FFT of size N. The twiddle factors are used by the
mips_fft32() function. The number of samples to be processed is specified by the parameter log2N:
N = 2log2N.
Include
dsplib_dsp.h
Prototype
void
mips_fft32_setup
(
int32c *twiddles,
int log2N
);

Argument

twiddles: Output array containing N 32-bit complex twiddle factors.
log2N: Logarithm base 2 of the number of samples: N = 2log2N.
Return Value
None.
Remarks
This function requires floating-point support.
Notes
This function is implemented in C.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 308

XC32 Compiler for PIC32M
PIC32 DSP Library

31.8

Video Processing Functions

31.8.1 mips_h264_iqt
Description
Combined inverse quantization and inverse transform function. The input DCT coefficients are
inverse quantized by multiplying them with corresponding elements of the inverse quantization
matrix. The results are transformed by a 4x4¦-element integer inverse DCT as specified in the H.264
video compression standard.
Include
dsplib_video.h
Prototype
void
mips_h264_iqt
(
uint8 b[4][4],
int16 c[4][4],
int16 iq[4][4]
);

Argument

b: Output 4x4-pixel array in 8-bit unsigned integer format.
c: Input 4x4-element array of DCT coefficients in signed 16-bit integer format.
iq: Inverse quantization matrix in signed 16-bit integer format.
Return Value
None.
Remarks
The pointers b, c, and iq must be aligned on 4-byte boundaries.
Notes
The mips_iqt_setup() function can be used to initialize the iq array.
Example:
uint8 b[4][4]
int16 dct_data[4][4];
int16 iq_matrix[4][4];
// quantization parameter
int QP = 28;
// initialize the inverse quantization matrix
mips_h264_iqt_setup(iq_matrix, mips_h264_iq_coeffs, QP);
...
// load DCT data into dct_data
...
mips_h264_iqt(b, dct_data, iq_matrix);

31.8.2 mips_h264_iqt_setup
Description

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 309

XC32 Compiler for PIC32M
PIC32 DSP Library

Computes the inverse quantization matrix used by the mips_iqt() function. The default inverse
quantization coefficient array as specified by the H.264 video compression standard is provided as
mips_h264_iq_coeffs and can be used in place of the q parameter.
Include
dsplib_video.h
Prototype
void
mips_h264_iqt_setup
(
int16 iq[4][4],
int16 q[6][4][4],
int16 qp
);

Argument
iq: Output 4x4-element inverse quantization matrix in signed 16-bit integer format.

q: Input 6x4x4-element inverse quantization coefficient array in signed 16-bit integer format.
qp: Quantization parameter.
Return Value
None.
Remarks
None.
Notes
This function is implemented in C.

31.8.3 mips_h264_mc_luma
Description
This function computes 1/4-pixel motion compensation for luma blocks as specified by the H.264
video compression standard. The function performs all necessary interpolations depending on the
fractional offset of the desired block as specified by the dx and dy input parameters. Note, however,
that there is no special handling of cases that cross the picture edge. It is expected that the image
will be enlarged by four pixels in each direction and the pixels along the edges of the image will be
replicated to the expanded borders.
Include
dsplib_video.h
Prototype
void
mips_h264_mc_luma
(
uint8 b[4][4],
uint8 *src,
int ystride,
int dx,
int dy
);

Argument

b: Output 4x4-pixel array in 8-bit unsigned integer format.
src: Pointer to the top-left pixel of the source image block.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 310

XC32 Compiler for PIC32M
PIC32 DSP Library

ystride: Vertical stride, i.e., distance in bytes between corresponding pixels on adjacent rows.
dx, dy: Fractional pixel offsets multiplied by four, e.g., dx = 1 specifies a 1/4-pixel offset.
Return Value
None.
Remarks:
The offsets dx and dy must have values between 0 and 3 inclusive.
Example
uint8 b[4][4];
uint8 luma[HEIGHT][WIDTH];
int ystride = WIDTH;
...
// obtain 1/4-pixel coordinates of desired block
int x4 = ...;
int y4 = ...;
// compute the integer and fractional parts
int x = x4 >> 2;
int y = y4 >> 2;
int dx4 = x4 & 0x03;
int dy4 = y4 & 0x03;
mips_h264_mc_luma(b, &luma[y][x], ystride, dx4, dy4);

31.8.4 MIPS Technologies Inc.’s DSP Library Notices:
Please note that the following notices apply to the MIPS Technologies Inc. DSP Library.
Copyright © 2003, 2005, 2006, 2007 MIPS Technologies, Inc. All rights reserved.
Unpublished rights (if any) reserved under the copyright laws of the United States of America and
other countries.
This document contains information that is proprietary to MIPS Technologies, Inc. (“MIPS
Technologies”). Any copying, reproducing, modifying or use of this information (in whole or in part)
that is not expressly permitted in writing by MIPS Technologies or an authorized third party is strictly
prohibited. At a minimum, this information is protected under unfair competition and copyright
laws. Violations thereof may result in criminal penalties and fines.
Any document provided in source format (i.e., in a modifiable form such as in FrameMaker or
Microsoft Word format) is subject to use and distribution restrictions that are independent of
and supplemental to any and all confidentiality restrictions. UNDER NO CIRCUMSTANCES MAY
A DOCUMENT PROVIDED IN SOURCE FORMAT BE DISTRIBUTED TO A THIRD PARTY IN SOURCE
FORMAT WITHOUT THE EXPRESS WRITTEN PERMISSION OF MIPS TECHNOLOGIES, INC.
MIPS Technologies reserves the right to change the information contained in this document to
improve function, design or otherwise. MIPS Technologies does not assume any liability arising out
of the application or use of this information, or of any error or omission in such information. Any
warranties, whether express, statutory, implied or otherwise, including but not limited to the implied
warranties of merchantability or fitness for a particular purpose, are excluded. Except as expressly
provided in any written license agreement from MIPS Technologies or an authorized third party, the
furnishing of this document does not give recipient any license to any intellectual property rights,
including any patent rights, that cover the information in this document.
The information contained in this document shall not be exported, reexported, transferred, or
released, directly or indirectly, in violation of the law of any country or international law, regulation,
treaty, Executive Order, statute, amendments or supplements thereto. Should a conflict arise

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 311

XC32 Compiler for PIC32M
PIC32 DSP Library

regarding the export, reexport, transfer, or release of the information contained in this document,
the laws of the United States of America shall be the governing law.
The information contained in this document constitutes one or more of the following: commercial
computer software, commercial computer software documentation or other commercial items. If
the user of this information, or any related documentation of any kind, including related technical
data or manuals, is an agency, department, or other entity of the United States government
(“Government”), the use, duplication, reproduction, release, modification, disclosure, or transfer of
this information, or any related documentation of any kind, is restricted in accordance with Federal
Acquisition Regulation 12.212 for civilian agencies and Defense Federal Acquisition Regulation
Supplement 227.7202 for military agencies. The use of this information by the Government is
further restricted in accordance with the terms of the license agreement(s) and/or applicable
contract terms and conditions covering this information from MIPS Technologies or an authorized
third party.
MIPS, MIPS I, MIPS II, MIPS III, MIPS IV, MIPS V, MIPS-3D, MIPS16, MIPS16e, MIPS32, MIPS64,
MIPS-Based, MIPSsim, MIPSpro, MIPS Technologies logo, MIPS RISC CERTIFIED POWER logo, MIPSVERIFIED, 4K, 4Kc, 4Km, 4Kp, 4KE, 4KEc, 4KEm, 4KEp, 4KS, 4KSc, 4KSd, M4K, 5K, 5Kc, 5Kf, 20K, 20Kc,
24K, 24Kc, 24Kf, 24KE, 24KEc, 24KEf, 25Kf, 34K, 34Kc, 34Kf, R3000, R4000, R5000, ASMACRO, Atlas,
“At the core of the user experience.”, BusBridge, CorExtend, CoreFPGA, CoreLV, EC, JALGO, Malta,
MDMX, MGB, PDtrace, the Pipeline, Pro Series, QuickMIPS, SEAD, SEAD-2, SmartMIPS, SOC-it, and
YAMON are trademarks or registered trademarks of MIPS Technologies, Inc. in the United States and
other countries.
All other trademarks referred to herein are the property of their respective owners.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 312

XC32 Compiler for PIC32M
PIC32 Debug-Support Library

32.

PIC32 Debug-Support Library

32.1

Overview

This library supports both the Application Input/Output debugging feature and the PIC32 Starter Kit
Debug I/O feature.

32.1.1 Application Input/Output with printf() and scanf()
Many PIC32 devices support the APPIN/APPOUT debugging feature. This PIC32 feature allows the
PIC32 application to write text or data to an MPLAB IDE window, invoked from the Tools menu,
without halting the target device. Similarly, you may use the display window to send text or data
back to the target PIC32 device. This feature requires an MPLAB REAL ICE emulator or MPLAB ICD 4
debugger.

32.1.2 Starter Kit Debug Print Mechanism with DBPRINTF() and DBSCANF()
A similar target input/output feature is available for the PIC32 Starter Kit (DM320001) featuring
the PIC32MX360F512L MCU and the PIC32 USB Starter Board (DM320003) featuring the
PIC32MX460F512L MCU.
The print output functionality is routed to the Output window on the MPLAB PIC32MX tab of the
interface window.
For input using the Starter Kit, MPLAB IDE uses a TargetIN window. To send text to the target, type
your text into the Enter Information to be Sent to Target box and click Send.

32.2

Configuring Debug Input/Output for the Target And Tool

The debug-support library, for both the APPIN/APPOUT mechanism and the Starter Kit mechanism,
works by providing alternate I/O helper functions: _mon_write (), _mon_putc (), and
_mon_getc() . These alternate functions use the APPIN/APPOUT or Starter Kit mechanism as
requested in the project. These debug-support function implementations override the default
helper I/O function implementations.
You can choose which implementation to use by defining a preprocessor symbol. To choose the
APPIN/APPOUT implementation, pass the -mappio-debug option to pic32-gcc.exe. To choose
the PIC32 Starter Kit implementation, pass -DPIC32_STARTER_KIT to the compiler shell. Also use
#include <p32xxxx.h> to include the generic header file in your source code.
With one of the above options passed to the compiler and the sys/appio.h include file added
to your source code, the debugging-support library provides alternate I/O helper functions to
the linker. These alternate I/O helper functions redirect stdin and stdout to the appropriate
debugging mechanism. Standard I/O functions now use the selected mechanism.

32.3

PIC32 Debugging Support Header

The <sys/appio.h> header file contains conditional-compilation directives that cause the compiler
to pull in the correct aliased functions. In addition, it provides macros that simplify enabling and
disabling the debugging feature.

32.3.1 DBINIT()
Description
Selects the appropriate mechanism (APPIN/APPOUT or Starter Kit) and initializes buffering as
appropriate. When the -mappio-debug option is passed to the compiler, the init function
initializes the debug library for APPIN/APPOUT. When the –DPIC32_STARTER_KIT option is passed
to the compiler, the init function initializes the debug library for the PIC32 Starter Kit.
The APPIN/APPOUT mechanism disables stdin/stdout buffering while the PIC32 Starter Kit
mechanism uses default line buffering.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 313

XC32 Compiler for PIC32M
PIC32 Debug-Support Library

Include
<sys/appio.h>

Remarks
Behaves as ((void)0) when APPIO debugging or Starter Kit I/O debugging is not enabled.

32.3.2 DBPRINTF()
Description
Calls printf() but is enabled only with the -mappio-debug or –DPIC32_STARTER_KIT option.
When one of these options is not specified on the compiler command line, DBPRINTF() behaves as
((void)0) and printf is not called.
Include
<sys/appio.h>

Remarks
Behaves as ((void)0) when APPIO debugging or Starter Kit I/O debugging is not enabled via the
-mappio-debug or –DPIC32_STARTER_KIT option. Use this macro to insert messages that should
print only when debugging.

32.3.3 DBSCANF()
Description
Calls scanf(). Available for only the APPIN/APPOUT mechanism, not for the PIC32 Starter Kit
mechanism.
Include
<sys/appio.h>

Remarks
Behaves as ((void)0) when APPIN/APPOUT debugging is not enabled via the -mappio-debug or
–DPIC32_STARTER_KIT option. Use this macro to read formatted input that should read only when
debugging. PIC32 Starter Kit users should consider DBGETS instead.

32.3.4 DBGETC(canblock)
Description
Get a single char from the input mechanism.
Include
<sys/appio.h>

Remarks
Behaves as ((void)0) when APPIN/APPOUT debugging or Starter Kit I/O debugging is not enabled
via the -mappio-debug or –DPIC32_STARTER_KIT option.

32.3.5 DBGETWORD(int canblock)
Description
Read a 32-bit word from the APPIN mechanism. Available only for the APPIN/APPOUT mechanism,
not for the PIC32 Starter Kit mechanism.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 314

XC32 Compiler for PIC32M
PIC32 Debug-Support Library

Include
<sys/appio.h>

Remarks
Behaves as ((void)0) when APPIN/APPOUT debugging is not enabled via the -mappio-debug or
–DPIC32_STARTER_KIT option.

32.3.6 DBPUTC(char c)
Description
Writes a single char to the output mechanism
Include
<sys/appio.h>

Remarks
Behaves as ((void)0) when APPIN/APPOUT debugging or Starter Kit I/O debugging is not enabled
via the -mappio-debug or –DPIC32_STARTER_KIT option.

32.3.7 DBPUTWORD(int w)
Description
Writes a 32-bit integer word to the APPOUT mechanism. Available only for the APPIN/APPOUT
mechanism, not for the PIC32 Starter Kit mechanism.
Include
<sys/appio.h>
Remarks
Behaves as ((void)0) when APPIN/APPOUT is not enabled via the -mappio-debug or –
DPIC32_STARTER_KIT option.
Example Code
#include <p32xxxx.h>
int main (void)
{
int num;
char buf[256] ={0};
DBINIT();

while(1)
{
DBPRINTF ("Hello there!\n");
DBPRINTF ("Enter a string\n");
#if defined(__APPIO_DEBUG)
DBSCANF ("%s", &buf[0]);
#elif defined(PIC32_STARTER_KIT)
DBGETS

(&buf[0],128);

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 315

XC32 Compiler for PIC32M
PIC32 Debug-Support Library
#endif
DBPRINTF ("Entered \”%s\”\n\n", &buf[0]);

printf ("Prints to UART2 by default or APPOUT when enabled\n");
}
}

return 0;

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 316

XC32 Compiler for PIC32M
DSP Wrapper Functions

33.

DSP Wrapper Functions

33.1

Overview
The PIC32 DSP wrapper functions assist programmers who are porting existing 16-bit application
software using dsPIC® DSP library functions to PIC32. The wrapper functions internally call the DSP
library functions provided by MIPS Technologies. The wrapper functions are available for some of
the functions supported by dsPIC DSP library.
Note: The DSP libraries from MIPS Technologies support a variety of signal processing functions
that have applicability in speech compression, echo cancellation, noise cancellation, channel
equalization, audio decoding, and many other DSP and media applications. It is always advisable
for the new users to use MIPS Technologies DSP libraries.

33.2

PIC32 DSP Wrapper Functions List
These functions are supported by the DSP wrapper functions for PIC32 MCUs:

33.3

•

VectorAdd16

•

VectorAdd32

•

VectorDotProduct16

•

VectorDotProduct32

•

VectorMultiply16

•

VectorMultiply32

•

VectorScale16

•

VectorScale32

•

VectorSubtract16

•

VectorSubtract32

•

VectorPower16

•

VectorPower32

•

FIR

•

FFTComplex16

•

TwidFactorInit16

•

FFTComplex32

•

TwidFactorInit32

Differences Between Wrapper Functions and dsPIC® DSP Library
The PIC32 DSP wrapper function names, input parameters and return parameters use the sames as
their counterparts in the dsPIC DSP library; however, these are some functional differences:
The number of coefficients in filter (filter->numCoeffs) must be larger than or equal to 4 and
multiple of 4.
Table 33-1. Differences in Wrapper Functions
PIC32 DSP Wrapper Function Name

Differences with Corresponding
®
Function of dsPIC DSP Library

General Comments Regarding PIC32
DSP Library

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 317

XC32 Compiler for PIC32M
DSP Wrapper Functions
FIR (int numSamps, short int*
dstSamps, short int* srcSamps,
FIRStruct* filter)

Some of the parameters of the structure Number of coefficients in filter
FIRStruct are not necessary for
(filter->numCoeffs) must be larger
PIC32 library function. Hence, it is not
than or equal to 4 and multiple of 4.
necessary to initialize these parameters
before the FIR function is called. These
parameters are namely:
filter->coeffsEnd,
filter -> coeffsPage,
filter->delay End,
filter->delay

TwidFactorInit16 (int log2N,
fractcomplex16* twidFactors,
int conjFlag)
TwidFactorInit32 (int log2N,
fractcomplex32* twidFactors,
int conjFlag)

There is a provision in the
TwidFactorInit function of dsPIC
library, either to generate or not
generate a complex conjugates
of twiddles. It is controlled by
flag conjFlag. There is no
such facility in the PIC32 DSP
library. Both TwidFactorInit16 and
TwidFactorInit32 in PIC32 do not
generate a complex conjugate of
twiddles. However, the parameter is
kept in the function prototype of
TwidFactorInit of PIC32 to make it
compatible with dsPIC.

Notes:
1. PIC32 supports both 16-bit and 32-bit vector math operations.
2. The current version of PIC32 DSP wrapper functions does not support floating-point calculations.
3. For all the vector math operations, the number of samples must be larger than or equal to 4 or
multiple of 4.
4. log2N must be larger than or equal to 3 for function FFTComplex16 and FFTComplex32.
5. All the source and destination pointers used for math operations must be aligned on 4-byte
boundaries.
6. The include file for these DSP wrapper functions is <mchp_dsp_wrapper.h>.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 318

XC32 Compiler for PIC32M
ASCII Character Set

34.

ASCII Character Set
Table 34-1. ASCII Character Set
Most Significant Character
Least Significant Character

Hex

0

1

2

3

4

5

6

7

0

NUL

DLE

Space

0

@

P

‘

p

1

SOH

DC1

!

1

A

Q

a

q

2

STX

DC2

"

2

B

R

b

r

3

ETX

DC3

#

3

C

S

c

s

4

EOT

DC4

$

4

D

T

d

t

5

ENQ

NAK

%

5

E

U

e

u

6

ACK

SYN

&

6

F

V

f

v

7

Bell

ETB

’

7

G

W

g

w

8

BS

CAN

(

8

H

X

h

x

9

HT

EM

)

9

I

Y

i

y

A

LF

SUB

*

:

J

Z

j

z

B

VT

ESC

+

;

K

[

k

{

C

FF

FS

,

<

L

\

l

|

D

CR

GS

-

=

M

]

m

}

E

SO

RS

.

>

N

^

n

~

F

SI

US

/

?

O

_

o

DEL

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 319

XC32 Compiler for PIC32M
Document Revision History

35.

Document Revision History
Revision A (August 2018)
•

Initial revision of the document.

Revision B (April 2020)
•

The document was re-formatted throughout, including paragraph numbering and minor editing
changes.

•

Added new topic 3.5.21. How Do I Stop My Project's Checksum From Changing? to the How To’s
section.

•

Corrected description of option -fenforce-eh-specs in Table 4-7.

•

Revised 5. Command-line Driver section extensively.

•

Updated Example 10-6 and Example 10-7 in 10.6.3. Using an Application-Defined Memory
Region.

•

Added examples for keep and noload in the 16.2.1. Function Attributes.

•

Adding more information to 18.2.2. Jump to NMI Handler (_nmi_handler) if an NMI Occurred.

Revision C (May 2023)
•

Updated the stated size and information relating to the double type, which is now 64 bits wide.

•

Corrected examples of using the __pack specifier.

•

Updated information on the compiler option controls available in the MPLAB X IDE.

•

Provided dedicated sections on all compiler options in addition to a summary table.

•

Added new section on the compiler's code coverage feature.

•

Added a new section on the stack and the stack guidance feature.

•

Added -f[no-]common option description, which controls the placement of global variables
defined without an initializer.

•

Added -Warray-bounds option description, which can warn on out-of-bounds array indices and
pointer offsets.

•

Added -Wmultistatement-macros option description, which warns on unsafe macro
expansion.

•

Added -Wsizeof-pointer-div option description, which warns on suspicious divisions
involving pointers.

•

Indicated that the -foptimize-register-move option no longer has any effect.

•

Added information on the iar argument to the -mext option.

•

Added information on the used variable attribute.

•

Added information on the externally_visible function attribute and variable attribute.

•

Expanded information on the naked function attribute.

•

Updated and expanded the sections relating to variables in program memory, reflecting changes
in the compiler.

•

Expanded information on fixed-point types and arithmetic.

•

Expanded information on interrupt context switching.

•

Updated information on the runtime startup code, including information on the data initialization
template.

•

Added information on smart IO library features.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 320

XC32 Compiler for PIC32M
Document Revision History

•

Expanded information on optimizations performed.

•

Added section on preprocessor arithmetic.

•

Added information on the default_function_attributes,
default_variable_attributes, message, GCC optimize, pack, and weak pragmas.

•

Removed reference to the __PIC__ and __pic__ position independent code macros, which are
no longer supported.

•

Indicated in the default linker script information that selecting an alternate DFP will affect the
script used.

•

Added information on __builtin_mfc0 and __builtin_mtc0 built-in functions.

•

Corrected information relating to the return value for the __builtin_bcc0, __builtin_bsc0,
and __builtin_bcsc0 built-in functions.

Revision D (September 2023)
•

Merged the MIPS-related library content in the 32-Bit Language Tools Libraries document into
this guide.

•

Updated references to the C++ standard to reflect that the ISO/IEC 14882:2014 C++ program
language is now supported.

•

Renamed references to the MPLAB XC16 compiler to be MPLAB XC-DSC to reflect the change in
product name.

•

Defined the compiler's implementation-defined behavior for the C++14 standard in a new
section.

•

Clarified information in the runtime startup section.

•

Updated Common C Interface chapter to reflect recent changes in MPLAB XC compilers.

•

Removed reference to MPLAB XC8 in the Embedded Compiler Compatibility Mode chapter, as
this compiler no longer supports this mode.

Revision E (June 2024)
•

Added new How To explaining how the stack usage for each function in a module can be
displayed

•

Updated compiler options used with the Linktime Optimizations setting in XC32 Global options
tab of the MPLAB X IDE Project Properties

•

Added option present in the xc32-ar (Library Archive) tab of the MPLAB X IDE Project Properties

•

Added a diagram indicating the internal compiler applications

•

Updated information relating to runtime startup files

•

Added the following option descriptions to the guide:

-mmalloc-variant

-mips16e

--version

-mlibc-variant

-std

-Wformat-smart-io

-dA

-fdiagnostics-show-caret

-fframe-base-loclist

-mno-info-linker

-ffat-lto-objects

-finline-small-functions

-flto-partition

-fpeel-loops

-ftracer

-fuse-linker-plugin

-T

•

Corrected typo in the name of what should have been the --dint-compression option and
specified this with the -Wl, prefix, since it is a linker option

•

Updated the Dynamic Memory Allocation section to include the new allocation schemes

•

Updated several items in the Common C Interface section to improve readability and include the
XC-DSC compiler

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 321

XC32 Compiler for PIC32M
Document Revision History

•

Expanded the description of the __builtin_disable_interrupts and
__builtin_enable_interrupts Built-in Functions

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 322

XC32 Compiler for PIC32M

The Microchip Website
Microchip provides online support via our website at www.microchip.com/. This website is used to
make files and information easily available to customers. Some of the content available includes:
•

Product Support – Data sheets and errata, application notes and sample programs, design
resources, user’s guides and hardware support documents, latest software releases and archived
software

•

General Technical Support – Frequently Asked Questions (FAQs), technical support requests,
online discussion groups, Microchip design partner program member listing

•

Business of Microchip – Product selector and ordering guides, latest Microchip press releases,
listing of seminars and events, listings of Microchip sales offices, distributors and factory
representatives

Product Change Notification Service
Microchip’s product change notification service helps keep customers current on Microchip
products. Subscribers will receive email notification whenever there are changes, updates, revisions
or errata related to a specified product family or development tool of interest.
To register, go to www.microchip.com/pcn and follow the registration instructions.

Customer Support
Users of Microchip products can receive assistance through several channels:
•

Distributor or Representative

•

Local Sales Office

•

Embedded Solutions Engineer (ESE)

•

Technical Support

Customers should contact their distributor, representative or ESE for support. Local sales offices are
also available to help customers. A listing of sales offices and locations is included in this document.
Technical support is available through the website at: www.microchip.com/support

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 323

XC32 Compiler for PIC32M

Product Identification System
To order or obtain information, e.g., on pricing or delivery, refer to the factory or the listed sales
office.
[X](1)

PART NO.
Device

-

X

Tape and Reel Temperature
Option
Range

/XX

XXX

Package

Pattern

Device:

PIC16F18313, PIC16LF18313, PIC16F18323, PIC16LF18323

Tape and Reel Option:

Blank

= Standard packaging (tube or tray)

T

= Tape and Reel(1)

I

= -40°C to +85°C (Industrial)

E

= -40°C to +125°C (Extended)

JQ

= UQFN

P

= PDIP

ST

= TSSOP

Temperature Range:
Package:(2)

Pattern:







SL

= SOIC-14

SN

= SOIC-8

RF

= UDFN

QTP, SQTP, Code or Special Requirements (blank otherwise)

Examples:
•

PIC16LF18313- I/P Industrial temperature, PDIP package

•

PIC16F18313- E/SS Extended temperature, SSOP package

Notes:
1. Tape and Reel identifier only appears in the catalog part number description. This identifier is
used for ordering purposes and is not printed on the device package. Check with your Microchip
Sales Office for package availability with the Tape and Reel option.
2. Small form-factor packaging options may be available. Please check www.microchip.com/
packaging for small-form factor package availability, or contact your local Sales Office.

Microchip Devices Code Protection Feature
Note the following details of the code protection feature on Microchip products:
•

Microchip products meet the specifications contained in their particular Microchip Data Sheet.

•

Microchip believes that its family of products is secure when used in the intended manner, within
operating specifications, and under normal conditions.

•

Microchip values and aggressively protects its intellectual property rights. Attempts to breach the
code protection features of Microchip product is strictly prohibited and may violate the Digital
Millennium Copyright Act.

•

Neither Microchip nor any other semiconductor manufacturer can guarantee the security of its
code. Code protection does not mean that we are guaranteeing the product is “unbreakable”.
Code protection is constantly evolving. Microchip is committed to continuously improving the
code protection features of our products.

Legal Notice
This publication and the information herein may be used only with Microchip products, including
to design, test, and integrate Microchip products with your application. Use of this information


User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 324

XC32 Compiler for PIC32M

in any other manner violates these terms. Information regarding device applications is provided
only for your convenience and may be superseded by updates. It is your responsibility to ensure
that your application meets with your specifications. Contact your local Microchip sales office for
additional support or, obtain additional support at www.microchip.com/en-us/support/design-help/
client-support-services.
THIS INFORMATION IS PROVIDED BY MICROCHIP "AS IS". MICROCHIP MAKES NO REPRESENTATIONS
OR WARRANTIES OF ANY KIND WHETHER EXPRESS OR IMPLIED, WRITTEN OR ORAL, STATUTORY
OR OTHERWISE, RELATED TO THE INFORMATION INCLUDING BUT NOT LIMITED TO ANY IMPLIED
WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS FOR A PARTICULAR
PURPOSE, OR WARRANTIES RELATED TO ITS CONDITION, QUALITY, OR PERFORMANCE.
IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, INCIDENTAL, OR
CONSEQUENTIAL LOSS, DAMAGE, COST, OR EXPENSE OF ANY KIND WHATSOEVER RELATED TO THE
INFORMATION OR ITS USE, HOWEVER CAUSED, EVEN IF MICROCHIP HAS BEEN ADVISED OF THE
POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO THE FULLEST EXTENT ALLOWED BY LAW,
MICROCHIP'S TOTAL LIABILITY ON ALL CLAIMS IN ANY WAY RELATED TO THE INFORMATION OR
ITS USE WILL NOT EXCEED THE AMOUNT OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO
MICROCHIP FOR THE INFORMATION.
Use of Microchip devices in life support and/or safety applications is entirely at the buyer's risk,
and the buyer agrees to defend, indemnify and hold harmless Microchip from any and all damages,
claims, suits, or expenses resulting from such use. No licenses are conveyed, implicitly or otherwise,
under any Microchip intellectual property rights unless otherwise stated.

Trademarks
The Microchip name and logo, the Microchip logo, Adaptec, AnyRate, AVR, AVR logo, AVR Freaks,
BesTime, BitCloud, chipKIT, chipKIT logo, CryptoMemory, CryptoRF, dsPIC, FlashFlex, flexPWR,
HELDO, IGLOO, JukeBlox, KeeLoq, Kleer, LANCheck, LinkMD, maXStylus, maXTouch, MediaLB,
megaAVR, Microsemi, Microsemi logo, MOST, MOST logo, MPLAB, OptoLyzer, PackeTime, PIC,
picoPower, PICSTART, PIC32 logo, PolarFire, Prochip Designer, QTouch, SAM-BA, SenGenuity,
SpyNIC, SST, SST Logo, SuperFlash, Symmetricom, SyncServer, Tachyon, TimeSource, tinyAVR, UNI/O,
Vectron, and XMEGA are registered trademarks of Microchip Technology Incorporated in the U.S.A.
and other countries.
AgileSwitch, APT, ClockWorks, The Embedded Control Solutions Company, EtherSynch, FlashTec,
Hyper Speed Control, HyperLight Load, IntelliMOS, Libero, motorBench, mTouch, Powermite 3,
Precision Edge, ProASIC, ProASIC Plus, ProASIC Plus logo, Quiet-Wire, SmartFusion, SyncWorld,
Temux, TimeCesium, TimeHub, TimePictra, TimeProvider, WinPath, and ZL are registered
trademarks of Microchip Technology Incorporated in the U.S.A.
Adjacent Key Suppression, AKS, Analog-for-the-Digital Age, Any Capacitor, AnyIn, AnyOut,
Augmented Switching, BlueSky, BodyCom, CodeGuard, CryptoAuthentication, CryptoAutomotive,
CryptoCompanion, CryptoController, dsPICDEM, dsPICDEM.net, Dynamic Average Matching, DAM,
ECAN, Espresso T1S, EtherGREEN, IdealBridge, In-Circuit Serial Programming, ICSP, INICnet,
Intelligent Paralleling, Inter-Chip Connectivity, JitterBlocker, maxCrypto, maxView, memBrain, Mindi,
MiWi, MPASM, MPF, MPLAB Certified logo, MPLIB, MPLINK, MultiTRAK, NetDetach, Omniscient Code
Generation, PICDEM, PICDEM.net, PICkit, PICtail, PowerSmart, PureSilicon, QMatrix, REAL ICE, Ripple
Blocker, RTAX, RTG4, SAM-ICE, Serial Quad I/O, simpleMAP, SimpliPHY, SmartBuffer, SMART-I.S.,
storClad, SQI, SuperSwitcher, SuperSwitcher II, Switchtec, SynchroPHY, Total Endurance, TSHARC,
USBCheck, VariSense, VectorBlox, VeriPHY, ViewSpan, WiperLock, XpressConnect, and ZENA are
trademarks of Microchip Technology Incorporated in the U.S.A. and other countries.
SQTP is a service mark of Microchip Technology Incorporated in the U.S.A.
The Adaptec logo, Frequency on Demand, Silicon Storage Technology, and Symmcom are registered
trademarks of Microchip Technology Inc. in other countries.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 325

XC32 Compiler for PIC32M

GestIC is a registered trademark of Microchip Technology Germany II GmbH & Co. KG, a subsidiary
of Microchip Technology Inc., in other countries.
All other trademarks mentioned herein are property of their respective companies.
© 2024, Microchip Technology Incorporated, Printed in the U.S.A., All Rights Reserved.

ISBN: 978-1-6683-4824-6

Quality Management System
For information regarding Microchip’s Quality Management Systems, please visit
www.microchip.com/quality.

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 326

Worldwide Sales and Service
AMERICAS

ASIA/PACIFIC

ASIA/PACIFIC

EUROPE

Corporate Office

Australia - Sydney

India - Bangalore

Austria - Wels

2355 West Chandler Blvd.

Tel: 61-2-9868-6733

Tel: 91-80-3090-4444

Tel: 43-7242-2244-39

Chandler, AZ 85224-6199

China - Beijing

India - New Delhi

Fax: 43-7242-2244-393

Tel: 480-792-7200

Tel: 86-10-8569-7000

Tel: 91-11-4160-8631

Denmark - Copenhagen

Fax: 480-792-7277

China - Chengdu

India - Pune

Tel: 45-4485-5910

Technical Support:

Tel: 86-28-8665-5511

Tel: 91-20-4121-0141

Fax: 45-4485-2829

www.microchip.com/support

China - Chongqing

Japan - Osaka

Finland - Espoo

Web Address:

Tel: 86-23-8980-9588

Tel: 81-6-6152-7160

Tel: 358-9-4520-820

www.microchip.com

China - Dongguan

Japan - Tokyo

France - Paris

Atlanta

Tel: 86-769-8702-9880

Tel: 81-3-6880- 3770

Tel: 33-1-69-53-63-20

Duluth, GA

China - Guangzhou

Korea - Daegu

Fax: 33-1-69-30-90-79

Tel: 678-957-9614

Tel: 86-20-8755-8029

Tel: 82-53-744-4301

Germany - Garching

Fax: 678-957-1455

China - Hangzhou

Korea - Seoul

Tel: 49-8931-9700

Austin, TX

Tel: 86-571-8792-8115

Tel: 82-2-554-7200

Germany - Haan

Tel: 512-257-3370

China - Hong Kong SAR

Malaysia - Kuala Lumpur

Tel: 49-2129-3766400

Boston

Tel: 852-2943-5100

Tel: 60-3-7651-7906

Germany - Heilbronn

Westborough, MA

China - Nanjing

Malaysia - Penang

Tel: 49-7131-72400

Tel: 774-760-0087

Tel: 86-25-8473-2460

Tel: 60-4-227-8870

Germany - Karlsruhe

Fax: 774-760-0088

China - Qingdao

Philippines - Manila

Tel: 49-721-625370

Chicago

Tel: 86-532-8502-7355

Tel: 63-2-634-9065

Germany - Munich

Itasca, IL

China - Shanghai

Singapore

Tel: 49-89-627-144-0

Tel: 630-285-0071

Tel: 86-21-3326-8000

Tel: 65-6334-8870

Fax: 49-89-627-144-44

Fax: 630-285-0075

China - Shenyang

Taiwan - Hsin Chu

Germany - Rosenheim

Dallas

Tel: 86-24-2334-2829

Tel: 886-3-577-8366

Tel: 49-8031-354-560

Addison, TX

China - Shenzhen

Taiwan - Kaohsiung

Israel - Ra’anana

Tel: 972-818-7423

Tel: 86-755-8864-2200

Tel: 886-7-213-7830

Tel: 972-9-744-7705

Fax: 972-818-2924

China - Suzhou

Taiwan - Taipei

Italy - Milan

Detroit

Tel: 86-186-6233-1526

Tel: 886-2-2508-8600

Tel: 39-0331-742611

Novi, MI

China - Wuhan

Thailand - Bangkok

Fax: 39-0331-466781

Tel: 248-848-4000

Tel: 86-27-5980-5300

Tel: 66-2-694-1351

Italy - Padova

Houston, TX

China - Xian

Vietnam - Ho Chi Minh

Tel: 39-049-7625286

Tel: 281-894-5983

Tel: 86-29-8833-7252

Tel: 84-28-5448-2100

Netherlands - Drunen

Indianapolis

China - Xiamen

Tel: 31-416-690399

Noblesville, IN

Tel: 86-592-2388138

Fax: 31-416-690340

Tel: 317-773-8323

China - Zhuhai

Norway - Trondheim

Fax: 317-773-5453

Tel: 86-756-3210040

Tel: 47-72884388

Tel: 317-536-2380

Poland - Warsaw

Los Angeles

Tel: 48-22-3325737

Mission Viejo, CA

Romania - Bucharest

Tel: 949-462-9523

Tel: 40-21-407-87-50

Fax: 949-462-9608

Spain - Madrid

Tel: 951-273-7800

Tel: 34-91-708-08-90

Raleigh, NC

Fax: 34-91-708-08-91

Tel: 919-844-7510

Sweden - Gothenberg

New York, NY

Tel: 46-31-704-60-40

Tel: 631-435-6000

Sweden - Stockholm

San Jose, CA

Tel: 46-8-5090-4654

Tel: 408-735-9110

UK - Wokingham

Tel: 408-436-4270

Tel: 44-118-921-5800

Canada - Toronto

Fax: 44-118-921-5820

Tel: 905-695-1980
Fax: 905-695-2078

User Guide

© 2024 Microchip Technology Inc. and its subsidiaries

DS50002799E - 327

