@startuml
title CNC Motion Control - Current Implementation Status (November 2025)
!theme blueprint

participant "GCODE_Tasks\n(âœ… Complete)" as GCODE
participant "KINEMATICS\n(âœ… Complete)" as KINEMATICS
participant "MOTION_Tasks\n(ðŸš§ In Progress)" as MOTION
participant "TMR2\n(Free-Running)" as TMR2
participant "OC1 ISR\n(X Axis)" as OC1
participant "OC2 ISR\n(Y Axis)" as OC2
participant "OC3 ISR\n(Z Axis)" as OC3
participant "OC4 ISR\n(A Axis)" as OC4
participant "Bresenham\nState Machine" as Bresenham

== Current Implementation Flow ==
GCODE -> GCODE : Parse G01 X100 Y25 Z10 F1000
GCODE -> GCODE : Extract command to gcodeCommandQueue (âœ…)
GCODE -> KINEMATICS : Call KINEMATICS_LinearMove()
KINEMATICS -> KINEMATICS : Convert work â†’ machine coordinates (âœ…)
KINEMATICS -> KINEMATICS : Calculate Bresenham parameters (âœ…)
KINEMATICS -> KINEMATICS : Determine dominant axis = X (highest Î”) (âœ…)
KINEMATICS -> MOTION : Return pre-calculated MotionSegment
MOTION -> TMR2 : Initialize TMR2 continuous operation (âœ…)
note right of TMR2
  âœ… TMR2 runs continuously at 10Âµs/tick
  âœ… 32-bit timer (TMR2:TMR3 pair)  
  âœ… Never stops or resets during operation
  âœ… Provides stable time base for all axes
end note

MOTION -> OC1 : Setup dominant axis tracking (âœ…)
MOTION -> OC1 : Set OC1R = TMR2 + interval (absolute value)
MOTION -> OC1 : Set OC1RS = OC1R + pulse_width (absolute value)
note right of OC1
  X axis tracks ahead of TMR2
  All values are absolute timer counts
  Dominant axis continuously scheduled
end note

== Runtime - Dominant Axis Drives Motion ==
TMR2 -> OC1 : Match event (TMR2 == OC1R)
activate OC1
OC1 -> OC1 : Generate X step pulse
OC1 -> OC1 : Increment X step counter
OC1 -> Bresenham : Signal step complete, check subordinates
deactivate OC1

activate Bresenham
Bresenham -> Bresenham : Update error_y += delta_y
Bresenham -> Bresenham : Update error_z += delta_z
Bresenham -> Bresenham : Update error_a += delta_a

alt error_y >= delta_x (Y needs step)
    Bresenham -> OC2 : Set OC2R = TMR2 + offset (absolute)
    Bresenham -> OC2 : Set OC2RS = OC2R + pulse_width
    Bresenham -> Bresenham : error_y -= delta_x
end

alt error_z >= delta_x (Z needs step)
    Bresenham -> OC3 : Set OC3R = TMR2 + offset (absolute)
    Bresenham -> OC3 : Set OC3RS = OC3R + pulse_width
    Bresenham -> Bresenham : error_z -= delta_x
end

alt error_a >= delta_x (A needs step)
    Bresenham -> OC4 : Set OC4R = TMR2 + offset (absolute)
    Bresenham -> OC4 : Set OC4RS = OC4R + pulse_width
    Bresenham -> Bresenham : error_a -= delta_x
end

Bresenham -> OC1 : Schedule next X pulse (OC1R = TMR2 + interval)
note right
  Dominant axis continuously
  tracks ahead of TMR2
end note
deactivate Bresenham

== Subordinate Axis Pulses (On Demand) ==
alt Y step scheduled
    TMR2 -> OC2 : Match event (TMR2 == OC2R)
    activate OC2
    OC2 -> OC2 : Generate Y pulse
    OC2 -> OC2 : Increment Y counter
    deactivate OC2
end

alt Z step scheduled
    TMR2 -> OC3 : Match event (TMR2 == OC3R)
    activate OC3
    OC3 -> OC3 : Generate Z pulse
    OC3 -> OC3 : Increment Z counter
    deactivate OC3
end

== Dynamic Axis Swapping (Optional) ==
alt Trajectory changes - Y becomes dominant
    Planner -> OC1 : Stop tracking ahead
    Planner -> OC2 : Start tracking ahead of TMR2
    note right
      Dominant axis swapped
      seamlessly during motion
      No timer reset required
    end note
end

== Segment Completion ==
loop Until all steps complete
    TMR2 -> OC1 : Continue dominant axis pulses
    Bresenham -> Bresenham : Update errors, schedule subordinates
end

OC1 -> Planner : All X steps complete
Planner -> Planner : Check all axes complete
Planner -> Planner : Load next segment

@enduml