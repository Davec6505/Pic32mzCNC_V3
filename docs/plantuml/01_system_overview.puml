@startuml
title CNC Motion Control - Current Implementation Status (November 2025)
!theme blueprint

participant "GCODE_Tasks\n(âœ… Complete)" as GCODE
participant "UTILS_Module\n(âœ… Complete)" as UTILS  
participant "APP_Tasks\n(âœ… Complete)" as APP
participant "KINEMATICS\n(âœ… Complete)" as KINEMATICS
participant "STEPPER\n(âœ… Complete)" as STEPPER
participant "MOTION_Tasks\n(ðŸš§ In Progress)" as MOTION
participant "LIMIT_CHECK\n(âœ… Complete)" as LIMITS
participant "TMR2\n(Free-Running)" as TMR2
participant "OC1 ISR\n(X Axis)" as OC1
participant "OC2 ISR\n(Y Axis)" as OC2
participant "OC3 ISR\n(Z Axis)" as OC3
participant "OC4 ISR\n(A Axis)" as OC4
participant "Bresenham\nState Machine" as Bresenham

== Current Implementation Flow ==
GCODE -> GCODE : Receive "G90G1X100Y25F1000S200M3" (multi-command line)
GCODE -> UTILS : Call UTILS_TokenizeGcodeLine()
UTILS -> UTILS : Split into tokens: ["G90", "G1", "X100", "Y25", "F1000", "S200", "M3"]
UTILS -> GCODE : Return tokenized commands
GCODE -> GCODE : Store commands in gcodeCommandQueue (âœ…)
note right of GCODE
  âœ… Commands ready for event processing
  âœ… Clean separation: parsing vs execution
  âœ… APP_DATA abstraction layer preserved
end note
== Event-Driven Processing in APP_Tasks ==
participant "APP_Tasks" as APP
APP -> GCODE : Call GCODE_GetNextEvent(&cmdQueue, &event)
GCODE -> GCODE : Parse next command to GCODE_Event
GCODE -> APP : Return event (G1, G90, M3, etc.)

APP -> APP : Process event through APP_DATA abstraction
note right of APP
  âœ… Event-driven architecture
  âœ… Clean interface: GCODE_GetNextEvent()
  âœ… Your APP_DATA controls all routing
  âœ… Separation of concerns maintained
end note

alt event.type == GCODE_EVENT_LINEAR_MOVE
    APP -> KINEMATICS : Convert coordinates using event data
    KINEMATICS -> KINEMATICS : Calculate Bresenham parameters (âœ…)
    KINEMATICS -> KINEMATICS : Determine dominant axis = X (highest Î”) (âœ…)
    KINEMATICS -> APP : Return pre-calculated MotionSegment
    APP -> APP : Add to appData.motionQueue through YOUR abstraction
end
MOTION -> TMR2 : Initialize TMR2 continuous operation (âœ…)
note right of TMR2
  âœ… TMR2 runs continuously at 10Âµs/tick
  âœ… 32-bit timer (TMR2:TMR3 pair)  
  âœ… Never stops or resets during operation
  âœ… Provides stable time base for all axes
end note

MOTION -> OC1 : Setup dominant axis tracking (âœ…)
MOTION -> OC1 : Set OC1R = TMR2 + interval (absolute value)
MOTION -> OC1 : Set OC1RS = OC1R + pulse_width (absolute value)
note right of OC1
  X axis tracks ahead of TMR2
  All values are absolute timer counts
  Dominant axis continuously scheduled
end note

== Runtime - Dominant Axis Drives Motion ==
TMR2 -> OC1 : Match event (TMR2 == OC1R)
activate OC1
OC1 -> OC1 : Generate X step pulse
OC1 -> OC1 : Increment X step counter
OC1 -> Bresenham : Signal step complete, check subordinates
deactivate OC1

activate Bresenham
Bresenham -> Bresenham : Update error_y += delta_y
Bresenham -> Bresenham : Update error_z += delta_z
Bresenham -> Bresenham : Update error_a += delta_a

alt error_y >= delta_x (Y needs step)
    Bresenham -> OC2 : Set OC2R = TMR2 + offset (absolute)
    Bresenham -> OC2 : Set OC2RS = OC2R + pulse_width
    Bresenham -> Bresenham : error_y -= delta_x
end

alt error_z >= delta_x (Z needs step)
    Bresenham -> OC3 : Set OC3R = TMR2 + offset (absolute)
    Bresenham -> OC3 : Set OC3RS = OC3R + pulse_width
    Bresenham -> Bresenham : error_z -= delta_x
end

alt error_a >= delta_x (A needs step)
    Bresenham -> OC4 : Set OC4R = TMR2 + offset (absolute)
    Bresenham -> OC4 : Set OC4RS = OC4R + pulse_width
    Bresenham -> Bresenham : error_a -= delta_x
end

Bresenham -> OC1 : Schedule next X pulse (OC1R = TMR2 + interval)
note right
  Dominant axis continuously
  tracks ahead of TMR2
end note
deactivate Bresenham

== Subordinate Axis Pulses (On Demand) ==
alt Y step scheduled
    TMR2 -> OC2 : Match event (TMR2 == OC2R)
    activate OC2
    OC2 -> OC2 : Generate Y pulse
    OC2 -> OC2 : Increment Y counter
    deactivate OC2
end

alt Z step scheduled
    TMR2 -> OC3 : Match event (TMR2 == OC3R)
    activate OC3
    OC3 -> OC3 : Generate Z pulse
    OC3 -> OC3 : Increment Z counter
    deactivate OC3
end

== Dynamic Axis Swapping (Optional) ==
alt Trajectory changes - Y becomes dominant
    Planner -> OC1 : Stop tracking ahead
    Planner -> OC2 : Start tracking ahead of TMR2
    note right
      Dominant axis swapped
      seamlessly during motion
      No timer reset required
    end note
end

== Segment Completion ==
loop Until all steps complete
    TMR2 -> OC1 : Continue dominant axis pulses
    Bresenham -> Bresenham : Update errors, schedule subordinates
end

OC1 -> Planner : All X steps complete
Planner -> Planner : Check all axes complete
Planner -> Planner : Load next segment

@enduml