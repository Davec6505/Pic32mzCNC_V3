@startuml
title CNC Motion Control - Current Implementation Status (November 2025)
!theme blueprint

participant "GCODE_Tasks\n(âœ… Complete)" as GCODE
participant "UTILS_Module\n(âœ… Complete)" as UTILS  
participant "APP_Tasks\n(âœ… Complete)" as APP
participant "KINEMATICS\n(âœ… Complete)" as KINEMATICS
participant "STEPPER\n(âœ… Complete)" as STEPPER
participant "MOTION_Tasks\n(ðŸš§ In Progress)" as MOTION
participant "LIMIT_CHECK\n(âœ… Complete)" as LIMITS
participant "TMR2\n(Free-Running)" as TMR2
participant "OC1 ISR\n(X Axis)" as OC1
participant "OC2 ISR\n(Y Axis)" as OC2
participant "OC3 ISR\n(Z Axis)" as OC3
participant "OC4 ISR\n(A Axis)" as OC4
participant "Bresenham\nState Machine" as Bresenham

== Current Implementation Flow ==
GCODE -> GCODE : Receive "G90G1X100Y25F1000S200M3" (multi-command line)
GCODE -> UTILS : Call UTILS_TokenizeGcodeLine()
UTILS -> UTILS : Split into tokens: ["G90", "G1X100Y25F1000", "S200", "M3"]
UTILS -> GCODE : Return tokenized commands
GCODE -> GCODE : Store commands in gcodeCommandQueue (âœ…)
note right of GCODE
  âœ… Commands ready for event processing
  âœ… Clean separation: parsing vs execution
  âœ… APP_DATA abstraction layer preserved
end note
== Event-Driven Processing in APP_Tasks ==
participant "APP_Tasks" as APP
APP -> GCODE : Call GCODE_GetNextEvent(&cmdQueue, &event)
GCODE -> GCODE : Parse next command to GCODE_Event
GCODE -> APP : Return event (G1, G90, M3, etc.)

APP -> APP : Process event through APP_DATA abstraction
note right of APP
  âœ… Event-driven architecture
  âœ… Clean interface: GCODE_GetNextEvent()
  âœ… Your APP_DATA controls all routing
  âœ… Separation of concerns maintained
end note

alt event.type == GCODE_EVENT_LINEAR_MOVE
    APP -> APP : Check soft limits (fabsf against max_travel) (âœ…)
    alt Soft limit exceeded
        APP -> APP : Set alarmCode = 2, transition to APP_ALARM (âœ…)
        APP -> STEPPER : STEPPER_DisableAll() - emergency stop (âœ…)
    else Within limits
        APP -> KINEMATICS : Convert coordinates using event data
        KINEMATICS -> KINEMATICS : Calculate Bresenham parameters (âœ…)
        KINEMATICS -> KINEMATICS : Calculate trapezoidal velocity profile (âœ…)
        KINEMATICS -> KINEMATICS : Determine dominant axis = X (highest Î”) (âœ…)
        KINEMATICS -> APP : Return pre-calculated MotionSegment
        APP -> APP : Add to appData.motionQueue through YOUR abstraction
    end
end

== Hard Limit Monitoring (Every APP_Tasks Iteration) ==
APP -> LIMITS : MOTION_UTILS_CheckHardLimits(invert_mask) (âœ…)
alt Hard limit triggered
    LIMITS -> APP : Return true
    APP -> APP : Set alarmCode = 1, transition to APP_ALARM (âœ…)
    APP -> STEPPER : STEPPER_DisableAll() - emergency stop (âœ…)
    APP -> APP : Clear motion queue and G-code queue (âœ…)
    APP -> APP : Send "ALARM:1 Hard limit triggered" (âœ…)
else No limits
    LIMITS -> APP : Return false
    APP -> APP : Continue normal operation
end
MOTION -> TMR2 : Initialize TMR2 continuous operation (âœ…)
note right of TMR2
  âœ… TMR2 runs continuously at 10Âµs/tick
  âœ… 32-bit timer (TMR2:TMR3 pair)  
  âœ… Never stops or resets during operation
  âœ… Provides stable time base for all axes
end note

MOTION -> OC1 : Setup dominant axis tracking (âœ…)
MOTION -> OC1 : Set OC1R = TMR2 + interval (absolute value)
MOTION -> OC1 : Set OC1RS = OC1R + pulse_width (absolute value)
note right of OC1
  X axis tracks ahead of TMR2
  All values are absolute timer counts
  Dominant axis continuously scheduled
end note

== Runtime - Dominant Axis Drives Motion ==
TMR2 -> OC1 : Match event (TMR2 == OC1R)
activate OC1
OC1 -> OC1 : Generate X step pulse
OC1 -> OC1 : Increment X step counter
OC1 -> Bresenham : Signal step complete, check subordinates
deactivate OC1

activate Bresenham
Bresenham -> Bresenham : Update error_y += delta_y
Bresenham -> Bresenham : Update error_z += delta_z
Bresenham -> Bresenham : Update error_a += delta_a

alt error_y >= delta_x (Y needs step)
    Bresenham -> OC2 : Set OC2R = TMR2 + offset (absolute)
    Bresenham -> OC2 : Set OC2RS = OC2R + pulse_width
    Bresenham -> Bresenham : error_y -= delta_x
end

alt error_z >= delta_x (Z needs step)
    Bresenham -> OC3 : Set OC3R = TMR2 + offset (absolute)
    Bresenham -> OC3 : Set OC3RS = OC3R + pulse_width
    Bresenham -> Bresenham : error_z -= delta_x
end

alt error_a >= delta_x (A needs step)
    Bresenham -> OC4 : Set OC4R = TMR2 + offset (absolute)
    Bresenham -> OC4 : Set OC4RS = OC4R + pulse_width
    Bresenham -> Bresenham : error_a -= delta_x
end

Bresenham -> OC1 : Schedule next X pulse (OC1R = TMR2 + interval)
note right
  Dominant axis continuously
  tracks ahead of TMR2
end note
deactivate Bresenham

== Subordinate Axis Pulses (On Demand) ==
alt Y step scheduled
    TMR2 -> OC2 : Match event (TMR2 == OC2R)
    activate OC2
    OC2 -> OC2 : Generate Y pulse
    OC2 -> OC2 : Increment Y counter
    deactivate OC2
end

alt Z step scheduled
    TMR2 -> OC3 : Match event (TMR2 == OC3R)
    activate OC3
    OC3 -> OC3 : Generate Z pulse
    OC3 -> OC3 : Increment Z counter
    deactivate OC3
end

== Dynamic Axis Swapping (Optional) ==
alt Trajectory changes - Y becomes dominant
    Planner -> OC1 : Stop tracking ahead
    Planner -> OC2 : Start tracking ahead of TMR2
    note right
      Dominant axis swapped
      seamlessly during motion
      No timer reset required
    end note
end

== Segment Completion ==
loop Until all steps complete
    TMR2 -> OC1 : Continue dominant axis pulses
    Bresenham -> Bresenham : Update errors, schedule subordinates
end

OC1 -> Planner : All X steps complete
Planner -> Planner : Check all axes complete
Planner -> Planner : Load next segment

== Compile-Time Debug System (November 2025) ==
participant "Makefile" as MAKE
participant "Preprocessor" as PREPROC
participant "Compiler" as COMPILER
participant "Source Code" as SOURCE

MAKE -> MAKE : User runs: make DEBUG_FLAGS="DEBUG_MOTION"
MAKE -> PREPROC : Pass -DDEBUG_MOTION to compiler
SOURCE -> SOURCE : Code contains:\nDEBUG_PRINT_MOTION("[MOTION] Value: %d", x);
PREPROC -> PREPROC : Expand macro based on flags
alt DEBUG_MOTION defined
    PREPROC -> PREPROC : DEBUG_PRINT_MOTION â†’ UART_Printf(...)
    PREPROC -> COMPILER : Pass expanded code
    COMPILER -> COMPILER : Compile UART_Printf call
    note right of COMPILER
      Debug build: Full debug output
      ~150 bytes per debug statement
    end note
else DEBUG_MOTION not defined (Release)
    PREPROC -> PREPROC : DEBUG_PRINT_MOTION â†’ ((void)0)
    PREPROC -> COMPILER : Pass no-op expression
    COMPILER -> COMPILER : Optimize away ((void)0)
    note right of COMPILER
      Release build: ZERO overhead
      Debug code completely removed
      Binary size unchanged
    end note
end

note over MAKE, COMPILER
  âœ… Zero runtime overhead in release
  âœ… No if() checks, no runtime cost
  âœ… Pure compile-time elimination
  âœ… Professional embedded pattern
end note

== Build System Flow (November 2025) ==
participant "Developer" as DEV
participant "make" as MAKE
participant "Makefile" as MF

DEV -> MAKE : make (no arguments)
MAKE -> MF : .DEFAULT_GOAL = all
MF -> MF : BUILD_CONFIG = Release (default)
MF -> MF : Execute: make clean
MF -> MF : Execute: make build
note right of MF
  Default: Full rebuild Release
  Fast: make build (incremental)
  Debug: make BUILD_CONFIG=Debug
  Trace: make DEBUG_FLAGS="..."
end note

@enduml