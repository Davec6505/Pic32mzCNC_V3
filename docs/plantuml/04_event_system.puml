@startuml event_system
title G-Code Event System Architecture - Clean Abstraction Layer Respect
!theme blueprint

participant "UART2\n(G-code Input)" as UART
participant "GCODE_Tasks\n(Parser)" as GCODE
participant "APP_Tasks\n(Your Control)" as APP
participant "Motion Queue\n(appData)" as MOTION
participant "Kinematics\n(Physics)" as KINEMATICS
participant "Stepper\n(Hardware)" as STEPPER

== Event System Overview ==
note over UART, STEPPER
  âœ… Clean Architecture: Parser never touches APP_DATA
  âœ… Event-Driven: GCODE_GetNextEvent() is only interface  
  âœ… Your Control: APP_Tasks routes all events through YOUR abstraction
  âœ… Professional: Zero memory allocation, deterministic processing
end note

== G-Code Reception & Parsing ==
UART -> GCODE : "G90G1X100Y25F1000S200M3\\n"
GCODE -> GCODE : Tokenize â†’ ["G90", "G1X100Y25F1000", "S200", "M3"]
GCODE -> GCODE : Store in gcodeCommandQueue (16-command buffer)
note right of GCODE
  Parser focuses purely on parsing
  No execution logic or APP_DATA access
  Clean separation of concerns
end note

== Event Processing Loop ==
APP -> GCODE : GCODE_GetNextEvent(&appData.gcodeCommandQueue, &event)

activate GCODE
GCODE -> GCODE : Parse next command â†’ GCODE_Event structure
alt Command: "G90"
    GCODE -> APP : event.type = GCODE_EVENT_SET_ABSOLUTE
end
deactivate GCODE

APP -> APP : Update coordinate mode in YOUR state management
note right of APP
  Your abstraction layer
  controls all state
end note

APP -> GCODE : GCODE_GetNextEvent(&appData.gcodeCommandQueue, &event)
activate GCODE
alt Command: "G1X100Y25F1000"
    GCODE -> GCODE : Extract coordinates & feedrate
    GCODE -> APP : event.type = GCODE_EVENT_LINEAR_MOVE\\nevent.data.linearMove = {x:100, y:25, z:0, a:0, feedrate:1000}
end
deactivate GCODE

== Your Motion Processing ==
APP -> KINEMATICS : KINEMATICS_LinearMove(currentPos, event.data.linearMove, &segment)
KINEMATICS -> KINEMATICS : Physics calculations, Bresenham parameters
KINEMATICS -> APP : Return MotionSegment

APP -> APP : Add to YOUR motion queue through YOUR abstraction
note right of APP
  if (appData.motionQueueCount < MAX_MOTION_SEGMENTS) {
      memcpy(&appData.motionQueue[appData.motionQueueHead], 
             &segment, sizeof(MotionSegment));
      appData.motionQueueHead = (appData.motionQueueHead + 1) % MAX_MOTION_SEGMENTS;
      appData.motionQueueCount++;
  }
end note

== Auxiliary Command Processing ==
APP -> GCODE : GCODE_GetNextEvent(&appData.gcodeCommandQueue, &event)
activate GCODE
alt Command: "S200"  
    GCODE -> APP : event.type = GCODE_EVENT_SPINDLE_ON\\nevent.data.spindle.rpm = 200
end
deactivate GCODE

APP -> APP : Handle spindle control through YOUR interfaces
note right of APP
  SPINDLE_SetSpeed(event.data.spindle.rpm);
  Your hardware control layer
end note

APP -> GCODE : GCODE_GetNextEvent(&appData.gcodeCommandQueue, &event)
activate GCODE
alt Command: "M3"
    GCODE -> APP : event.type = GCODE_EVENT_SPINDLE_ON\\n(RPM from previous S command)
end  
deactivate GCODE

== Motion Execution (Your Existing System) ==
APP -> MOTION : Process segments from appData.motionQueue
MOTION -> STEPPER : Execute via absolute compare mode
STEPPER -> STEPPER : TMR2-based pulse generation
note right of STEPPER
  Your existing motion system
  unchanged and unaffected
end note

== Event System Benefits ==
note over UART, STEPPER
  ðŸ† **Architecture Benefits:**
  â€¢ Perfect abstraction layer preservation
  â€¢ APP_DATA can evolve without breaking parser
  â€¢ Clean testable interfaces
  â€¢ Professional separation of concerns
  
  ðŸš€ **Performance Benefits:**  
  â€¢ Zero memory allocation
  â€¢ Deterministic processing time
  â€¢ Real-time system compatibility
  â€¢ Event consumption at YOUR pace
  
  ðŸ”§ **Maintenance Benefits:**
  â€¢ Easy to add new G-code commands
  â€¢ Independent module testing  
  â€¢ Clear debugging boundaries
  â€¢ Future-proof architecture
end note

== Debug System Integration (November 2025) ==
participant "Debug Macros" as DEBUG
participant "UART Output" as UART_OUT

APP -> DEBUG : DEBUG_PRINT_GCODE("[GCODE] Event: %d\\n", event.type)
alt DEBUG_GCODE defined (Debug Build)
    DEBUG -> UART_OUT : UART_Printf("[GCODE] Event: 1\\n")
    note right of UART_OUT
      Debug output appears
      Trace event processing
      Zero runtime checks
    end note
else DEBUG_GCODE not defined (Release Build)
    DEBUG -> DEBUG : ((void)0) - no-op
    note right of DEBUG
      Compiler removes code
      Zero overhead
      No binary size impact
    end note
end

KINEMATICS -> DEBUG : DEBUG_PRINT_MOTION("[MOTION] dX=%ld dY=%ld\\n", dx, dy)
alt DEBUG_MOTION defined
    DEBUG -> UART_OUT : UART_Printf("[MOTION] dX=400 dY=100\\n")
else DEBUG_MOTION not defined
    DEBUG -> DEBUG : Code eliminated by compiler
end

STEPPER -> DEBUG : DEBUG_EXEC_STEPPER(LED1_Toggle())
alt DEBUG_STEPPER defined
    DEBUG -> DEBUG : Execute: LED1_Toggle()
    note right
      Visual indicator
      ISR-safe execution
      Conditional compilation
    end note
else DEBUG_STEPPER not defined
    DEBUG -> DEBUG : Code eliminated
end

note over DEBUG, UART_OUT
  âœ… Compile-time debugging
  âœ… Six subsystems: MOTION, GCODE, STEPPER,
     SEGMENT, UART, APP
  âœ… Usage: make DEBUG_FLAGS="DEBUG_MOTION"
  âœ… Zero runtime overhead in release
end note

@enduml