# V3 Architecture Refactor - November 7, 2025

## Overview
Refactored from **failed absolute compare mode with 4 OC modules** to **proven GRBL-style single master timer + GPIO control**.

---

## ‚úÖ COMPLETED: stepper.c/.h Refactor

### Architecture Changes
| Aspect | Before (V3 Old) | After (V3 New) |
|--------|-----------------|----------------|
| **OC Modules** | 4 (OC1/3/4/5) | **1 (OC1 master)** |
| **OC Mode** | Absolute compare (0x0006) | **Continuous pulse (0x0005)** |
| **Timer** | TMR2 32-bit free-running | **TMR2 16-bit period-based** |
| **Step Pulses** | OCx hardware outputs | **GPIO LATC SET/CLR** |
| **Bresenham** | Main loop phases | **ISR (OC1_ISR)** |
| **Velocity** | Adjust `currentStepInterval` | **Update PR2** |
| **ISR Count** | 4 ISRs (never fired!) | **1 ISR (OC1 only)** |

### Files Modified
1. ‚úÖ `srcs/motion/stepper.c` - Complete rewrite
   - Removed: OCP5_ISR, OCP3_ISR, OCP4_ISR
   - Removed: `STEPPER_ScheduleStep()`, `STEPPER_DisableAxis()`
   - Removed: `STEPPER_CheckTimerRollover()` (no longer needed)
   - Added: Single `OCP1_ISR()` with Bresenham + GPIO control
   - Added: `STEPPER_LoadSegment()` - loads deltas, directions, errors
   - Added: `STEPPER_SetStepRate()` - updates PR2 for velocity

2. ‚úÖ `incs/motion/stepper.h` - Updated API
   - Removed: Complex scheduling functions
   - Added: Simple segment loading interface

### Key Implementation Details

#### Static Variables (ISR State)
```c
static volatile int32_t error_y, error_z, error_a;  // Bresenham errors
static volatile int32_t dominant_delta;              // Largest axis delta
static volatile int32_t delta_x, delta_y, delta_z, delta_a;  // Segment deltas
static volatile uint8_t direction_bits;              // Direction state
static uint32_t pulse_width_cycles = 1000;           // ~5¬µs @ 200MHz CPU
```

#### OC1 ISR Pattern (GRBL Style)
```c
void OCP1_ISR(uintptr_t context) {
    LED2_Toggle();  // Visual debug
    
    // 1. Determine dominant axis (largest delta)
    // 2. Pulse dominant axis GPIO pin (LATCSET)
    // 3. Run Bresenham for subordinate axes
    // 4. Pulse width delay (~5¬µs loop)
    // 5. Clear all GPIO pins (LATCCLR)
    // 6. Signal main loop (motionPhase = VELOCITY)
}
```

#### Segment Loading Pattern
```c
STEPPER_LoadSegment(segment);
// - Loads deltas (delta_x/y/z/a)
// - Initializes Bresenham errors
// - Sets direction bits + GPIO direction pins
// - Sets PR2 for initial step rate
```

#### Velocity Profiling Pattern
```c
STEPPER_SetStepRate(new_rate_ticks);
// - Updates PR2 directly
// - OC1 automatically adjusts period
// - ISR fires at new rate on next period match
```

---

## ‚è≥ REMAINING: motion.c Simplification

### Current State
- Still has complex phase system (VELOCITY/BRESENHAM/SCHEDULE/COMPLETE)
- Still calls `STEPPER_ScheduleStep()` (no longer exists!)
- Still uses TMR2 polling
- Still has dominant axis tracking logic

### Required Changes
1. **Simplify APP_Tasks phases:**
   - Remove: MOTION_PHASE_BRESENHAM (now in ISR)
   - Remove: MOTION_PHASE_SCHEDULE (no scheduling needed)
   - Keep: MOTION_PHASE_VELOCITY (update PR2 only)
   - Keep: MOTION_PHASE_COMPLETE (segment done detection)

2. **Replace segment loading:**
   ```c
   // OLD (complex scheduling):
   STEPPER_SetDirection(axis, forward);
   STEPPER_ScheduleStep(axis, offset);
   
   // NEW (simple loading):
   STEPPER_LoadSegment(current_segment);  // All axes at once
   ```

3. **Replace velocity update:**
   ```c
   // OLD (update interval variable):
   appData->currentStepInterval = new_rate;
   
   // NEW (update PR2 directly):
   STEPPER_SetStepRate(new_rate);
   ```

4. **Remove TMR2 polling:**
   - Delete watchdog timeout logic (lines 348-358)
   - Delete TMR2 rollover checks

5. **Remove dominant axis tracking:**
   - `dominantAxis` no longer needed (ISR determines it dynamically)
   - Remove from APP_DATA

---

## ‚è≥ REMAINING: data_structures.h Cleanup

### Required Changes
1. **Remove from APP_DATA:**
   ```c
   MotionPhase motionPhase;           // ‚ùå Remove (simplify to 2 states)
   E_AXIS dominantAxis;               // ‚ùå Remove (ISR calculates)
   int32_t bresenham_error_y/z/a;     // ‚ùå Remove (now in stepper.c)
   uint32_t currentStepInterval;      // ‚ùå Remove (use PR2 directly)
   ```

2. **Keep essential fields:**
   ```c
   MotionSegment* currentSegment;     // ‚úÖ Keep
   MotionSegment motionQueue[16];     // ‚úÖ Keep
   uint32_t motionQueueHead/Tail/Count;  // ‚úÖ Keep
   ```

---

## üß™ Testing Plan (After MCC Regeneration)

### Step 1: Hardware Verification
- OC1 configured: Continuous pulse mode (0x0005), TMR2 source
- TMR2 configured: 16-bit mode, prescaler set
- RC1/RC2/RC3/RC4 configured as GPIO outputs (step pins)
- RD0/RD1/RD2/RD3 configured as GPIO outputs (direction pins)

### Step 2: Firmware Flash
```bash
make clean
make all
make flash
```

### Step 3: Basic Motion Test
```gcode
G92 X0 Y0 Z0    # Set work origin
G1 X1 F100      # Move 1mm in X axis at 100 mm/min
?               # Query status (should show position incrementing)
```

### Step 4: Oscilloscope Verification
- Probe RC1 (X_STEP) - should see ~500Hz pulses during motion
- LED2 should blink rapidly during motion (ISR visual debug)
- Verify 5¬µs pulse width

### Step 5: Multi-Axis Test
```gcode
G1 X10 Y10 F500    # Diagonal motion (tests Bresenham)
?                  # Verify both X and Y increment
```

---

## üìä Performance Expectations

### ISR Execution Time
- **Dominant axis step**: 10-15 cycles (GPIO set, position update)
- **Bresenham per axis**: 20-30 cycles (accumulate, compare, branch)
- **Pulse delay**: 1000 cycles (~5¬µs @ 200MHz)
- **GPIO clear**: 5 cycles
- **Total**: ~1100 cycles = **5.5¬µs @ 200MHz**

### Step Rate Capability
- **Maximum**: 25kHz (PR2 = 500 @ 12.5MHz)
- **256 microstepping**: 97 steps/sec ‚Üí ~5860 RPM @ 200 steps/rev
- **64 microstepping**: 390 steps/sec ‚Üí ~23,400 RPM @ 200 steps/rev

---

## üéØ Next Steps

1. **YOU:** Finish MCC reconfiguration (OC1 + TMR2 + GPIO pins)
2. **ME:** Refactor motion.c (simplify phases, remove scheduling)
3. **ME:** Update data_structures.h (remove obsolete fields)
4. **BOTH:** Flash and test firmware
5. **BOTH:** Oscilloscope verification of step pulses

---

## üîë Key Benefits of New Architecture

‚úÖ **Simpler** - 1 ISR vs 4, no multi-module coordination  
‚úÖ **More reliable** - Hardware period-based timing (not software scheduling)  
‚úÖ **Proven pattern** - GRBL uses this exact approach  
‚úÖ **Easier to debug** - GPIO pins easy to scope, LED2 visual confirmation  
‚úÖ **Lower CPU overhead** - No TMR2 polling, no scheduling calculations  
‚úÖ **Better velocity control** - Direct PR2 updates, no scheduling lag  

---

**Status:** 
- ‚úÖ Stepper module refactored (stepper.c/stepper.h) - COMPLETE
- ‚úÖ MOTION_SegmentTasks() simplified - COMPLETE  
- ‚è≥ MOTION_Tasks() needs simplification - **IN PROGRESS**
- ‚è≥ MCC config complete, awaiting firmware flash

## üö® IMMEDIATE ACTION NEEDED

The build is failing because `MOTION_Tasks()` still has old phase-based code that calls deleted functions:
- Line 237, 258: `STEPPER_ScheduleStep()` calls (function deleted)
- Line 359, 368, 377: More `STEPPER_ScheduleStep()` calls
- Line 362, 371, 380: `STEPPER_DisableAxis()` calls (function deleted)

**Quick Fix**: Comment out or delete the entire phase processing system (lines ~230-450 in motion.c) and replace with simple segment loading + velocity updates (like MOTION_SegmentTasks).

**Permanent Solution**: The MOTION_Tasks() function needs the same simplification as MOTION_SegmentTasks() - remove phases, just load segments and update PR2.
